diff -u -p a/db-5.2.28.NC/examples/stl/StlTransactionGuideExample.cpp b/db-5.2.28.NC/examples/stl/StlTransactionGuideExample.cpp
--- a/db-5.2.28.NC/examples/stl/StlTransactionGuideExample.cpp
+++ b/db-5.2.28.NC/examples/stl/StlTransactionGuideExample.cpp
@@ -9,6 +9,10 @@
 // File txn_guide_stl.cpp
 #include <iostream>
 #include <db_cxx.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #include "dbstl_map.h"
 
@@ -42,7 +46,7 @@ typedef HANDLE mutex_t;
 
 typedef pthread_t thread_t;
 #define thread_create(thrp, attr, func, arg)                               \
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define thread_join(thr, statusp) pthread_join((thr), (statusp))
 
 typedef pthread_mutex_t mutex_t;
diff -u -p a/db-5.2.28.NC/examples/stl/repquote/StlRepQuoteExample.cpp b/db-5.2.28.NC/examples/stl/repquote/StlRepQuoteExample.cpp
--- a/db-5.2.28.NC/examples/stl/repquote/StlRepQuoteExample.cpp
+++ b/db-5.2.28.NC/examples/stl/repquote/StlRepQuoteExample.cpp
@@ -55,6 +55,10 @@ using namespace dbstl;
 const char *progname = "exstl_repquote";
 
 #include <errno.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 #ifdef _WIN32
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
@@ -81,7 +85,7 @@ typedef DWORD thread_exit_status_t;
 typedef pthread_t thread_t;
 typedef void* thread_exit_status_t;
 #define	thread_create(thrp, attr, func, arg)				   \
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define	thread_join(thr, statusp) pthread_join((thr), (statusp))
 #endif
 
diff -u -p a/db-5.2.28.NC/examples/cxx/excxx_repquote/RepQuoteExample.cpp b/db-5.2.28.NC/examples/cxx/excxx_repquote/RepQuoteExample.cpp
--- a/db-5.2.28.NC/examples/cxx/excxx_repquote/RepQuoteExample.cpp
+++ b/db-5.2.28.NC/examples/cxx/excxx_repquote/RepQuoteExample.cpp
@@ -58,6 +58,10 @@ using std::getline;
 const char *progname = "excxx_repquote";
 
 #include <errno.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 #ifdef _WIN32
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
@@ -83,7 +87,7 @@ typedef DWORD thread_exit_status_t;
 typedef pthread_t thread_t;
 typedef void* thread_exit_status_t;
 #define	thread_create(thrp, attr, func, arg)				   \
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define	thread_join(thr, statusp) pthread_join((thr), (statusp))
 #endif
 
diff -u -p a/db-5.2.28.NC/examples/cxx/txn_guide/TxnGuide.cpp b/db-5.2.28.NC/examples/cxx/txn_guide/TxnGuide.cpp
--- a/db-5.2.28.NC/examples/cxx/txn_guide/TxnGuide.cpp
+++ b/db-5.2.28.NC/examples/cxx/txn_guide/TxnGuide.cpp
@@ -12,6 +12,10 @@
 #include <cstring>
 #include <iostream>
 #include <db_cxx.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #ifdef _WIN32
 #include <windows.h>
@@ -43,7 +47,7 @@ typedef HANDLE mutex_t;
 
 typedef pthread_t thread_t;
 #define thread_create(thrp, attr, func, arg)                               \
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define thread_join(thr, statusp) pthread_join((thr), (statusp))
 
 typedef pthread_mutex_t mutex_t;
diff -u -p a/db-5.2.28.NC/examples/cxx/txn_guide/TxnGuideInMemory.cpp b/db-5.2.28.NC/examples/cxx/txn_guide/TxnGuideInMemory.cpp
--- a/db-5.2.28.NC/examples/cxx/txn_guide/TxnGuideInMemory.cpp
+++ b/db-5.2.28.NC/examples/cxx/txn_guide/TxnGuideInMemory.cpp
@@ -12,6 +12,10 @@
 #include <cstring>
 #include <iostream>
 #include <db_cxx.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #ifdef _WIN32
 #include <windows.h>
@@ -43,7 +47,7 @@ typedef HANDLE mutex_t;
 
 typedef pthread_t thread_t;
 #define thread_create(thrp, attr, func, arg)                               \
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define thread_join(thr, statusp) pthread_join((thr), (statusp))
 
 typedef pthread_mutex_t mutex_t;
diff -u -p a/db-5.2.28.NC/lang/tcl/tcl_internal.c b/db-5.2.28.NC/lang/tcl/tcl_internal.c
--- a/db-5.2.28.NC/lang/tcl/tcl_internal.c
+++ b/db-5.2.28.NC/lang/tcl/tcl_internal.c
@@ -786,7 +786,7 @@ _GetFlagsList(interp, flags, fnp)
 	 * specified Tcl list.
 	 */
 	for (; fnp->mask != 0; ++fnp)
-		if (LF_ISSET(fnp->mask)) {
+		if (((flags) & (fnp->mask))) {
 			newobj = NewStringObj(fnp->name, strlen(fnp->name));
 			result =
 			    Tcl_ListObjAppendElement(interp, newlist, newobj);
diff -u -p a/db-5.2.28.NC/lang/tcl/tcl_db.c b/db-5.2.28.NC/lang/tcl/tcl_db.c
--- a/db-5.2.28.NC/lang/tcl/tcl_db.c
+++ b/db-5.2.28.NC/lang/tcl/tcl_db.c
@@ -3386,7 +3386,7 @@ tcl_DbGetFlags(interp, objc, objv, dbp)
 		buf[0] = '\0';
 
 		for (i = 0; db_flags[i].flag != 0; i++)
-			if (LF_ISSET(db_flags[i].flag)) {
+			if (((flags) & (db_flags[i].flag))) {
 				if (strlen(buf) > 0)
 					(void)strncat(buf, " ", sizeof(buf));
 				(void)strncat(
@@ -3442,7 +3442,7 @@ tcl_DbGetOpenFlags(interp, objc, objv, d
 		buf[0] = '\0';
 
 		for (i = 0; open_flags[i].flag != 0; i++)
-			if (LF_ISSET(open_flags[i].flag)) {
+			if (((flags) & (open_flags[i].flag))) {
 				if (strlen(buf) > 0)
 					(void)strncat(buf, " ", sizeof(buf));
 				(void)strncat(
@@ -3847,11 +3847,11 @@ tcl_DbCompact(interp, objc, objv, dbp)
 			fillfactor = arg;
 			break;
 		case DBREORG_FREESPACE:
-			LF_SET(DB_FREE_SPACE);
+			((flags) |= (DB_FREE_SPACE));
 			break;
 
 		case DBREORG_FREEONLY:
-			LF_SET(DB_FREELIST_ONLY);
+			((flags) |= (DB_FREELIST_ONLY));
 			break;
 
 		case DBREORG_PAGES:
diff -u -p a/db-5.2.28.NC/lang/tcl/tcl_seq.c b/db-5.2.28.NC/lang/tcl/tcl_seq.c
--- a/db-5.2.28.NC/lang/tcl/tcl_seq.c
+++ b/db-5.2.28.NC/lang/tcl/tcl_seq.c
@@ -553,7 +553,7 @@ tcl_SeqGetFlags(interp, objc, objv, seq)
 		buf[0] = '\0';
 
 		for (i = 0; seq_flags[i].flag != 0; i++)
-			if (LF_ISSET(seq_flags[i].flag)) {
+			if (((flags) & (seq_flags[i].flag))) {
 				if (strlen(buf) > 0)
 					(void)strncat(buf, " ", sizeof(buf));
 				(void)strncat(
diff -u -p a/db-5.2.28.NC/lang/tcl/tcl_db_pkg.c b/db-5.2.28.NC/lang/tcl/tcl_db_pkg.c
--- a/db-5.2.28.NC/lang/tcl/tcl_db_pkg.c
+++ b/db-5.2.28.NC/lang/tcl/tcl_db_pkg.c
@@ -2955,7 +2955,7 @@ bdb_SeqOpen(interp, objc, objv, ip, seqp
 			oflags |= DB_CREATE;
 			break;
 		case TCL_SEQ_INC:
-			LF_SET(DB_SEQ_INC);
+			((flags) |= (DB_SEQ_INC));
 			break;
 		case TCL_SEQ_CACHESIZE:
 			if (i >= objc) {
@@ -2980,7 +2980,7 @@ bdb_SeqOpen(interp, objc, objv, ip, seqp
 			setvalue = 1;
 			break;
 		case TCL_SEQ_DEC:
-			LF_SET(DB_SEQ_DEC);
+			((flags) |= (DB_SEQ_DEC));
 			break;
 		case TCL_SEQ_MAX:
 			if (i >= objc) {
@@ -3029,7 +3029,7 @@ bdb_SeqOpen(interp, objc, objv, ip, seqp
 			}
 			break;
 		case TCL_SEQ_WRAP:
-			LF_SET(DB_SEQ_WRAP);
+			((flags) |= (DB_SEQ_WRAP));
 			break;
 		case TCL_SEQ_ENDARG:
 			endarg = 1;
@@ -4734,14 +4734,14 @@ tcl_isalive(dbenv, pid, tid, flags)
 	int answer, result;
 
 	__os_id(dbenv, &mypid, &mytid);
-	if (mypid == pid && (LF_ISSET(DB_MUTEX_PROCESS_ONLY) ||
+	if (mypid == pid && (((flags) & (DB_MUTEX_PROCESS_ONLY)) ||
 	    mytid == tid))
 		return (1);
 	/*
 	 * We only support the PROCESS_ONLY case for now, because that seems
 	 * easiest, and that's all we need for our tests for the moment.
 	 */
-	if (!LF_ISSET(DB_MUTEX_PROCESS_ONLY))
+	if (!((flags) & (DB_MUTEX_PROCESS_ONLY)))
 		return (1);
 
 	ip = (DBTCL_INFO *)dbenv->app_private;
@@ -4845,13 +4845,13 @@ tcl_rep_send(dbenv, control, rec, lsnp,
 	myobjv[myobjc = 0] = NULL;
 	if (flags == 0)
 		myobjv[myobjc++] = NewStringObj("none", strlen("none"));
-	if (LF_ISSET(DB_REP_ANYWHERE))
+	if (((flags) & (DB_REP_ANYWHERE)))
 		myobjv[myobjc++] = NewStringObj("any", strlen("any"));
-	if (LF_ISSET(DB_REP_NOBUFFER))
+	if (((flags) & (DB_REP_NOBUFFER)))
 		myobjv[myobjc++] = NewStringObj("nobuffer", strlen("nobuffer"));
-	if (LF_ISSET(DB_REP_PERMANENT))
+	if (((flags) & (DB_REP_PERMANENT)))
 		myobjv[myobjc++] = NewStringObj("perm", strlen("perm"));
-	if (LF_ISSET(DB_REP_REREQUEST))
+	if (((flags) & (DB_REP_REREQUEST)))
 		myobjv[myobjc++] =
 		    NewStringObj("rerequest", strlen("rerequest"));
 	/*
diff -u -p a/db-5.2.28.NC/lang/tcl/tcl_env.c b/db-5.2.28.NC/lang/tcl/tcl_env.c
--- a/db-5.2.28.NC/lang/tcl/tcl_env.c
+++ b/db-5.2.28.NC/lang/tcl/tcl_env.c
@@ -2784,7 +2784,7 @@ env_GetFlags(interp, objc, objv, dbenv)
 		buf[0] = '\0';
 
 		for (i = 0; open_flags[i].flag != 0; i++)
-			if (LF_ISSET(open_flags[i].flag)) {
+			if (((flags) & (open_flags[i].flag))) {
 				if (strlen(buf) > 0)
 					(void)strncat(buf, " ", sizeof(buf));
 				(void)strncat(
@@ -2850,7 +2850,7 @@ env_GetOpenFlag(interp, objc, objv, dben
 		buf[0] = '\0';
 
 		for (i = 0; open_flags[i].flag != 0; i++)
-			if (LF_ISSET(open_flags[i].flag)) {
+			if (((flags) & (open_flags[i].flag))) {
 				if (strlen(buf) > 0)
 					(void)strncat(buf, " ", sizeof(buf));
 				(void)strncat(
@@ -2902,7 +2902,7 @@ tcl_EnvGetEncryptFlags(interp, objc, obj
 		buf[0] = '\0';
 
 		for (i = 0; encrypt_flags[i].flag != 0; i++)
-			if (LF_ISSET(encrypt_flags[i].flag)) {
+			if (((flags) & (encrypt_flags[i].flag))) {
 				if (strlen(buf) > 0)
 					(void)strncat(buf, " ", sizeof(buf));
 				(void)strncat(
diff -u -p a/db-5.2.28.NC/lang/sql/sqlite/src/mutex_unix.c b/db-5.2.28.NC/lang/sql/sqlite/src/mutex_unix.c
--- a/db-5.2.28.NC/lang/sql/sqlite/src/mutex_unix.c
+++ b/db-5.2.28.NC/lang/sql/sqlite/src/mutex_unix.c
@@ -313,9 +313,9 @@ static void pthreadMutexLeave(sqlite3_mu
   assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );
 
 #ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
-  if( p->nRef==0 ){
+  if( p->nRef==0 )
     pthread_mutex_unlock(&p->mutex);
-  }
+  
 #else
   pthread_mutex_unlock(&p->mutex);
 #endif
diff -u -p a/db-5.2.28.NC/lang/sql/sqlite/src/test_server.c b/db-5.2.28.NC/lang/sql/sqlite/src/test_server.c
--- a/db-5.2.28.NC/lang/sql/sqlite/src/test_server.c
+++ b/db-5.2.28.NC/lang/sql/sqlite/src/test_server.c
@@ -466,7 +466,7 @@ void sqlite3_server_start(void){
   pthread_t x;
   int rc;
   g.serverHalt = 0;
-  rc = pthread_create(&x, 0, sqlite3_server, 0);
+  rc = liblock_thread_create(&x, 0, sqlite3_server, 0);
   if( rc==0 ){
     pthread_detach(x);
   }
diff -u -p a/db-5.2.28.NC/lang/sql/sqlite/src/test4.c b/db-5.2.28.NC/lang/sql/sqlite/src/test4.c
--- a/db-5.2.28.NC/lang/sql/sqlite/src/test4.c
+++ b/db-5.2.28.NC/lang/sql/sqlite/src/test4.c
@@ -145,7 +145,7 @@ static int tcl_thread_create(
   threadset[i].zFilename = sqlite3_mprintf("%s", argv[2]);
   threadset[i].opnum = 1;
   threadset[i].completed = 0;
-  rc = pthread_create(&x, 0, thread_main, &threadset[i]);
+  rc = liblock_thread_create(&x, 0, thread_main, &threadset[i]);
   if( rc ){
     Tcl_AppendResult(interp, "failed to create the thread", 0);
     sqlite3_free(threadset[i].zFilename);
diff -u -p a/db-5.2.28.NC/lang/sql/sqlite/src/test_thread.c b/db-5.2.28.NC/lang/sql/sqlite/src/test_thread.c
--- a/db-5.2.28.NC/lang/sql/sqlite/src/test_thread.c
+++ b/db-5.2.28.NC/lang/sql/sqlite/src/test_thread.c
@@ -17,6 +17,10 @@
 
 #include "sqliteInt.h"
 #include <tcl.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #if SQLITE_THREADSAFE
 
diff -u -p a/db-5.2.28.NC/lang/sql/sqlite/src/test7.c b/db-5.2.28.NC/lang/sql/sqlite/src/test7.c
--- a/db-5.2.28.NC/lang/sql/sqlite/src/test7.c
+++ b/db-5.2.28.NC/lang/sql/sqlite/src/test7.c
@@ -167,7 +167,7 @@ static int tcl_client_create(
   threadset[i].zFilename = sqlite3_mprintf("%s", argv[2]);
   threadset[i].opnum = 1;
   threadset[i].completed = 0;
-  rc = pthread_create(&x, 0, client_main, &threadset[i]);
+  rc = liblock_thread_create(&x, 0, client_main, &threadset[i]);
   if( rc ){
     Tcl_AppendResult(interp, "failed to create the thread", 0);
     sqlite3_free(threadset[i].zFilename);
diff -u -p a/db-5.2.28.NC/lang/sql/sqlite/test/threadtest3.c b/db-5.2.28.NC/lang/sql/sqlite/test/threadtest3.c
--- a/db-5.2.28.NC/lang/sql/sqlite/test/threadtest3.c
+++ b/db-5.2.28.NC/lang/sql/sqlite/test/threadtest3.c
@@ -81,6 +81,10 @@
 #include <string.h>
 #include <fcntl.h>
 #include <errno.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 /*
  * This code implements the MD5 message-digest algorithm.
@@ -741,7 +745,7 @@ static void launch_thread_x(
     p->iArg = iArg;
     p->xProc = xProc;
 
-    rc = pthread_create(&p->tid, NULL, launch_thread_main, (void *)p);
+    rc = liblock_thread_create(&p->tid, NULL, launch_thread_main, (void *)p);
     if( rc!=0 ){
       system_error(pErr, rc);
       sqlite3_free(p);
diff -u -p a/db-5.2.28.NC/lang/sql/sqlite/test/threadtest2.c b/db-5.2.28.NC/lang/sql/sqlite/test/threadtest2.c
--- a/db-5.2.28.NC/lang/sql/sqlite/test/threadtest2.c
+++ b/db-5.2.28.NC/lang/sql/sqlite/test/threadtest2.c
@@ -20,6 +20,10 @@
 #include <pthread.h>
 #include <string.h>
 #include <stdlib.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 #include "sqlite.h"
 
 /*
@@ -118,7 +122,7 @@ int main(int argc, char **argv){
   }
   sqlite3_close(db);
   for(i=0; i<sizeof(aThread)/sizeof(aThread[0]); i++){
-    pthread_create(&aThread[i], 0, worker, (void*)i);
+    liblock_thread_create(&aThread[i], 0, worker, (void*)i);
   }
   for(i=0; i<sizeof(aThread)/sizeof(aThread[i]); i++){
     pthread_join(aThread[i], 0);
diff -u -p a/db-5.2.28.NC/lang/sql/sqlite/test/threadtest1.c b/db-5.2.28.NC/lang/sql/sqlite/test/threadtest1.c
--- a/db-5.2.28.NC/lang/sql/sqlite/test/threadtest1.c
+++ b/db-5.2.28.NC/lang/sql/sqlite/test/threadtest1.c
@@ -28,6 +28,10 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 /*
 ** Enable for tracing
@@ -272,7 +276,7 @@ int main(int argc, char **argv){
       free(zJournal);
     }
       
-    pthread_create(&id, 0, worker_bee, (void*)zFile);
+    liblock_thread_create(&id, 0, worker_bee, (void*)zFile);
     pthread_detach(id);
   }
   pthread_mutex_lock(&lock);
diff -u -p a/db-5.2.28.NC/build_vxworks/util/db_recover.c b/db-5.2.28.NC/build_vxworks/util/db_recover.c
--- a/db-5.2.28.NC/build_vxworks/util/db_recover.c
+++ b/db-5.2.28.NC/build_vxworks/util/db_recover.c
@@ -150,10 +150,9 @@ db_recover_main(argc, argv)
 	 * certainly use DB_CONFIG files in the directory.
 	 */
 	flags = 0;
-	LF_SET(DB_CREATE | DB_INIT_LOG |
-	    DB_INIT_MPOOL | DB_INIT_TXN | DB_USE_ENVIRON);
-	LF_SET(fatal_recover ? DB_RECOVER_FATAL : DB_RECOVER);
-	LF_SET(retain_env ? DB_INIT_LOCK : DB_PRIVATE);
+	((flags) |= (DB_CREATE | DB_INIT_LOG | DB_INIT_MPOOL | DB_INIT_TXN | DB_USE_ENVIRON));
+	((flags) |= (fatal_recover ? DB_RECOVER_FATAL : DB_RECOVER));
+	((flags) |= (retain_env ? DB_INIT_LOCK : DB_PRIVATE));
 	if ((ret = dbenv->open(dbenv, home, flags, 0)) != 0) {
 		dbenv->err(dbenv, ret, "DB_ENV->open");
 		goto err;
diff -u -p a/db-5.2.28.NC/build_vxworks/util/db_stat.c b/db-5.2.28.NC/build_vxworks/util/db_stat.c
--- a/db-5.2.28.NC/build_vxworks/util/db_stat.c
+++ b/db-5.2.28.NC/build_vxworks/util/db_stat.c
@@ -74,7 +74,7 @@ db_stat_main(argc, argv)
 	    argv, "aC:cd:Eefgh:L:lM:mNP:R:rs:tVxX:Z")) != EOF)
 		switch (ch) {
 		case 'a':
-			LF_SET(DB_STAT_ALLOC);
+			((flags) |= (DB_STAT_ALLOC));
 			break;
 		case 'C': case 'c':
 			if (ttype != T_NOTSET && ttype != T_LOCK)
@@ -84,21 +84,21 @@ db_stat_main(argc, argv)
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 					case 'A':
-						LF_SET(DB_STAT_ALL);
+						((flags) |= (DB_STAT_ALL));
 						break;
 					case 'c':
-						LF_SET(DB_STAT_LOCK_CONF);
+						((flags) |= (DB_STAT_LOCK_CONF));
 						break;
 					case 'l':
-						LF_SET(DB_STAT_LOCK_LOCKERS);
+						((flags) |= (DB_STAT_LOCK_LOCKERS));
 						break;
 					case 'm': /* Backward compatible. */
 						break;
 					case 'o':
-						LF_SET(DB_STAT_LOCK_OBJECTS);
+						((flags) |= (DB_STAT_LOCK_OBJECTS));
 						break;
 					case 'p':
-						LF_SET(DB_STAT_LOCK_PARAMS);
+						((flags) |= (DB_STAT_LOCK_PARAMS));
 						break;
 					default:
 						return (db_stat_usage());
@@ -114,15 +114,15 @@ db_stat_main(argc, argv)
 			if (ttype != T_NOTSET && ttype != T_ENV)
 				goto argcombo;
 			ttype = T_ENV;
-			LF_SET(DB_STAT_SUBSYSTEM);
+			((flags) |= (DB_STAT_SUBSYSTEM));
 			if (ch == 'E')
-				LF_SET(DB_STAT_ALL);
+				((flags) |= (DB_STAT_ALL));
 			break;
 		case 'f':
 			if (ttype != T_NOTSET && ttype != T_DB)
 				goto argcombo;
 			ttype = T_DB;
-			LF_SET(DB_FAST_STAT);
+			((flags) |= (DB_FAST_STAT));
 			break;
 		case 'h':
 			home = optarg;
@@ -135,7 +135,7 @@ db_stat_main(argc, argv)
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 					case 'A':
-						LF_SET(DB_STAT_ALL);
+						((flags) |= (DB_STAT_ALL));
 						break;
 					default:
 						return (db_stat_usage());
@@ -149,10 +149,10 @@ db_stat_main(argc, argv)
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 					case 'A':
-						LF_SET(DB_STAT_ALL);
+						((flags) |= (DB_STAT_ALL));
 						break;
 					case 'h':
-						LF_SET(DB_STAT_MEMP_HASH);
+						((flags) |= (DB_STAT_MEMP_HASH));
 						break;
 					case 'm': /* Backward compatible. */
 						break;
@@ -181,7 +181,7 @@ db_stat_main(argc, argv)
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 					case 'A':
-						LF_SET(DB_STAT_ALL);
+						((flags) |= (DB_STAT_ALL));
 						break;
 					default:
 						return (db_stat_usage());
@@ -213,14 +213,14 @@ argcombo:			fprintf(stderr, DB_STR_A("50
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 						case 'A':
-							LF_SET(DB_STAT_ALL);
+							((flags) |= (DB_STAT_ALL));
 							break;
 						default:
 							return (db_stat_usage());
 					}
 			break;
 		case 'Z':
-			LF_SET(DB_STAT_CLEAR);
+			((flags) |= (DB_STAT_CLEAR));
 			break;
 		case '?':
 		default:
@@ -246,7 +246,7 @@ argcombo:			fprintf(stderr, DB_STR_A("50
 		return (db_stat_usage());
 	}
 
-	if (LF_ISSET(DB_STAT_ALL | DB_STAT_ALLOC) == DB_STAT_ALLOC)
+	if (((flags) & (DB_STAT_ALL | DB_STAT_ALLOC)) == DB_STAT_ALLOC)
 		return (db_stat_usage());
 
 	/* Handle possible interruptions. */
diff -u -p a/db-5.2.28.NC/build_vxworks/util/db_upgrade.c b/db-5.2.28.NC/build_vxworks/util/db_upgrade.c
--- a/db-5.2.28.NC/build_vxworks/util/db_upgrade.c
+++ b/db-5.2.28.NC/build_vxworks/util/db_upgrade.c
@@ -80,7 +80,7 @@ db_upgrade_main(argc, argv)
 			}
 			break;
 		case 's':
-			LF_SET(DB_DUPSORT);
+			((flags) |= (DB_DUPSORT));
 			break;
 		case 'V':
 			printf("%s\n", db_version(NULL, NULL, NULL));
diff -u -p a/db-5.2.28.NC/build_vxworks/util/db_load.c b/db-5.2.28.NC/build_vxworks/util/db_load.c
--- a/db-5.2.28.NC/build_vxworks/util/db_load.c
+++ b/db-5.2.28.NC/build_vxworks/util/db_load.c
@@ -317,7 +317,7 @@ db_load_load(dbenv, name, argtype, clist
 	int ascii_recno, checkprint, hexkeys, keyflag, keys, resize, ret, rval;
 	char *subdb;
 
-	put_flags = LF_ISSET(LDF_NOOVERWRITE) ? DB_NOOVERWRITE : 0;
+	put_flags = ((flags) & (LDF_NOOVERWRITE)) ? DB_NOOVERWRITE : 0;
 	G(endodata) = 0;
 
 	dbc = NULL;
@@ -341,7 +341,7 @@ retry_db:
 	}
 
 	/* Read the header -- if there's no header, we expect flat text. */
-	if (LF_ISSET(LDF_NOHEADER)) {
+	if (((flags) & (LDF_NOHEADER))) {
 		checkprint = 1;
 		dbtype = argtype;
 	} else {
@@ -435,7 +435,7 @@ retry_db:
 		ascii_recno = 0;
 
 	/* If configured with a password, encrypt databases we create. */
-	if (LF_ISSET(LDF_PASSWORD) &&
+	if (((flags) & (LDF_PASSWORD)) &&
 	    (ret = dbp->set_flags(dbp, DB_ENCRYPT)) != 0) {
 		dbp->err(dbp, ret, "DB->set_flags: DB_ENCRYPT");
 		goto err;
@@ -707,8 +707,8 @@ db_load_db_init(dbenv, home, cache, is_p
 	 * an mpool region exists).  Create one, but make it private so that
 	 * no files are actually created.
 	 */
-	LF_CLR(DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_TXN);
-	LF_SET(DB_CREATE | DB_PRIVATE);
+	((flags) &= ~(DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_TXN));
+	((flags) |= (DB_CREATE | DB_PRIVATE));
 	*is_private = 1;
 	if ((ret = dbenv->set_cachesize(dbenv, 0, cache, 1)) != 0) {
 		dbenv->err(dbenv, ret, "set_cachesize");
diff -u -p a/db-5.2.28.NC/build_vxworks/util/db_archive.c b/db-5.2.28.NC/build_vxworks/util/db_archive.c
--- a/db-5.2.28.NC/build_vxworks/util/db_archive.c
+++ b/db-5.2.28.NC/build_vxworks/util/db_archive.c
@@ -64,16 +64,16 @@ db_archive_main(argc, argv)
 	while ((ch = getopt(argc, argv, "adh:lP:sVv")) != EOF)
 		switch (ch) {
 		case 'a':
-			LF_SET(DB_ARCH_ABS);
+			((flags) |= (DB_ARCH_ABS));
 			break;
 		case 'd':
-			LF_SET(DB_ARCH_REMOVE);
+			((flags) |= (DB_ARCH_REMOVE));
 			break;
 		case 'h':
 			home = optarg;
 			break;
 		case 'l':
-			LF_SET(DB_ARCH_LOG);
+			((flags) |= (DB_ARCH_LOG));
 			break;
 		case 'P':
 			passwd = strdup(optarg);
@@ -86,7 +86,7 @@ db_archive_main(argc, argv)
 			}
 			break;
 		case 's':
-			LF_SET(DB_ARCH_DATA);
+			((flags) |= (DB_ARCH_DATA));
 			break;
 		case 'V':
 			printf("%s\n", db_version(NULL, NULL, NULL));
diff -u -p a/db-5.2.28.NC/build_vxworks/util/db_verify.c b/db-5.2.28.NC/build_vxworks/util/db_verify.c
--- a/db-5.2.28.NC/build_vxworks/util/db_verify.c
+++ b/db-5.2.28.NC/build_vxworks/util/db_verify.c
@@ -82,13 +82,13 @@ db_verify_main(argc, argv)
 			}
 			break;
 		case 'o':
-			LF_SET(DB_NOORDERCHK);
+			((flags) |= (DB_NOORDERCHK));
 			break;
 		case 'q':
 			quiet = 1;
 			break;
 		case 'u':			/* Undocumented. */
-			LF_SET(DB_UNREF);
+			((flags) |= (DB_UNREF));
 			break;
 		case 'V':
 			printf("%s\n", db_version(NULL, NULL, NULL));
diff -u -p a/db-5.2.28.NC/build_vxworks/test/micro/b_latch.c b/db-5.2.28.NC/build_vxworks/test/micro/b_latch.c
--- a/db-5.2.28.NC/build_vxworks/test/micro/b_latch.c
+++ b/db-5.2.28.NC/build_vxworks/test/micro/b_latch.c
@@ -175,7 +175,7 @@ b_latch(argc, argv)
 #ifdef _POSIX_THREADS
 	if (nthreads > 0) {
 		for (i = 0; i < nthreads; i++)
-			DB_BENCH_ASSERT(pthread_create(&threads[i].id,
+			DB_BENCH_ASSERT(liblock_thread_create(&threads[i].id,
 			    NULL, b_latch_latch_threadmain, &threads[i]) == 0);
 		for (i = 0; i < nthreads; i++) {
 			ret = pthread_join(threads[i].id, &status);
diff -u -p a/db-5.2.28.NC/examples/c/ex_thread.c b/db-5.2.28.NC/examples/c/ex_thread.c
--- a/db-5.2.28.NC/examples/c/ex_thread.c
+++ b/db-5.2.28.NC/examples/c/ex_thread.c
@@ -24,6 +24,10 @@ extern int getopt(int, char * const *, c
 #endif
 
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 /*
  * NB: This application is written using POSIX 1003.1b-1993 pthreads
@@ -186,17 +190,17 @@ main(argc, argv)
 
 	/* Create reader/writer threads. */
 	for (i = 0; i < nreaders + nwriters; ++i)
-		if ((ret = pthread_create(
+		if ((ret = liblock_thread_create(
 		    &tids[i], NULL, tstart, (void *)(uintptr_t)i)) != 0)
 			fatal("pthread_create", ret > 0 ? ret : errno, 1);
 
 	/* Create buffer pool trickle thread. */
-	if (pthread_create(&tids[i], NULL, trickle, &i))
+	if (liblock_thread_create(&tids[i], NULL, trickle, &i))
 		fatal("pthread_create", errno, 1);
 	++i;
 
 	/* Create deadlock detector thread. */
-	if (pthread_create(&tids[i], NULL, deadlock, &i))
+	if (liblock_thread_create(&tids[i], NULL, deadlock, &i))
 		fatal("pthread_create", errno, 1);
 
 	/* Wait for the threads. */
diff -u -p a/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan.h b/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan.h
--- a/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan.h
+++ b/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan.h
@@ -92,7 +92,7 @@ typedef HANDLE mutex_t;
 
 typedef pthread_t thread_t;
 #define	thread_create(thrp, attr, func, arg)				   \
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define	thread_join(thr, statusp) pthread_join((thr), (statusp))
 
 typedef pthread_mutex_t mutex_t;
diff -u -p a/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan.c b/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan.c
--- a/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan.c
+++ b/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan.c
@@ -15,6 +15,10 @@
 #include <unistd.h>
 #endif
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #include "rep_chan.h"
 
diff -u -p a/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan_util.c b/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan_util.c
--- a/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan_util.c
+++ b/db-5.2.28.NC/examples/c/ex_rep_chan/rep_chan_util.c
@@ -15,6 +15,10 @@
 #include <unistd.h>
 #endif
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #include "rep_chan.h"
 
diff -u -p a/db-5.2.28.NC/examples/c/ex_rep/common/rep_common.h b/db-5.2.28.NC/examples/c/ex_rep/common/rep_common.h
--- a/db-5.2.28.NC/examples/c/ex_rep/common/rep_common.h
+++ b/db-5.2.28.NC/examples/c/ex_rep/common/rep_common.h
@@ -65,7 +65,7 @@ typedef HANDLE thread_t;
 
 typedef pthread_t thread_t;
 #define	thread_create(thrp, attr, func, arg)				   \
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define	thread_join(thr, statusp) pthread_join((thr), (statusp))
 
 #endif
diff -u -p a/db-5.2.28.NC/examples/c/ex_rep/base/rep_base.c b/db-5.2.28.NC/examples/c/ex_rep/base/rep_base.c
--- a/db-5.2.28.NC/examples/c/ex_rep/base/rep_base.c
+++ b/db-5.2.28.NC/examples/c/ex_rep/base/rep_base.c
@@ -13,6 +13,10 @@
 #include <string.h>
 
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #include "rep_base.h"
 
diff -u -p a/db-5.2.28.NC/examples/c/ex_rep/base/rep_net.c b/db-5.2.28.NC/examples/c/ex_rep/base/rep_net.c
--- a/db-5.2.28.NC/examples/c/ex_rep/base/rep_net.c
+++ b/db-5.2.28.NC/examples/c/ex_rep/base/rep_net.c
@@ -13,6 +13,10 @@
 #include <string.h>
 
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 #include "rep_base.h"
 #ifndef _SYS_QUEUE_H
 /*
diff -u -p a/db-5.2.28.NC/examples/c/ex_rep/base/rep_msg.c b/db-5.2.28.NC/examples/c/ex_rep/base/rep_msg.c
--- a/db-5.2.28.NC/examples/c/ex_rep/base/rep_msg.c
+++ b/db-5.2.28.NC/examples/c/ex_rep/base/rep_msg.c
@@ -13,6 +13,10 @@
 #include <string.h>
 
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #include "rep_base.h"
 
diff -u -p a/db-5.2.28.NC/examples/c/ex_rep/mgr/rep_mgr.c b/db-5.2.28.NC/examples/c/ex_rep/mgr/rep_mgr.c
--- a/db-5.2.28.NC/examples/c/ex_rep/mgr/rep_mgr.c
+++ b/db-5.2.28.NC/examples/c/ex_rep/mgr/rep_mgr.c
@@ -15,6 +15,10 @@
 #endif
 
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #include "../common/rep_common.h"
 
diff -u -p a/db-5.2.28.NC/examples/c/ex_rep/common/rep_common.c b/db-5.2.28.NC/examples/c/ex_rep/common/rep_common.c
--- a/db-5.2.28.NC/examples/c/ex_rep/common/rep_common.c
+++ b/db-5.2.28.NC/examples/c/ex_rep/common/rep_common.c
@@ -12,6 +12,10 @@
 #include <time.h>
 
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #include "rep_common.h"
 
diff -u -p a/db-5.2.28.NC/examples/c/txn_guide/txn_guide.c b/db-5.2.28.NC/examples/c/txn_guide/txn_guide.c
--- a/db-5.2.28.NC/examples/c/txn_guide/txn_guide.c
+++ b/db-5.2.28.NC/examples/c/txn_guide/txn_guide.c
@@ -13,6 +13,10 @@
 #include <stdlib.h>
 #include <string.h>
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #ifdef _WIN32
 #include <windows.h>
@@ -43,7 +47,7 @@ typedef HANDLE mutex_t;
 
 typedef pthread_t thread_t;
 #define	thread_create(thrp, attr, func, arg)                               \
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define	thread_join(thr, statusp) pthread_join((thr), (statusp))
 
 typedef pthread_mutex_t mutex_t;
diff -u -p a/db-5.2.28.NC/examples/c/txn_guide/txn_guide_inmemory.c b/db-5.2.28.NC/examples/c/txn_guide/txn_guide_inmemory.c
--- a/db-5.2.28.NC/examples/c/txn_guide/txn_guide_inmemory.c
+++ b/db-5.2.28.NC/examples/c/txn_guide/txn_guide_inmemory.c
@@ -13,6 +13,10 @@
 #include <stdlib.h>
 #include <string.h>
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #ifdef _WIN32
 #include <windows.h>
@@ -43,7 +47,7 @@ typedef HANDLE mutex_t;
 
 typedef pthread_t thread_t;
 #define	thread_create(thrp, attr, func, arg)                               \
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define	thread_join(thr, statusp) pthread_join((thr), (statusp))
 
 typedef pthread_mutex_t mutex_t;
diff -u -p a/db-5.2.28.NC/examples/sql/c/ex_sql_utils.h b/db-5.2.28.NC/examples/sql/c/ex_sql_utils.h
--- a/db-5.2.28.NC/examples/sql/c/ex_sql_utils.h
+++ b/db-5.2.28.NC/examples/sql/c/ex_sql_utils.h
@@ -71,7 +71,7 @@ void load_table_from_file(sqlite3*, samp
   typedef pthread_t       os_thread_t;
   #define os_thread_id()  pthread_self()
   #define os_thread_create(pid, func, arg)                    \
-       (0 == pthread_create(pid, NULL, func, arg))
+       (0 == liblock_thread_create(pid, NULL, func, arg))
 #endif
 
 /* Program should register the thread id for following join_threads(). */
diff -u -p a/db-5.2.28.NC/src/dbreg/dbreg_stat.c b/db-5.2.28.NC/src/dbreg/dbreg_stat.c
--- a/db-5.2.28.NC/src/dbreg/dbreg_stat.c
+++ b/db-5.2.28.NC/src/dbreg/dbreg_stat.c
@@ -29,7 +29,7 @@ __dbreg_stat_print(env, flags)
 {
 	int ret;
 
-	if (LF_ISSET(DB_STAT_ALL) &&
+	if (((flags) & (DB_STAT_ALL)) &&
 	    (ret = __dbreg_print_all(env, flags)) != 0)
 		return (ret);
 
lock on line 37 in file ../bd-orig/db-5.2.28.NC/src/dbreg/dbreg.c has no unlock
MLOCK ( env , fnp -> mutex )
unlock on line 48 in file ../bd-orig/db-5.2.28.NC/src/dbreg/dbreg.c has no lock
diff -u -p a/db-5.2.28.NC/src/dbreg/dbreg.c b/db-5.2.28.NC/src/dbreg/dbreg.c
--- a/db-5.2.28.NC/src/dbreg/dbreg.c
+++ b/db-5.2.28.NC/src/dbreg/dbreg.c
@@ -199,8 +199,10 @@ __dbreg_teardown(dbp)
 	 * We may not have an FNAME if we were never opened.  This is not an
 	 * error.
 	 */
-	if (dbp->log_filename == NULL)
-		return (0);
+	if (dbp->log_filename == NULL) {
+		
+			return (0);
+		}
 
 	ret = __dbreg_teardown_int(dbp->env, dbp->log_filename);
 
@@ -229,8 +231,10 @@ __dbreg_teardown_int(env, fnp)
 	REGINFO *infop;
 	int ret;
 
-	if (F_ISSET(fnp, DB_FNAME_NOTLOGGED))
-		return (0);
+	if (F_ISSET(fnp, DB_FNAME_NOTLOGGED)) {
+		
+			return (0);
+		}
 	dblp = env->lg_handle;
 	infop = &dblp->reginfo;
 #ifdef HAVE_STATISTICS
@@ -525,8 +529,10 @@ __dbreg_revoke_id_int(env, fnp, have_loc
 	ret = 0;
 
 	/* If we lack an ID, this is a null-op. */
-	if (fnp == NULL)
-		return (0);
+	if (fnp == NULL) {
+		
+			return (0);
+		}
 
 	/*
 	 * If we have a force_id, we had an error after allocating
@@ -536,8 +542,10 @@ __dbreg_revoke_id_int(env, fnp, have_loc
 	if (force_id != DB_LOGFILEID_INVALID)
 		id = force_id;
 	else if (fnp->id == DB_LOGFILEID_INVALID) {
-		if (fnp->old_id == DB_LOGFILEID_INVALID)
-			return (0);
+		if (fnp->old_id == DB_LOGFILEID_INVALID) {
+			
+				return (0);
+			}
 		id = fnp->old_id;
 	} else
 		id = fnp->id;
@@ -564,6 +572,39 @@ __dbreg_revoke_id_int(env, fnp, have_loc
 	return (ret);
 }
 
+union instance8 {struct input6{FNAME *fnp;ENV *env;int ret;} input6;
+struct output5{int ret;} output5;};
+void * function9(void *ctx7);
+void *function9(void *ctx7) {
+	{
+		struct output5 *outcontext3=&(((union instance8 *)ctx7)->output5);
+		struct input6 *incontext4=&(((union instance8 *)ctx7)->input6);
+		int t_ret;
+		int ret1;
+		FNAME *fnp=incontext4->fnp;
+		ENV *env=incontext4->env;
+		int ret=incontext4->ret;
+		ret = ret;
+		{
+			ret1 = 0;
+			if (fnp->txn_ref > 1) {
+				if ((t_ret = __dbreg_rem_dbentry(env->lg_handle, fnp->id)) != 0 && ret == 0)
+					ret = t_ret;
+				F_SET(fnp, DB_FNAME_CLOSED);
+				fnp->txn_ref--;
+				ret1 = 0 + 1;
+				goto done2;
+			}
+			done2:
+			{
+				
+			}
+		}
+		outcontext3->ret = ret;
+		return (void *)(uintptr_t)ret1;
+	}
+}
+
 /*
  * __dbreg_close_id --
  *	Take a dbreg id away from a dbp that we're closing, and log
@@ -577,6 +618,7 @@ __dbreg_close_id(dbp, txn, op)
 	DB_TXN *txn;
 	u_int32_t op;
 {
+	int ret1;
 	DB_LOG *dblp;
 	ENV *env;
 	FNAME *fnp;
@@ -589,8 +631,10 @@ __dbreg_close_id(dbp, txn, op)
 	fnp = dbp->log_filename;
 
 	/* If we lack an ID, this is a null-op. */
-	if (fnp == NULL)
-		return (0);
+	if (fnp == NULL) {
+		
+			return (0);
+		}
 
 	if (fnp->id == DB_LOGFILEID_INVALID) {
 		ret = __dbreg_revoke_id(dbp, 0, DB_LOGFILEID_INVALID);
@@ -606,7 +650,24 @@ __dbreg_close_id(dbp, txn, op)
 	ret = 0;
 	DB_ASSERT(env, fnp->txn_ref > 0);
 	if (fnp->txn_ref > 1) {
-		MUTEX_LOCK(env, dbp->mutex);
+		{ union instance8 instance8 = {
+			{
+				fnp,
+				env,
+				ret,
+			},
+		};
+		#if 0
+{
+		struct output5 *outcontext3 = &(((union instance8 *)ctx7)->output5);
+		struct input6 *incontext4 = &(((union instance8 *)ctx7)->input6);
+		int t_ret;
+		int ret1;
+		FNAME *fnp = incontext4->fnp;
+		ENV *env = incontext4->env;
+		int ret = incontext4->ret;
+		ret = ret;{
+		ret1 = 0;
 		if (fnp->txn_ref > 1) {
 			if ((t_ret = __dbreg_rem_dbentry(
 			    env->lg_handle, fnp->id)) != 0 && ret == 0)
@@ -620,13 +681,29 @@ __dbreg_close_id(dbp, txn, op)
 			 */
 			F_SET(fnp, DB_FNAME_CLOSED);
 			fnp->txn_ref--;
-			MUTEX_UNLOCK(env, dbp->mutex);
-			/* The mutex now lives only in the FNAME. */
-			dbp->mutex = MUTEX_INVALID;
-			dbp->log_filename = NULL;
-			return (ret); // jll
+			ret1 = 0 + 1;
+			__GOTO__(done2);}
+		done2: {
+			
+		}
+		}outcontext3->ret = ret;
+		
+		__RETURN__((void *)(uintptr_t)ret1);
 		}
-		MUTEX_UNLOCK(env, dbp->mutex); // jll
+#endif
+		ret1 =(int)(uintptr_t)(liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance8),
+					  &function9));
+		ret = instance8.output5.ret;
+		}
+		if (ret1) {
+			if (ret1 == 0 + 1)
+				{
+					dbp->mutex = MUTEX_INVALID;
+					dbp->log_filename = NULL;
+					return(ret);
+				}
+			
+		} // jll
 	}
 	MUTEX_LOCK(env, lp->mtx_filelist);
 
@@ -663,12 +740,16 @@ __dbreg_close_id_int(env, fnp, op, locke
 	dblp = env->lg_handle;
 	lp = dblp->reginfo.primary;
 
-	if (fnp->id == DB_LOGFILEID_INVALID)
-		return (__dbreg_revoke_id_int(env,
+	if (fnp->id == DB_LOGFILEID_INVALID) {
+		
+			return (__dbreg_revoke_id_int(env,
 		     fnp, locked, 1, DB_LOGFILEID_INVALID));
+		}
 
-	if (F_ISSET(fnp, DB_FNAME_RECOVER))
-		return (__dbreg_close_file(env, fnp));
+	if (F_ISSET(fnp, DB_FNAME_RECOVER)) {
+		
+			return (__dbreg_close_file(env, fnp));
+		}
 	/*
 	 * If log_close fails then it will mark the name DB_FNAME_NOTLOGGED
 	 * and the id must persist.
@@ -708,8 +789,10 @@ __dbreg_failchk(env)
 	int ret, t_ret;
 	char buf[DB_THREADID_STRLEN];
 
-	if ((dblp = env->lg_handle) == NULL)
-		return (0);
+	if ((dblp = env->lg_handle) == NULL) {
+		
+			return (0);
+		}
 
 	lp = dblp->reginfo.primary;
 	dbenv = env->dbenv;
@@ -720,7 +803,7 @@ __dbreg_failchk(env)
 		nnp = SH_TAILQ_NEXT(fnp, q, __fname);
 		if (dbenv->is_alive(dbenv, fnp->pid, 0, DB_MUTEX_PROCESS_ONLY))
 			continue;
-		MUTEX_LOCK(env, fnp->mutex);
+		liblock_relock_in_cs(MLOCK(env, fnp->mutex));
 		__db_msg(env, DB_STR_A("1502",
 		    "Freeing log information for process: %s, (ref %lu)",
 		    "%s %lu"),
@@ -731,7 +814,7 @@ __dbreg_failchk(env)
 				fnp->txn_ref--;
 				F_SET(fnp, DB_FNAME_CLOSED);
 			}
-			MUTEX_UNLOCK(env, fnp->mutex);
+			liblock_unlock_in_cs(MLOCK(env, fnp->mutex));
 			fnp->mutex = MUTEX_INVALID;
 			fnp->pid = 0;
 		} else {
@@ -904,8 +987,10 @@ __dbreg_pluck_id(env, id)
 	dblp = env->lg_handle;
 	lp = dblp->reginfo.primary;
 
-	if (id >= lp->fid_max)
-		return (0);
+	if (id >= lp->fid_max) {
+		
+			return (0);
+		}
 
 	/* Do we have anything to look at? */
 	if (lp->free_fid_stack != INVALID_ROFF) {
diff -u -p a/db-5.2.28.NC/src/qam/qam.c b/db-5.2.28.NC/src/qam/qam.c
--- a/db-5.2.28.NC/src/qam/qam.c
+++ b/db-5.2.28.NC/src/qam/qam.c
@@ -587,11 +587,11 @@ __qamc_del(dbc, flags)
 	 * the metapage and check again as lower numbered
 	 * record may have been inserted.
 	 */
-	if (LF_ISSET(DB_CONSUME) || cp->recno == first) {
+	if (((flags) & (DB_CONSUME)) || cp->recno == first) {
 		if ((ret = __memp_fget(mpf, &metapg,
 		    dbc->thread_info, dbc->txn, DB_MPOOL_DIRTY, &meta)) != 0)
 			goto err;
-		if (LF_ISSET(DB_CONSUME) || cp->recno == meta->first_recno)
+		if (((flags) & (DB_CONSUME)) || cp->recno == meta->first_recno)
 			ret = __qam_consume(dbc, meta, RECNO_OOB);
 	}
 
@@ -1392,7 +1392,7 @@ __qam_bulk(dbc, data, flags)
 	recs = ((QUEUE *)dbp->q_internal)->rec_page;
 	metapno = ((QUEUE *)dbp->q_internal)->q_meta;
 
-	is_key = LF_ISSET(DB_MULTIPLE_KEY) ? 1 : 0;
+	is_key = ((flags) & (DB_MULTIPLE_KEY)) ? 1 : 0;
 	size = 0;
 
 	dbuf = data->data;
diff -u -p a/db-5.2.28.NC/src/qam/qam_verify.c b/db-5.2.28.NC/src/qam/qam_verify.c
--- a/db-5.2.28.NC/src/qam/qam_verify.c
+++ b/db-5.2.28.NC/src/qam/qam_verify.c
@@ -171,7 +171,7 @@ err:	if ((t_ret = __db_vrfy_putpageinfo(
 		__os_free(env, buf);
 	if (ret != 0 && extents != NULL)
 		__os_free(env, extents);
-	if (LF_ISSET(DB_SALVAGE) &&
+	if (((flags) & (DB_SALVAGE)) &&
 	   (t_ret = __db_salvage_markdone(vdp, pgno)) != 0 && ret == 0)
 		ret = t_ret;
 	return (ret == 0 && isbad == 1 ? DB_VERIFY_BAD : ret);
@@ -375,7 +375,7 @@ __qam_vrfy_structure(dbp, vdp, flags)
 
 	for (i = 1; i <= vdp->last_pgno; i++) {
 		/* Send feedback to the application about our progress. */
-		if (!LF_ISSET(DB_SALVAGE))
+		if (!((flags) & (DB_SALVAGE)))
 			__db_vrfy_struct_feedback(dbp, vdp);
 
 		if ((ret = __db_vrfy_putpageinfo(dbp->env, vdp, pip)) != 0 ||
@@ -453,7 +453,7 @@ begin:	for (; i <= stop; i++) {
 		 * If DB_SALVAGE is set, we inspect our database of completed
 		 * pages, and skip any we've already printed in the subdb pass.
 		 */
-		if (LF_ISSET(DB_SALVAGE) && (__db_salvage_isdone(vdp, i) != 0))
+		if (((flags) & (DB_SALVAGE)) && (__db_salvage_isdone(vdp, i) != 0))
 			continue;
 		if ((t_ret = __qam_fget(dbc, &i, 0, &h)) != 0) {
 			if (t_ret == ENOENT || t_ret == DB_PAGE_NOTFOUND) {
@@ -465,7 +465,7 @@ begin:	for (; i <= stop; i++) {
 			 * If an individual page get fails, keep going iff
 			 * we're salvaging.
 			 */
-			if (LF_ISSET(DB_SALVAGE)) {
+			if (((flags) & (DB_SALVAGE))) {
 				if (ret == 0)
 					ret = t_ret;
 				continue;
@@ -475,7 +475,7 @@ begin:	for (; i <= stop; i++) {
 			goto err;
 		}
 
-		if (LF_ISSET(DB_SALVAGE)) {
+		if (((flags) & (DB_SALVAGE))) {
 			/*
 			 * We pretty much don't want to quit unless a
 			 * bomb hits.  May as well return that something
@@ -531,7 +531,7 @@ put:			if ((ret = __db_vrfy_putpageinfo(
 
 		/* Again, keep going iff we're salvaging. */
 		if ((t_ret = __qam_fput(dbc, i, h, dbp->priority)) != 0) {
-			if (LF_ISSET(DB_SALVAGE)) {
+			if (((flags) & (DB_SALVAGE))) {
 				if (ret == 0)
 					ret = t_ret;
 				continue;
@@ -552,7 +552,7 @@ put:			if ((ret = __db_vrfy_putpageinfo(
 	 * Now check to see if there were any lingering
 	 * extents and dump their data.
 	 */
-	if (LF_ISSET(DB_SALVAGE) && nextents != 0) {
+	if (((flags) & (DB_SALVAGE)) && nextents != 0) {
 		nextents--;
 		i = 1 +
 		    vdp->extents[nextents] * vdp->page_ext;
@@ -617,7 +617,7 @@ __qam_salvage(dbp, vdp, pgno, h, handle,
 		if (!F_ISSET(qp, QAM_SET))
 			continue;
 
-		if (!LF_ISSET(DB_AGGRESSIVE) && !F_ISSET(qp, QAM_VALID))
+		if (!((flags) & (DB_AGGRESSIVE)) && !F_ISSET(qp, QAM_VALID))
 			continue;
 
 		dbt.data = qp->data;
diff -u -p a/db-5.2.28.NC/src/qam/qam_method.c b/db-5.2.28.NC/src/qam/qam_method.c
--- a/db-5.2.28.NC/src/qam/qam_method.c
+++ b/db-5.2.28.NC/src/qam/qam_method.c
@@ -76,7 +76,7 @@ again:
 			mpf = mpfp->mpf;
 			mpfp->mpf = NULL;
 			if (mpf != NULL && (t_ret = __memp_fclose(mpf,
-			    LF_ISSET(DB_AM_DISCARD) ? DB_MPOOL_DISCARD : 0))
+			    ((flags) & (DB_AM_DISCARD)) ? DB_MPOOL_DISCARD : 0))
 			    != 0 && ret == 0)
 				ret = t_ret;
 		}
@@ -88,7 +88,7 @@ again:
 		goto again;
 	}
 
-	if (LF_ISSET(DB_AM_DISCARD) &&
+	if (((flags) & (DB_AM_DISCARD)) &&
 	     (t_ret = __qam_nameop(dbp, NULL,
 	     NULL, QAM_NAME_DISCARD)) != 0 && ret == 0)
 		ret = t_ret;
diff -u -p a/db-5.2.28.NC/src/qam/qam_open.c b/db-5.2.28.NC/src/qam/qam_open.c
--- a/db-5.2.28.NC/src/qam/qam_open.c
+++ b/db-5.2.28.NC/src/qam/qam_open.c
@@ -72,7 +72,7 @@ __qam_open(dbp, ip, txn, name, base_pgno
 	 * lock instead.
 	 */
 	if ((ret = __db_cursor(dbp, ip, txn, &dbc,
-	    LF_ISSET(DB_CREATE) && CDB_LOCKING(env) ?
+	    ((flags) & (DB_CREATE)) && CDB_LOCKING(env) ?
 	    DB_WRITECURSOR : 0)) != 0)
 		return (ret);
 
diff -u -p a/db-5.2.28.NC/src/qam/qam_stat.c b/db-5.2.28.NC/src/qam/qam_stat.c
--- a/db-5.2.28.NC/src/qam/qam_stat.c
+++ b/db-5.2.28.NC/src/qam/qam_stat.c
@@ -205,10 +205,10 @@ __qam_stat_print(dbc, flags)
 	dbp = dbc->dbp;
 	env = dbp->env;
 
-	if ((ret = __qam_stat(dbc, &sp, LF_ISSET(DB_FAST_STAT))) != 0)
+	if ((ret = __qam_stat(dbc, &sp, ((flags) & (DB_FAST_STAT)))) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL)) {
+	if (((flags) & (DB_STAT_ALL))) {
 		__db_msg(env, "%s", DB_GLOBAL(db_line));
 		__db_msg(env, "Default Queue database information:");
 	}
diff -u -p a/db-5.2.28.NC/src/qam/qam_files.c b/db-5.2.28.NC/src/qam/qam_files.c
--- a/db-5.2.28.NC/src/qam/qam_files.c
+++ b/db-5.2.28.NC/src/qam/qam_files.c
@@ -19,6 +19,208 @@
 	snprintf((B), (L),						\
 	    QUEUE_EXTENT, (Q)->dir, PATH_SEPARATOR[0], (Q)->name, (I))
 
+union instance22 {struct input20{u_int32_t flags;u_int32_t extid;qam_probe_mode mode;MPFARRAY *array;ENV *env;DB_MPOOLFILE *mpf;int ret;} input20;};
+union instance15 {struct input13{u_int8_t *fid;char *buf;u_int32_t flags;u_int32_t lflags;qam_probe_mode mode;db_pgno_t pgno;QUEUE *qp;ENV *env;DB_MPOOLFILE *mpf;DB *dbp;int ftype;int ret;} input13;
+struct output12{u_int32_t extid;MPFARRAY *array;DB_MPOOLFILE *mpf;} output12;};
+void * function23(void *ctx21);
+void *function23(void *ctx21) {
+	{
+		struct input20 *incontext18=&(((union instance22 *)ctx21)->input20);
+		u_int32_t offset;
+		int t_ret;
+		u_int32_t flags=incontext18->flags;
+		u_int32_t extid=incontext18->extid;
+		qam_probe_mode mode=incontext18->mode;
+		MPFARRAY *array=incontext18->array;
+		ENV *env=incontext18->env;
+		DB_MPOOLFILE *mpf=incontext18->mpf;
+		int ret=incontext18->ret;
+		ret = ret;
+		{
+			offset = extid - array->low_extent;
+			DB_ASSERT(env, array->mpfarray[offset].pinref > 0);
+			if (--array->mpfarray[offset].pinref == 0 && (mode == QAM_PROBE_GET || ret == 0)) {
+				(void)__memp_get_flags(mpf, &flags);
+				if (((flags) & (DB_MPOOL_UNLINK))) {
+					array->mpfarray[offset].mpf = NULL;
+					if ((t_ret = __memp_fclose(mpf, 0)) != 0 && ret == 0)
+						ret = t_ret;
+				}
+			}
+		}
+		return (void *)(uintptr_t)ret;
+	}
+}
+
+void * function16(void *ctx14);
+void *function16(void *ctx14) {
+	{
+		struct output12 *outcontext10=&(((union instance15 *)ctx14)->output12);
+		struct input13 *incontext11=&(((union instance15 *)ctx14)->input13);
+		u_int8_t *fid=incontext11->fid;
+		char *buf=incontext11->buf;
+		u_int32_t openflags;
+		u_int32_t i;
+		u_int32_t maxext;
+		u_int32_t oldext;
+		u_int32_t offset;
+		u_int32_t numext;
+		u_int32_t extid;
+		MPFARRAY *array;
+		int less;
+		u_int32_t flags=incontext11->flags;
+		u_int32_t lflags=incontext11->lflags;
+		qam_probe_mode mode=incontext11->mode;
+		db_pgno_t pgno=incontext11->pgno;
+		QUEUE *qp=incontext11->qp;
+		ENV *env=incontext11->env;
+		DB_MPOOLFILE *mpf=incontext11->mpf;
+		DB *dbp=incontext11->dbp;
+		int ftype=incontext11->ftype;
+		int ret=incontext11->ret;
+		mpf = mpf;
+		ret = ret;
+		{
+			extid = QAM_PAGE_EXTENT(dbp, pgno);
+			array = &qp->array1;
+			if (array->n_extent == 0) {
+				array->n_extent = 4;
+				array->low_extent = extid;
+				numext = offset = oldext = 0;
+				less = 0;
+				goto alloc;
+			}
+			retry:
+			if (extid < array->low_extent) {
+				less = 1;
+				offset = array->low_extent - extid;
+			}else {
+				less = 0;
+				offset = extid - array->low_extent;
+			}
+			if (qp->array2.n_extent != 0 && (extid >= qp->array2.low_extent ? offset > extid - qp->array2.low_extent : offset > qp->array2.low_extent - extid)) {
+				array = &qp->array2;
+				if (extid < array->low_extent) {
+					less = 1;
+					offset = array->low_extent - extid;
+				}else {
+					less = 0;
+					offset = extid - array->low_extent;
+				}
+			}
+			if (less == 1 || offset >= array->n_extent) {
+				oldext = array->n_extent;
+				numext = (array->hi_extent - array->low_extent) + 1;
+				if (less == 1 && offset + numext <= array->n_extent) {
+					memmove(&array->mpfarray[offset], array->mpfarray, numext * sizeof(array->mpfarray[0]));
+					memset(array->mpfarray, 0, offset * sizeof(array->mpfarray[0]));
+					offset = 0;
+				}else
+					if (less == 0 && offset == array->n_extent && (mode == QAM_PROBE_GET || mode == QAM_PROBE_PUT) && array->mpfarray[0].pinref == 0) {
+						mpf = array->mpfarray[0].mpf;
+						if (mpf != NULL && (ret = __memp_fclose(mpf, 0)) != 0)
+							goto err;
+						memmove(&array->mpfarray[0], &array->mpfarray[1], (array->n_extent - 1) * sizeof(array->mpfarray[0]));
+						array->low_extent++;
+						array->hi_extent++;
+						offset--;
+						array->mpfarray[offset].mpf = NULL;
+						array->mpfarray[offset].pinref = 0;
+					}else {
+						maxext = (u_int32_t)UINT32_MAX / (qp->page_ext * qp->rec_page);
+						if (offset >= maxext / 2) {
+							array = &qp->array2;
+							DB_ASSERT(env, array->n_extent == 0);
+							oldext = 0;
+							array->n_extent = 4;
+							array->low_extent = extid;
+							offset = 0;
+							numext = 0;
+						}else
+							if (array->mpfarray[0].pinref == 0) {
+								for (i = 0;i < array->n_extent;i++) {
+									if (array->mpfarray[i].pinref != 0)
+										break;
+									mpf = array->mpfarray[i].mpf;
+									if (mpf == NULL)
+										continue;
+									(void)__memp_get_flags(mpf, &lflags);
+									if (!FLD_ISSET(lflags, DB_MPOOL_UNLINK))
+										break;
+									array->mpfarray[i].mpf = NULL;
+									if ((ret = __memp_fclose(mpf, 0)) != 0)
+										goto err;
+								}
+								if (i == 0)
+									goto increase;
+								memmove(&array->mpfarray[0], &array->mpfarray[i], (array->n_extent - i) * sizeof(array->mpfarray[0]));
+								memset(&array->mpfarray[array->n_extent - i], '\0', i * sizeof(array->mpfarray[0]));
+								array->low_extent += i;
+								array->hi_extent += i;
+								goto retry;
+							}else {
+								increase:
+								array->n_extent += offset;
+								array->n_extent <<= 2;
+							}
+						alloc:
+						if ((ret = __os_realloc(env, array->n_extent * sizeof(struct __qmpf), &array->mpfarray)) != 0)
+							goto err;
+						if (less == 1) {
+							memmove(&array->mpfarray[offset], array->mpfarray, numext * sizeof(array->mpfarray[0]));
+							memset(array->mpfarray, 0, offset * sizeof(array->mpfarray[0]));
+							memset(&array->mpfarray[numext + offset], 0, (array->n_extent - (numext + offset)) * sizeof(array->mpfarray[0]));
+							offset = 0;
+						}else
+							memset(&array->mpfarray[oldext], 0, (array->n_extent - oldext) * sizeof(array->mpfarray[0]));
+					}
+			}
+			if (extid < array->low_extent)
+				array->low_extent = extid;
+			if (extid > array->hi_extent)
+				array->hi_extent = extid;
+			if (array->mpfarray[offset].mpf == NULL) {
+				QAM_EXNAME(qp, extid, buf, sizeof(buf));
+				if ((ret = __memp_fcreate(env, &array->mpfarray[offset].mpf)) != 0)
+					goto err;
+				mpf = array->mpfarray[offset].mpf;
+				(void)__memp_set_lsn_offset(mpf, 0);
+				(void)__memp_set_pgcookie(mpf, &qp->pgcookie);
+				(void)__memp_get_ftype(dbp->mpf, &ftype);
+				(void)__memp_set_ftype(mpf, ftype);
+				(void)__memp_set_clear_len(mpf, dbp->pgsize);
+				__qam_exid(dbp, fid, extid);
+				(void)__memp_set_fileid(mpf, fid);
+				openflags = DB_EXTENT;
+				if (((flags) & (DB_MPOOL_CREATE)))
+					openflags |= DB_CREATE;
+				if (F_ISSET(dbp, DB_AM_RDONLY))
+					openflags |= DB_RDONLY;
+				if (F_ISSET(env->dbenv, DB_ENV_DIRECT_DB))
+					openflags |= DB_DIRECT;
+				if ((ret = __memp_fopen(mpf, NULL, buf, NULL, openflags, qp->mode, dbp->pgsize)) != 0) {
+					array->mpfarray[offset].mpf = NULL;
+					(void)__memp_fclose(mpf, 0);
+					goto err;
+				}
+			}
+			mpf = array->mpfarray[offset].mpf;
+			if (mode == QAM_PROBE_GET)
+				array->mpfarray[offset].pinref++;
+			if (((flags) & (DB_MPOOL_CREATE)))
+				(void)__memp_set_flags(mpf, DB_MPOOL_UNLINK, 0);
+			err:
+			{
+				
+			}
+		}
+		outcontext10->extid = extid;
+		outcontext10->array = array;
+		outcontext10->mpf = mpf;
+		return (void *)(uintptr_t)ret;
+	}
+}
+
 /*
  * __qam_fprobe -- calculate and open extent
  *
@@ -76,7 +278,49 @@ __qam_fprobe(dbc, pgno, addrp, mode, pri
 	 * The file cannot go away because we must have a record locked
 	 * in that file.
 	 */
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance15 instance15 = {
+		{
+			fid,
+			buf,
+			flags,
+			lflags,
+			mode,
+			pgno,
+			qp,
+			env,
+			mpf,
+			dbp,
+			ftype,
+			ret,
+		},
+	};
+	#if 0
+{
+	struct output12 *outcontext10 = &(((union instance15 *)ctx14)->output12);
+	struct input13 *incontext11 = &(((union instance15 *)ctx14)->input13);
+	u_int8_t *fid = incontext11->fid;
+	char *buf = incontext11->buf;
+	u_int32_t openflags;
+	u_int32_t i;
+	u_int32_t maxext;
+	u_int32_t oldext;
+	u_int32_t offset;
+	u_int32_t numext;
+	u_int32_t extid;
+	MPFARRAY *array;
+	int less;
+	u_int32_t flags = incontext11->flags;
+	u_int32_t lflags = incontext11->lflags;
+	qam_probe_mode mode = incontext11->mode;
+	db_pgno_t pgno = incontext11->pgno;
+	QUEUE *qp = incontext11->qp;
+	ENV *env = incontext11->env;
+	DB_MPOOLFILE *mpf = incontext11->mpf;
+	DB *dbp = incontext11->dbp;
+	int ftype = incontext11->ftype;
+	int ret = incontext11->ret;
+	mpf = mpf;
+	ret = ret;{
 	extid = QAM_PAGE_EXTENT(dbp, pgno);
 
 	/* Array1 will always be in use if array2 is in use. */
@@ -256,7 +500,7 @@ alloc:			if ((ret = __os_realloc(env,
 		__qam_exid(dbp, fid, extid);
 		(void)__memp_set_fileid(mpf, fid);
 		openflags = DB_EXTENT;
-		if (LF_ISSET(DB_MPOOL_CREATE))
+		if (((flags) & (DB_MPOOL_CREATE)))
 			openflags |= DB_CREATE;
 		if (F_ISSET(dbp, DB_AM_RDONLY))
 			openflags |= DB_RDONLY;
@@ -283,11 +527,26 @@ alloc:			if ((ret = __os_realloc(env,
 	 * the file may nolonger be empty after this operation
 	 * so we clear the UNLINK flag.
 	 */
-	if (LF_ISSET(DB_MPOOL_CREATE))
+	if (((flags) & (DB_MPOOL_CREATE)))
 		(void)__memp_set_flags(mpf, DB_MPOOL_UNLINK, 0);
 
 err:
-	MUTEX_UNLOCK(env, dbp->mutex);
+{
+	
+}
+	}outcontext10->extid = extid;
+	outcontext10->array = array;
+	outcontext10->mpf = mpf;
+	
+	__RETURN__((void *)(uintptr_t)ret);
+	}
+#endif
+	ret =(int)(uintptr_t)(liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance15),
+				  &function16));
+	extid = instance15.output12.extid;
+	array = instance15.output12.array;
+	mpf = instance15.output12.mpf;
+	}
 
 	if (ret == 0) {
 		pgno--;
@@ -296,8 +555,10 @@ err:
 		case QAM_PROBE_GET:
 			ret = __memp_fget(mpf, &pgno,
 			    dbc->thread_info, dbc->txn, flags, addrp);
-			if (ret == 0)
-				return (0);
+			if (ret == 0) {
+				
+					return (0);
+				}
 			break;
 		case QAM_PROBE_PUT:
 			ret = __memp_fput(mpf,
@@ -311,7 +572,30 @@ err:
 			return (0);
 		}
 
-		MUTEX_LOCK(env, dbp->mutex);
+		{ union instance22 instance22 = {
+			{
+				flags,
+				extid,
+				mode,
+				array,
+				env,
+				mpf,
+				ret,
+			},
+		};
+		#if 0
+{
+		struct input20 *incontext18 = &(((union instance22 *)ctx21)->input20);
+		u_int32_t offset;
+		int t_ret;
+		u_int32_t flags = incontext18->flags;
+		u_int32_t extid = incontext18->extid;
+		qam_probe_mode mode = incontext18->mode;
+		MPFARRAY *array = incontext18->array;
+		ENV *env = incontext18->env;
+		DB_MPOOLFILE *mpf = incontext18->mpf;
+		int ret = incontext18->ret;
+		ret = ret;{
 		/* Recalculate because we dropped the lock. */
 		offset = extid - array->low_extent;
 		DB_ASSERT(env, array->mpfarray[offset].pinref > 0);
@@ -319,18 +603,60 @@ err:
 		    (mode == QAM_PROBE_GET || ret == 0)) {
 			/* Check to see if this file will be unlinked. */
 			(void)__memp_get_flags(mpf, &flags);
-			if (LF_ISSET(DB_MPOOL_UNLINK)) {
+			if (((flags) & (DB_MPOOL_UNLINK))) {
 				array->mpfarray[offset].mpf = NULL;
 				if ((t_ret =
 				    __memp_fclose(mpf, 0)) != 0 && ret == 0)
 					ret = t_ret;
 			}
 		}
-		MUTEX_UNLOCK(env, dbp->mutex);
+		}
+		__RETURN__((void *)(uintptr_t)ret);
+		}
+#endif
+		ret =(int)(uintptr_t)(liblock_execute_operation(env, dbp->mutex,
+					  (void *)(uintptr_t)(&instance22), &function23));
+		}
 	}
 	return (ret);
 }
 
+union instance29 {struct input27{db_pgno_t pgnoaddr;QUEUE *qp;ENV *env;DB *dbp;int ret;} input27;};
+void * function30(void *ctx28);
+void *function30(void *ctx28) {
+	{
+		struct input27 *incontext25=&(((union instance29 *)ctx28)->input27);
+		u_int32_t offset;
+		u_int32_t extid;
+		MPFARRAY *array;
+		DB_MPOOLFILE *mpf;
+		db_pgno_t pgnoaddr=incontext25->pgnoaddr;
+		QUEUE *qp=incontext25->qp;
+		ENV *env=incontext25->env;
+		DB *dbp=incontext25->dbp;
+		int ret=incontext25->ret;
+		ret = ret;
+		{
+			extid = QAM_PAGE_EXTENT(dbp, pgnoaddr);
+			array = &qp->array1;
+			if (array->low_extent > extid || array->hi_extent < extid)
+				array = &qp->array2;
+			offset = extid - array->low_extent;
+			DB_ASSERT(env, extid >= array->low_extent && offset < array->n_extent);
+			if (array->mpfarray[offset].pinref != 0)
+				goto done;
+			mpf = array->mpfarray[offset].mpf;
+			array->mpfarray[offset].mpf = NULL;
+			ret = __memp_fclose(mpf, 0);
+			done:
+			{
+				
+			}
+		}
+		return (void *)(uintptr_t)ret;
+	}
+}
+
 /*
  * __qam_fclose -- close an extent.
  *
@@ -355,7 +681,28 @@ __qam_fclose(dbp, pgnoaddr)
 	env = dbp->env;
 	qp = (QUEUE *)dbp->q_internal;
 
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance29 instance29 = {
+		{
+			pgnoaddr,
+			qp,
+			env,
+			dbp,
+			ret,
+		},
+	};
+	#if 0
+{
+	struct input27 *incontext25 = &(((union instance29 *)ctx28)->input27);
+	u_int32_t offset;
+	u_int32_t extid;
+	MPFARRAY *array;
+	DB_MPOOLFILE *mpf;
+	db_pgno_t pgnoaddr = incontext25->pgnoaddr;
+	QUEUE *qp = incontext25->qp;
+	ENV *env = incontext25->env;
+	DB *dbp = incontext25->dbp;
+	int ret = incontext25->ret;
+	ret = ret;{
 
 	extid = QAM_PAGE_EXTENT(dbp, pgnoaddr);
 	array = &qp->array1;
@@ -375,10 +722,70 @@ __qam_fclose(dbp, pgnoaddr)
 	ret = __memp_fclose(mpf, 0);
 
 done:
-	MUTEX_UNLOCK(env, dbp->mutex);
+{
+	
+}
+	}
+	__RETURN__((void *)(uintptr_t)ret);
+	}
+#endif
+	ret =(int)(uintptr_t)(liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance29),
+				  &function30));
+	}
 	return (ret);
 }
 
+union instance36 {struct input34{db_pgno_t pgnoaddr;QUEUE *qp;ENV *env;DB *dbp;int ret;} input34;};
+void * function37(void *ctx35);
+void *function37(void *ctx35) {
+	{
+		struct input34 *incontext32=&(((union instance36 *)ctx35)->input34);
+		u_int32_t offset;
+		u_int32_t extid;
+		MPFARRAY *array;
+		DB_MPOOLFILE *mpf;
+		db_pgno_t pgnoaddr=incontext32->pgnoaddr;
+		QUEUE *qp=incontext32->qp;
+		ENV *env=incontext32->env;
+		DB *dbp=incontext32->dbp;
+		int ret=incontext32->ret;
+		ret = ret;
+		{
+			extid = QAM_PAGE_EXTENT(dbp, pgnoaddr);
+			array = &qp->array1;
+			if (array->low_extent > extid || array->hi_extent < extid)
+				array = &qp->array2;
+			offset = extid - array->low_extent;
+			DB_ASSERT(env, extid >= array->low_extent && offset < array->n_extent);
+			mpf = array->mpfarray[offset].mpf;
+			if (mpf == NULL)
+				goto err;
+			if (LOGGING_ON(env) && (ret = __log_flush(env, NULL)) != 0)
+				goto err;
+			(void)__memp_set_flags(mpf, DB_MPOOL_UNLINK, 1);
+			if (array->mpfarray[offset].pinref != 0)
+				goto err;
+			array->mpfarray[offset].mpf = NULL;
+			if ((ret = __memp_fclose(mpf, 0)) != 0)
+				goto err;
+			if (offset == 0) {
+				memmove(array->mpfarray, &array->mpfarray[1], (array->hi_extent - array->low_extent) * sizeof(array->mpfarray[0]));
+				array->mpfarray[array->hi_extent - array->low_extent].mpf = NULL;
+				if (array->low_extent != array->hi_extent)
+					array->low_extent++;
+			}else {
+				if (extid == array->hi_extent)
+					array->hi_extent--;
+			}
+			err:
+			{
+				
+			}
+		}
+		return (void *)(uintptr_t)ret;
+	}
+}
+
 /*
  * __qam_fremove -- remove an extent.
  *
@@ -404,7 +811,28 @@ __qam_fremove(dbp, pgnoaddr)
 	env = dbp->env;
 	ret = 0;
 
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance36 instance36 = {
+		{
+			pgnoaddr,
+			qp,
+			env,
+			dbp,
+			ret,
+		},
+	};
+	#if 0
+{
+	struct input34 *incontext32 = &(((union instance36 *)ctx35)->input34);
+	u_int32_t offset;
+	u_int32_t extid;
+	MPFARRAY *array;
+	DB_MPOOLFILE *mpf;
+	db_pgno_t pgnoaddr = incontext32->pgnoaddr;
+	QUEUE *qp = incontext32->qp;
+	ENV *env = incontext32->env;
+	DB *dbp = incontext32->dbp;
+	int ret = incontext32->ret;
+	ret = ret;{
 
 	extid = QAM_PAGE_EXTENT(dbp, pgnoaddr);
 	array = &qp->array1;
@@ -452,7 +880,15 @@ __qam_fremove(dbp, pgnoaddr)
 			array->hi_extent--;
 	}
 
-err:	MUTEX_UNLOCK(env, dbp->mutex);
+err:
+{
+	
+}	}
+__RETURN__((void *)(uintptr_t)ret);
+}
+#endif
+ret =(int)(uintptr_t)(liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance36), &function37));
+}
 
 	return (ret);
 }
@@ -472,11 +908,15 @@ __qam_sync(dbp)
 	 * We can't easily identify the extent files associated with a specific
 	 * Queue file, so flush all Queue extent files.
 	 */
-	if ((ret = __memp_fsync(dbp->mpf)) != 0)
-		return (ret);
-	if (((QUEUE *)dbp->q_internal)->page_ext != 0)
-		return (__memp_sync_int(
+	if ((ret = __memp_fsync(dbp->mpf)) != 0) {
+		
+			return (ret);
+		}
+	if (((QUEUE *)dbp->q_internal)->page_ext != 0) {
+		
+			return (__memp_sync_int(
 		    dbp->env, NULL, 0, DB_SYNC_QUEUE_EXTENT, NULL, NULL));
+		}
 	return (0);
 }
 
@@ -509,23 +949,31 @@ __qam_gen_filelist(dbp, ip, filelistp)
 	qp = (QUEUE *)dbp->q_internal;
 	*filelistp = NULL;
 
-	if (qp->page_ext == 0)
-		return (0);
+	if (qp->page_ext == 0) {
+		
+			return (0);
+		}
 
 	/* This may happen during metapage recovery. */
-	if (qp->name == NULL)
-		return (0);
+	if (qp->name == NULL) {
+		
+			return (0);
+		}
 
 	/* Find out the first and last record numbers in the database. */
 	i = PGNO_BASE_MD;
-	if ((ret = __memp_fget(mpf, &i, ip, NULL, 0, &meta)) != 0)
-		return (ret);
+	if ((ret = __memp_fget(mpf, &i, ip, NULL, 0, &meta)) != 0) {
+		
+			return (ret);
+		}
 
 	current = meta->cur_recno;
 	first = meta->first_recno;
 
-	if ((ret = __memp_fput(mpf, ip, meta, dbp->priority)) != 0)
-		return (ret);
+	if ((ret = __memp_fput(mpf, ip, meta, dbp->priority)) != 0) {
+		
+			return (ret);
+		}
 
 	/*
 	 * Allocate the extent array.  Calculate the worst case number of
@@ -543,14 +991,20 @@ __qam_gen_filelist(dbp, ip, filelistp)
 		extent_cnt =
 		    (current + (UINT32_MAX - first)) / rec_extent + 4;
 
-	if (extent_cnt == 0)
-		return (0);
+	if (extent_cnt == 0) {
+		
+			return (0);
+		}
 	if ((ret = __os_calloc(env,
-	    extent_cnt, sizeof(QUEUE_FILELIST), filelistp)) != 0)
-		return (ret);
+	    extent_cnt, sizeof(QUEUE_FILELIST), filelistp)) != 0) {
+		
+			return (ret);
+		}
 	fp = *filelistp;
-	if ((ret = __db_cursor(dbp, ip, NULL, &dbc, 0)) != 0)
-		return (ret);
+	if ((ret = __db_cursor(dbp, ip, NULL, &dbc, 0)) != 0) {
+		
+			return (ret);
+		}
 
 again:
 	if (current >= first)
@@ -610,8 +1064,10 @@ __qam_extent_names(env, name, namelistp)
 	*namelistp = NULL;
 	filelist = NULL;
 	ENV_GET_THREAD_INFO(env, ip);
-	if ((ret = __db_create_internal(&dbp, env, 0)) != 0)
-		return (ret);
+	if ((ret = __db_create_internal(&dbp, env, 0)) != 0) {
+		
+			return (ret);
+		}
 	if ((ret = __db_open(dbp, ip,
 	    NULL, name, NULL, DB_QUEUE, DB_RDONLY, 0, PGNO_BASE_MD)) != 0)
 		goto done;
@@ -875,14 +1331,20 @@ __qam_lsn_reset(dbp, ip)
 	int ret;
 
 	qp = dbp->q_internal;
-	if (qp->page_ext == 0)
-		return (0);
+	if (qp->page_ext == 0) {
+		
+			return (0);
+		}
 
-	if ((ret = __qam_gen_filelist(dbp, ip, &filelist)) != 0)
-		return (ret);
+	if ((ret = __qam_gen_filelist(dbp, ip, &filelist)) != 0) {
+		
+			return (ret);
+		}
 
-	if (filelist == NULL)
-		return (ret);
+	if (filelist == NULL) {
+		
+			return (ret);
+		}
 
 	for (fp = filelist; fp->mpf != NULL; fp++)
 		if ((ret = __db_lsn_reset(fp->mpf, ip)) != 0)
diff -u -p a/db-5.2.28.NC/src/hash/hash_stat.c b/db-5.2.28.NC/src/hash/hash_stat.c
--- a/db-5.2.28.NC/src/hash/hash_stat.c
+++ b/db-5.2.28.NC/src/hash/hash_stat.c
@@ -148,10 +148,10 @@ __ham_stat_print(dbc, flags)
 	dbp = dbc->dbp;
 	env = dbp->env;
 
-	if ((ret = __ham_stat(dbc, &sp, LF_ISSET(DB_FAST_STAT))) != 0)
+	if ((ret = __ham_stat(dbc, &sp, ((flags) & (DB_FAST_STAT)))) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL)) {
+	if (((flags) & (DB_STAT_ALL))) {
 		__db_msg(env, "%s", DB_GLOBAL(db_line));
 		__db_msg(env, "Default Hash database information:");
 	}
diff -u -p a/db-5.2.28.NC/src/hash/hash_upgrade.c b/db-5.2.28.NC/src/hash/hash_upgrade.c
--- a/db-5.2.28.NC/src/hash/hash_upgrade.c
+++ b/db-5.2.28.NC/src/hash/hash_upgrade.c
@@ -206,7 +206,7 @@ __ham_31_hashmeta(dbp, real_name, flags,
 	newmeta->dbmeta.version = 7;
 
 	/* Upgrade the flags. */
-	if (LF_ISSET(DB_DUPSORT))
+	if (((flags) & (DB_DUPSORT)))
 		F_SET(&newmeta->dbmeta, DB_HASH_DUPSORT);
 
 	*dirtyp = 1;
@@ -243,7 +243,7 @@ __ham_31_hash(dbp, real_name, flags, fhp
 			memcpy(&pgno, HOFFDUP_PGNO(hk), sizeof(db_pgno_t));
 			tpgno = pgno;
 			if ((ret = __db_31_offdup(dbp, real_name, fhp,
-			    LF_ISSET(DB_DUPSORT) ? 1 : 0, &tpgno)) != 0)
+			    ((flags) & (DB_DUPSORT)) ? 1 : 0, &tpgno)) != 0)
 				break;
 			if (pgno != tpgno) {
 				*dirtyp = 1;
diff -u -p a/db-5.2.28.NC/src/hash/hash.c b/db-5.2.28.NC/src/hash/hash.c
--- a/db-5.2.28.NC/src/hash/hash.c
+++ b/db-5.2.28.NC/src/hash/hash.c
@@ -667,9 +667,9 @@ __ham_bulk(dbc, data, flags)
 	pagesize = dbp->pgsize;
 	mpf = dbp->mpf;
 	cp = (HASH_CURSOR *)dbc->internal;
-	is_key = LF_ISSET(DB_MULTIPLE_KEY) ? 1 : 0;
-	next_key = is_key && LF_ISSET(DB_OPFLAGS_MASK) != DB_NEXT_DUP;
-	no_dup = LF_ISSET(DB_OPFLAGS_MASK) == DB_NEXT_NODUP;
+	is_key = ((flags) & (DB_MULTIPLE_KEY)) ? 1 : 0;
+	next_key = is_key && ((flags) & (DB_OPFLAGS_MASK)) != DB_NEXT_DUP;
+	no_dup = ((flags) & (DB_OPFLAGS_MASK)) == DB_NEXT_NODUP;
 	dbuf = data->data;
 	np = dp = dbuf;
 
diff -u -p a/db-5.2.28.NC/src/hash/hash_open.c b/db-5.2.28.NC/src/hash/hash_open.c
--- a/db-5.2.28.NC/src/hash/hash_open.c
+++ b/db-5.2.28.NC/src/hash/hash_open.c
@@ -87,7 +87,7 @@ __ham_open(dbp, ip, txn, name, base_pgno
 	 * lock instead.
 	 */
 	if ((ret = __db_cursor(dbp, ip, txn, &dbc,
-	    (LF_ISSET(DB_CREATE) && CDB_LOCKING(env) ?  DB_WRITECURSOR : 0) |
+	    (((flags) & (DB_CREATE)) && CDB_LOCKING(env) ?  DB_WRITECURSOR : 0) |
 	    (F_ISSET(dbp, DB_AM_RECOVER) ? DB_RECOVER : 0))) != 0)
 		return (ret);
 
lock on line 92 in file ../bd-orig/db-5.2.28.NC/src/hash/hash_rec.c has no unlock
MLOCK ( cp -> dbp -> env , cp -> dbp -> mutex )
unlock on line 90 in file ../bd-orig/db-5.2.28.NC/src/hash/hash_rec.c has no lock
diff -u -p a/db-5.2.28.NC/src/hash/hash_rec.c b/db-5.2.28.NC/src/hash/hash_rec.c
--- a/db-5.2.28.NC/src/hash/hash_rec.c
+++ b/db-5.2.28.NC/src/hash/hash_rec.c
@@ -1287,8 +1287,10 @@ __ham_alloc_pages(dbc, argp, lsnp)
 
 	/* Had to create the page. */
 	if ((ret = __memp_fget(mpf, &pgno,
-	    ip, NULL, DB_MPOOL_CREATE, &pagep)) != 0)
-		return (__db_pgerr(dbc->dbp, pgno, ret));
+	    ip, NULL, DB_MPOOL_CREATE, &pagep)) != 0) {
+		
+			return (__db_pgerr(dbc->dbp, pgno, ret));
+		}
 
 reinit_page:
 	/* Initialize the newly allocated page. */
@@ -1520,11 +1522,13 @@ __ham_chgpg_recover_func(cp, my_dbc, cou
 		 * the cursor we're adjusting can't be closed
 		 * under us.
 		 */
-		MUTEX_UNLOCK(cp->dbp->env, cp->dbp->mutex);
+		liblock_unlock_in_cs(MLOCK(cp->dbp->env, cp->dbp->mutex));
 		ret = __dbc_close(lcp->opd);
-		MUTEX_LOCK(cp->dbp->env, cp->dbp->mutex);
-		if (ret != 0)
-			return (ret);
+		liblock_relock_in_cs(MLOCK(cp->dbp->env, cp->dbp->mutex));
+		if (ret != 0) {
+			
+				return (ret);
+			}
 		lcp->opd = NULL;
 		break;
 	}
@@ -1625,7 +1629,7 @@ __ham_metagroup_42_recover(env, dbtp, ls
 
 	flags = 0;
 	pagep = NULL;
-	LF_SET(DB_MPOOL_CREATE);
+	((flags) |= (DB_MPOOL_CREATE));
 	ret = __memp_fget(mpf, &pgno, ip,  NULL, flags, &pagep);
 
 	if (ret != 0) {
@@ -1872,15 +1876,19 @@ __ham_alloc_pages_42(dbc, argp, lsnp)
 		if (NUM_ENT(pagep) == 0 && IS_ZERO_LSN(pagep->lsn))
 			goto reinit_page;
 		if ((ret = __memp_fput(mpf,
-		    ip, pagep, dbc->priority)) != 0)
-			return (ret);
+		    ip, pagep, dbc->priority)) != 0) {
+			
+				return (ret);
+			}
 		return (0);
 	}
 
 	/* Had to create the page. */
 	if ((ret = __memp_fget(mpf, &pgno, ip, NULL,
-	    DB_MPOOL_CREATE | DB_MPOOL_DIRTY, &pagep)) != 0)
-		return (__db_pgerr(dbc->dbp, pgno, ret));
+	    DB_MPOOL_CREATE | DB_MPOOL_DIRTY, &pagep)) != 0) {
+		
+			return (__db_pgerr(dbc->dbp, pgno, ret));
+		}
 
 reinit_page:
 	/* Initialize the newly allocated page. */
@@ -1888,8 +1896,10 @@ reinit_page:
 	    dbc->dbp->pgsize, pgno, PGNO_INVALID, PGNO_INVALID, 0, P_HASH);
 	pagep->lsn = *lsnp;
 
-	if ((ret = __memp_fput(mpf, ip, pagep, dbc->priority)) != 0)
-		return (ret);
+	if ((ret = __memp_fput(mpf, ip, pagep, dbc->priority)) != 0) {
+		
+			return (ret);
+		}
 
 	return (0);
 }
diff -u -p a/db-5.2.28.NC/src/hash/hash_compact.c b/db-5.2.28.NC/src/hash/hash_compact.c
--- a/db-5.2.28.NC/src/hash/hash_compact.c
+++ b/db-5.2.28.NC/src/hash/hash_compact.c
@@ -175,7 +175,7 @@ err:		if (hcp->page != NULL &&
 		    atomic_read(&dbp->mpf->mfp->multiversion) == 0 &&
 		    (pgs_done == 0 || dbc->txn == NULL))
 			ret = __LPUT(dbc, hcp->lock);
-		else if (LF_ISSET(DB_AUTO_COMMIT)) {
+		else if (((flags) & (DB_AUTO_COMMIT))) {
 			if (ret == 0)
 				hcp->bucket++;
 			break;
@@ -187,7 +187,7 @@ err:		if (hcp->page != NULL &&
 	 * page. Wait till we are done with everything else as we
 	 * need to get an exclusive lock on the metadata page.
 	 */
-	if (ret == 0 && empty_buckets != 0 && LF_ISSET(DB_FREE_SPACE)) {
+	if (ret == 0 && empty_buckets != 0 && ((flags) & (DB_FREE_SPACE))) {
 		for (i = 0; i < empty_buckets && hcp->hdr->max_bucket > 2; i++)
 			if ((ret = __ham_contract_table(dbc, c_data)) != 0)
 				break;
diff -u -p a/db-5.2.28.NC/src/hash/hash_verify.c b/db-5.2.28.NC/src/hash/hash_verify.c
--- a/db-5.2.28.NC/src/hash/hash_verify.c
+++ b/db-5.2.28.NC/src/hash/hash_verify.c
@@ -74,7 +74,7 @@ __ham_vrfy_meta(dbp, vdp, m, pgno, flags
 	}
 
 	/* h_charkey */
-	if (!LF_ISSET(DB_NOORDERCHK))
+	if (!((flags) & (DB_NOORDERCHK)))
 		if (m->h_charkey != hfunc(dbp, CHARKEY, sizeof(CHARKEY))) {
 			EPRINT((env, DB_STR_A("1096",
 "Page %lu: database has custom hash function; reverify with DB_NOORDERCHK set",
@@ -166,7 +166,7 @@ __ham_vrfy_meta(dbp, vdp, m, pgno, flags
 
 err:	if ((t_ret = __db_vrfy_putpageinfo(env, vdp, pip)) != 0 && ret == 0)
 		ret = t_ret;
-	if (LF_ISSET(DB_SALVAGE) &&
+	if (((flags) & (DB_SALVAGE)) &&
 	   (t_ret = __db_salvage_markdone(vdp, pgno)) != 0 && ret == 0)
 		ret = t_ret;
 	return ((ret == 0 && isbad == 1) ? DB_VERIFY_BAD : ret);
@@ -249,7 +249,7 @@ __ham_vrfy(dbp, vdp, h, pgno, flags)
 	if ((ret = __db_cursor_int(dbp, vdp->thread_info, NULL, DB_HASH,
 	    PGNO_INVALID, 0, DB_LOCK_INVALIDID, &dbc)) != 0)
 		return (ret);
-	if (!LF_ISSET(DB_NOORDERCHK) && TYPE(h) == P_HASH &&
+	if (!((flags) & (DB_NOORDERCHK)) && TYPE(h) == P_HASH &&
 	    (ret = __ham_verify_sorted_page(dbc, h)) != 0)
 		isbad = 1;
 
@@ -334,7 +334,7 @@ __ham_vrfy_item(dbp, vdp, pgno, h, i, fl
 			}
 		}
 		F_SET(pip, VRFY_HAS_DUPS);
-		if (!LF_ISSET(DB_NOORDERCHK) &&
+		if (!((flags) & (DB_NOORDERCHK)) &&
 		    __ham_dups_unsorted(dbp, databuf, len))
 			F_SET(pip, VRFY_DUPS_UNSORTED);
 		break;
@@ -585,7 +585,7 @@ __ham_vrfy_bucket(dbp, vdp, m, bucket, f
 	/* Loop until we find a fatal bug, or until we run out of pages. */
 	for (;;) {
 		/* Provide feedback on our progress to the application. */
-		if (!LF_ISSET(DB_SALVAGE))
+		if (!((flags) & (DB_SALVAGE)))
 			__db_vrfy_struct_feedback(dbp, vdp);
 
 		if ((ret = __db_vrfy_pgset_get(vdp->pgset,
@@ -672,7 +672,7 @@ __ham_vrfy_bucket(dbp, vdp, m, bucket, f
 		    DB_HASH, PGNO_INVALID, 0, DB_LOCK_INVALIDID, &cc)) != 0)
 			goto err;
 		/* If it's safe to check that things hash properly, do so. */
-		if (isbad == 0 && !LF_ISSET(DB_NOORDERCHK) &&
+		if (isbad == 0 && !((flags) & (DB_NOORDERCHK)) &&
 		    (ret = __ham_vrfy_hashing(cc, pip->entries,
 		    m, bucket, pgno, flags, hfunc)) != 0) {
 			if (ret == DB_VERIFY_BAD)
@@ -838,7 +838,7 @@ __ham_salvage(dbp, vdp, pgno, h, handle,
 	himark = dbp->pgsize;
 	for (i = 0;; i++) {
 		/* If we're not aggressive, break when we hit NUM_ENT(h). */
-		if (!LF_ISSET(DB_AGGRESSIVE) && i >= NUM_ENT(h))
+		if (!((flags) & (DB_AGGRESSIVE)) && i >= NUM_ENT(h))
 			break;
 
 		/*
@@ -929,7 +929,7 @@ keydata:			memcpy(buf, HKEYDATA_DATA(hk)
 				 */
 				if (i % 2 == 0) {
 					err_ret = ret;
-					if (LF_ISSET(DB_AGGRESSIVE))
+					if (((flags) & (DB_AGGRESSIVE)))
 						goto keydata;
 					break;
 				}
@@ -996,7 +996,7 @@ keydata:			memcpy(buf, HKEYDATA_DATA(hk)
 				__os_free(dbp->env, key_buf);
 				break;
 			default:
-				if (!LF_ISSET(DB_AGGRESSIVE))
+				if (!((flags) & (DB_AGGRESSIVE)))
 					break;
 				err_ret = DB_VERIFY_BAD;
 				break;
diff -u -p a/db-5.2.28.NC/src/hash/hash_page.c b/db-5.2.28.NC/src/hash/hash_page.c
--- a/db-5.2.28.NC/src/hash/hash_page.c
+++ b/db-5.2.28.NC/src/hash/hash_page.c
@@ -1075,7 +1075,7 @@ __ham_del_pair(dbc, flags, ppg)
 	 * to remove the big item and then update the page to remove the
 	 * entry referring to the big item.
 	 */
-	if (!LF_ISSET(HAM_DEL_IGNORE_OFFPAGE) &&
+	if (!((flags) & (HAM_DEL_IGNORE_OFFPAGE)) &&
 	    HPAGE_PTYPE(H_PAIRKEY(dbp, p, ndx)) == H_OFFPAGE) {
 		memcpy(&pgno, HOFFPAGE_PGNO(P_ENTRY(dbp, p, H_KEYINDEX(ndx))),
 		    sizeof(db_pgno_t));
@@ -1083,7 +1083,7 @@ __ham_del_pair(dbc, flags, ppg)
 	} else
 		ret = 0;
 
-	if (!LF_ISSET(HAM_DEL_IGNORE_OFFPAGE) && ret == 0)
+	if (!((flags) & (HAM_DEL_IGNORE_OFFPAGE)) && ret == 0)
 		switch (HPAGE_PTYPE(H_PAIRDATA(dbp, p, ndx))) {
 		case H_OFFPAGE:
 			memcpy(&pgno,
@@ -1170,7 +1170,7 @@ __ham_del_pair(dbc, flags, ppg)
 	}
 
 	/* The HAM_DEL_NO_CURSOR flag implies HAM_DEL_NO_RECLAIM. */
-	if (LF_ISSET(HAM_DEL_NO_CURSOR))
+	if (((flags) & (HAM_DEL_NO_CURSOR)))
 		return (0);
 	/*
 	 * Update cursors that are on the page where the delete happened.
@@ -1186,7 +1186,7 @@ __ham_del_pair(dbc, flags, ppg)
 	 * the second page into it and remove the second page.
 	 * If its the only page in the bucket we leave it alone.
 	 */
-	if (LF_ISSET(HAM_DEL_NO_RECLAIM) ||
+	if (((flags) & (HAM_DEL_NO_RECLAIM)) ||
 	    NUM_ENT(p) != 0 ||
 	    (PREV_PGNO(p) == PGNO_INVALID && NEXT_PGNO(p) == PGNO_INVALID)) {
 		if (NUM_ENT(p) == 0)
diff -u -p a/db-5.2.28.NC/src/fileops/fop_util.c b/db-5.2.28.NC/src/fileops/fop_util.c
--- a/db-5.2.28.NC/src/fileops/fop_util.c
+++ b/db-5.2.28.NC/src/fileops/fop_util.c
@@ -227,8 +227,8 @@ __fop_file_setup(dbp, ip, txn, name, mod
 	created_locker = tmp_created = truncating = was_inval = 0;
 	real_name = real_tmpname = tmpname = NULL;
 	dflags = F_ISSET(dbp, DB_AM_NOT_DURABLE) ? DB_LOG_NOT_DURABLE : 0;
-	aflags = LF_ISSET(DB_INTERNAL_DB) ? DB_APP_NONE : DB_APP_DATA;
-	LF_CLR(DB_INTERNAL_DB);
+	aflags = ((flags) & (DB_INTERNAL_DB)) ? DB_APP_NONE : DB_APP_DATA;
+	((flags) &= ~(DB_INTERNAL_DB));
 
 	ret = 0;
 	retries = 0;
@@ -271,15 +271,15 @@ __fop_file_setup(dbp, ip, txn, name, mod
 		if (mode == 0)
 			mode = DB_MODE_660;
 
-		if (LF_ISSET(DB_RDONLY))
+		if (((flags) & (DB_RDONLY)))
 			oflags |= DB_OSO_RDONLY;
-		if (LF_ISSET(DB_TRUNCATE))
+		if (((flags) & (DB_TRUNCATE)))
 			oflags |= DB_OSO_TRUNC;
 	}
 
 	retries = 0;
-	create_ok = LF_ISSET(DB_CREATE);
-	LF_CLR(DB_CREATE);
+	create_ok = ((flags) & (DB_CREATE));
+	((flags) &= ~(DB_CREATE));
 
 retry:
 	/*
@@ -342,8 +342,8 @@ reopen:		if (!F_ISSET(dbp, DB_AM_INMEM)
 			goto err;
 
 		/* Case 2: DB_TRUNCATE: we must do the creation in place. */
-		if (LF_ISSET(DB_TRUNCATE)) {
-			if (LF_ISSET(DB_EXCL)) {
+		if (((flags) & (DB_TRUNCATE))) {
+			if (((flags) & (DB_EXCL))) {
 				/* Case 1a: DB_EXCL and DB_TRUNCATE. */
 				ret = EEXIST;
 				goto err;
@@ -361,13 +361,13 @@ reopen:		if (!F_ISSET(dbp, DB_AM_INMEM)
 		} else {
 			ret = __fop_read_meta(env, real_name, mbuf,
 			    sizeof(mbuf), fhp,
-			    LF_ISSET(DB_NOERROR) ||
-			    (LF_ISSET(DB_FCNTL_LOCKING) && txn == NULL) ? 1 : 0,
+			    ((flags) & (DB_NOERROR)) ||
+			    (((flags) & (DB_FCNTL_LOCKING)) && txn == NULL) ? 1 : 0,
 			    &len);
 
 			/* Case 3: 0-length, no txns. */
 			if (ret != 0 && len == 0 && txn == NULL) {
-				if (LF_ISSET(DB_EXCL)) {
+				if (((flags) & (DB_EXCL))) {
 					/*
 					 * Case 1b: DB_EXCL and
 					 * 0-length file exists.
@@ -417,7 +417,7 @@ reopen:		if (!F_ISSET(dbp, DB_AM_INMEM)
 			 * We assert it here to make sure we aren't destroying
 			 * any application level FCNTL semantics.
 			 */
-			DB_ASSERT(env, !LF_ISSET(DB_FCNTL_LOCKING));
+			DB_ASSERT(env, !((flags) & (DB_FCNTL_LOCKING)));
 			if (!F_ISSET(dbp, DB_AM_INMEM)) {
 				if ((ret = __os_closehandle(env, fhp)) != 0)
 					goto err;
@@ -467,7 +467,7 @@ reopen:		if (!F_ISSET(dbp, DB_AM_INMEM)
 				} else if ((ret =
 				    __os_closehandle(env, fhp)) != 0)
 					goto err;
-				LF_SET(DB_CREATE);
+				((flags) |= (DB_CREATE));
 				goto create;
 			} else {
 				ret = ENOENT;
@@ -488,7 +488,7 @@ reopen:		if (!F_ISSET(dbp, DB_AM_INMEM)
 		 * continue to hold the handle lock, since technically, we
 		 * should not have been allowed to open it.
 		 */
-		if (LF_ISSET(DB_EXCL)) {
+		if (((flags) & (DB_EXCL))) {
 			ret = __ENV_LPUT(env, dbp->handle_lock);
 			LOCK_INIT(dbp->handle_lock);
 			if (ret == 0)
@@ -509,12 +509,12 @@ reopen:		if (!F_ISSET(dbp, DB_AM_INMEM)
 	if (!create_ok || ret != ENOENT)
 #endif
 		goto err;
-	LF_SET(DB_CREATE);
+	((flags) |= (DB_CREATE));
 	/*
 	 * If we were trying to open a non-existent master database
 	 * readonly clear that here.
 	 */
-	LF_CLR(DB_RDONLY);
+	((flags) &= ~(DB_RDONLY));
 	F_CLR(dbp, DB_AM_RDONLY);
 	ret = 0;
 
@@ -971,7 +971,7 @@ retry:	if (LOCKING_ON(env)) {
 	 * that we shouldn't close the handle.
 	 */
 	fhp = dbp->saved_open_fhp;
-	DB_ASSERT(env, LF_ISSET(DB_FCNTL_LOCKING) || fhp == NULL);
+	DB_ASSERT(env, ((flags) & (DB_FCNTL_LOCKING)) || fhp == NULL);
 
 	/*
 	 * Lock environment to protect file open.  That will enable us to
@@ -1011,7 +1011,7 @@ retry:	if (LOCKING_ON(env)) {
 		 * Close the file, block on the lock, clean up the dbp, and
 		 * then start all over again.
 		 */
-		if (!F_ISSET(dbp, DB_AM_INMEM) && !LF_ISSET(DB_FCNTL_LOCKING)) {
+		if (!F_ISSET(dbp, DB_AM_INMEM) && !((flags) & (DB_FCNTL_LOCKING))) {
 			(void)__os_closehandle(env, fhp);
 			fhp = NULL;
 		}
@@ -1039,7 +1039,7 @@ retry:	if (LOCKING_ON(env)) {
 	if (0) {
 err:		(void)__ENV_LPUT(env, elock);
 	}
-	if (fhp != NULL && !LF_ISSET(DB_FCNTL_LOCKING))
+	if (fhp != NULL && !((flags) & (DB_FCNTL_LOCKING)))
 		(void)__os_closehandle(env, fhp);
 	/*
 	 * If this is a real file and we are going to proceed with the removal,
diff -u -p a/db-5.2.28.NC/src/rep/rep_method.c b/db-5.2.28.NC/src/rep/rep_method.c
--- a/db-5.2.28.NC/src/rep/rep_method.c
+++ b/db-5.2.28.NC/src/rep/rep_method.c
@@ -383,7 +383,7 @@ __rep_start_pp(dbenv, dbt, flags)
 		return (EINVAL);
 	}
 
-	switch (LF_ISSET(DB_REP_CLIENT | DB_REP_MASTER)) {
+	switch (((flags) & (DB_REP_CLIENT | DB_REP_MASTER))) {
 	case DB_REP_CLIENT:
 	case DB_REP_MASTER:
 		break;
@@ -461,7 +461,7 @@ __rep_start_int(env, dbt, flags)
 	renv = infop->primary;
 	interrupting = locked = 0;
 	pending_event = DB_EVENT_NO_SUCH_EVENT;
-	role = LF_ISSET(DB_REP_CLIENT | DB_REP_MASTER);
+	role = ((flags) & (DB_REP_CLIENT | DB_REP_MASTER));
 	start_th = 0;
 
 	/*
@@ -1110,7 +1110,7 @@ __rep_open_sysdb(env, ip, txn, dbname, f
 	dbp = NULL;
 	if (ret != 0)
 		goto err;
-	if (LF_ISSET(DB_CREATE)) {
+	if (((flags) & (DB_CREATE))) {
 		if ((ret = __db_create_internal(&dbp, env, 0)) != 0)
 			goto err;
 		if ((ret = __db_set_pagesize(dbp, REPSYSDBPGSZ)) != 0)
diff -u -p a/db-5.2.28.NC/src/rep/rep_elect.c b/db-5.2.28.NC/src/rep/rep_elect.c
--- a/db-5.2.28.NC/src/rep/rep_elect.c
+++ b/db-5.2.28.NC/src/rep/rep_elect.c
@@ -1109,7 +1109,7 @@ __rep_cmp_vote(env, rep, eid, lsnp, prio
 	 * If we're the first, make ourselves the winner to start.
 	 */
 	if (rep->sites > 1 &&
-	    (priority != 0 || LF_ISSET(REPCTL_ELECTABLE))) {
+	    (priority != 0 || ((flags) & (REPCTL_ELECTABLE)))) {
 		/*
 		 * Special case, if we have a mixed version group of sites,
 		 * we set priority to 0, but set the ELECTABLE flag so that
@@ -1151,7 +1151,7 @@ __rep_cmp_vote(env, rep, eid, lsnp, prio
 			rep->w_tiebreaker = tiebreaker;
 		}
 	} else if (rep->sites == 1) {
-		if (priority != 0 || LF_ISSET(REPCTL_ELECTABLE)) {
+		if (priority != 0 || ((flags) & (REPCTL_ELECTABLE))) {
 			/* Make ourselves the winner to start. */
 			rep->winner = eid;
 			rep->w_priority = priority;
@@ -1323,7 +1323,7 @@ __rep_wait(env, timeoutp, full_elect, eg
 		 * applicable for the phase 0 wait, which uses a completely
 		 * unrelated timeout value.)
 		 */
-		if (!LF_ISSET(REP_E_PHASE0) &&
+		if (!((flags) & (REP_E_PHASE0)) &&
 		    full_elect && F_ISSET(rep, REP_F_GROUP_ESTD)) {
 			*timeoutp = rep->elect_timeout;
 			timeout = *timeoutp;
diff -u -p a/db-5.2.28.NC/src/rep/rep_util.c b/db-5.2.28.NC/src/rep/rep_util.c
--- a/db-5.2.28.NC/src/rep/rep_util.c
+++ b/db-5.2.28.NC/src/rep/rep_util.c
@@ -189,7 +189,7 @@ __rep_bulk_message(env, bulk, repth, lsn
 	/*
 	 * Send the buffer if it is a perm record or a force.
 	 */
-	if (LF_ISSET(REPCTL_PERM)) {
+	if (((flags) & (REPCTL_PERM))) {
 		VPRINT(env, (env, DB_VERB_REP_MSGS,
 		    "bulk_msg: Send buffer after copy due to PERM"));
 		ret = __rep_send_bulk(env, bulk, flags);
@@ -1609,7 +1609,7 @@ __rep_send_throttle(env, eid, repth, fla
 	 * If we only want to do throttle processing and we don't have it
 	 * turned on, return immediately.
 	 */
-	if (!check_limit && LF_ISSET(REP_THROTTLE_ONLY))
+	if (!check_limit && ((flags) & (REP_THROTTLE_ONLY)))
 		return (0);
 
 	db_rep = env->rep_handle;
@@ -1653,7 +1653,7 @@ __rep_send_throttle(env, eid, repth, fla
 	 * NOTE:  It is the responsibility of the caller to marshal, if
 	 * needed, the data_dbt.  This function just sends what it is given.
 	 */
-snd:	if ((repth->type == typemore || !LF_ISSET(REP_THROTTLE_ONLY)) &&
+snd:	if ((repth->type == typemore || !((flags) & (REP_THROTTLE_ONLY))) &&
 	    (__rep_send_message(env, eid, repth->type,
 	    &repth->lsn, repth->data_dbt, (REPCTL_RESEND | ctlflags), 0) != 0))
 		return (DB_REP_UNAVAIL);
@@ -2291,7 +2291,7 @@ __rep_print_message(env, eid, rp, str, f
 	 * length cannot overflow the buffer.
 	 */
 	ftype[0] = '\0';
-	if (LF_ISSET(DB_REP_ANYWHERE))
+	if (((flags) & (DB_REP_ANYWHERE)))
 		(void)strcat(ftype, " any");		/* 4 */
 	if (FLD_ISSET(ctlflags, REPCTL_FLUSH))
 		(void)strcat(ftype, " flush");		/* 10 */
@@ -2304,11 +2304,11 @@ __rep_print_message(env, eid, rp, str, f
 		(void)strcat(ftype, " nogroup");	/* 18 */
 	if (FLD_ISSET(ctlflags, REPCTL_LEASE))
 		(void)strcat(ftype, " lease");		/* 24 */
-	if (LF_ISSET(DB_REP_NOBUFFER))
+	if (((flags) & (DB_REP_NOBUFFER)))
 		(void)strcat(ftype, " nobuf");		/* 30 */
 	if (FLD_ISSET(ctlflags, REPCTL_PERM))
 		(void)strcat(ftype, " perm");		/* 35 */
-	if (LF_ISSET(DB_REP_REREQUEST))
+	if (((flags) & (DB_REP_REREQUEST)))
 		(void)strcat(ftype, " rereq");		/* 41 */
 	if (FLD_ISSET(ctlflags, REPCTL_RESEND))
 		(void)strcat(ftype, " resend");		/* 48 */
diff -u -p a/db-5.2.28.NC/src/rep/rep_stat.c b/db-5.2.28.NC/src/rep/rep_stat.c
--- a/db-5.2.28.NC/src/rep/rep_stat.c
+++ b/db-5.2.28.NC/src/rep/rep_stat.c
@@ -174,7 +174,7 @@ __rep_stat(env, statp, flags)
 	else
 		stats->st_status = 0;
 
-	if (LF_ISSET(DB_STAT_CLEAR)) {
+	if (((flags) & (DB_STAT_CLEAR))) {
 		queued = rep->stat.st_log_queued;
 		startupdone = rep->stat.st_startup_complete;
 		memset(&rep->stat, 0, sizeof(rep->stat));
@@ -262,17 +262,17 @@ __rep_stat_print(env, flags)
 	int ret;
 
 	orig_flags = flags;
-	LF_CLR(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM);
-	if (LF_ISSET(DB_STAT_SUMMARY))
+	((flags) &= ~(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM));
+	if (((flags) & (DB_STAT_SUMMARY)))
 		return (__rep_stat_summary_print(env));
 
-	if (flags == 0 || LF_ISSET(DB_STAT_ALL)) {
+	if (flags == 0 || ((flags) & (DB_STAT_ALL))) {
 		ret = __rep_print_stats(env, orig_flags);
 		if (flags == 0 || ret != 0)
 			return (ret);
 	}
 
-	if (LF_ISSET(DB_STAT_ALL) &&
+	if (((flags) & (DB_STAT_ALL)) &&
 	    (ret = __rep_print_all(env, orig_flags)) != 0)
 		return (ret);
 
@@ -295,7 +295,7 @@ __rep_print_stats(env, flags)
 	if ((ret = __rep_stat(env, &sp, flags)) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL))
+	if (((flags) & (DB_STAT_ALL)))
 		__db_msg(env, "Default replication region information:");
 	PRINT_STATUS(sp, is_client);
 
diff -u -p a/db-5.2.28.NC/src/mp/mp_fopen.c b/db-5.2.28.NC/src/mp/mp_fopen.c
--- a/db-5.2.28.NC/src/mp/mp_fopen.c
+++ b/db-5.2.28.NC/src/mp/mp_fopen.c
@@ -62,13 +62,13 @@ __memp_fopen_pp(dbmfp, path, flags, mode
 	}
 
 	/* Read-only checks, and local flag. */
-	if (LF_ISSET(DB_RDONLY) && path == NULL) {
+	if (((flags) & (DB_RDONLY)) && path == NULL) {
 		__db_errx(env, DB_STR("3035",
 		    "DB_MPOOLFILE->open: temporary files can't be readonly"));
 		return (EINVAL);
 	}
 
-	if (LF_ISSET(DB_MULTIVERSION) && !TXN_ON(env)) {
+	if (((flags) & (DB_MULTIVERSION)) && !TXN_ON(env)) {
 		__db_errx(env, DB_STR("3036",
 	    "DB_MPOOLFILE->open: DB_MULTIVERSION requires transactions"));
 		return (EINVAL);
@@ -224,6 +224,7 @@ __memp_fopen(dbmfp, mfp, path, dirp, fla
 				dbmfp->addr = tmp_dbmfp->addr;
 				break;
 			}
+			tmp_dbmfp = tmp_dbmfp;
 		MUTEX_UNLOCK(env, dbmp->mutex);
 		if (dbmfp->fhp != NULL)
 			goto have_mfp;
@@ -236,11 +237,11 @@ __memp_fopen(dbmfp, mfp, path, dirp, fla
 	if (!FLD_ISSET(dbmfp->config_flags, DB_MPOOL_NOFILE)) {
 		/* Convert MP open flags to DB OS-layer open flags. */
 		oflags = 0;
-		if (LF_ISSET(DB_CREATE))
+		if (((flags) & (DB_CREATE)))
 			oflags |= DB_OSO_CREATE;
-		if (LF_ISSET(DB_DIRECT))
+		if (((flags) & (DB_DIRECT)))
 			oflags |= DB_OSO_DIRECT;
-		if (LF_ISSET(DB_RDONLY)) {
+		if (((flags) & (DB_RDONLY))) {
 			F_SET(dbmfp, MP_READONLY);
 			oflags |= DB_OSO_RDONLY;
 		}
@@ -308,7 +309,7 @@ __memp_fopen(dbmfp, mfp, path, dirp, fla
 		 */
 		DB_ASSERT(env, pagesize != 0);
 		if (bytes % pagesize != 0) {
-			if (LF_ISSET(DB_ODDFILESIZE))
+			if (((flags) & (DB_ODDFILESIZE)))
 				bytes -= (u_int32_t)(bytes % pagesize);
 			else {
 				__db_errx(env, DB_STR_A("3037",
@@ -397,7 +398,7 @@ check:	MUTEX_LOCK(env, hp->mtx_hash);
 		 * then the create flag should be set.
 		 */
 		if (FLD_ISSET(dbmfp->config_flags, DB_MPOOL_NOFILE) &&
-		    !LF_ISSET(DB_CREATE)) {
+		    !((flags) & (DB_CREATE))) {
 			ret = ENOENT;
 			goto err;
 		}
@@ -451,12 +452,12 @@ have_mfp:
 	 * durable.  This needs to be cross process and cross sub-databases, so
 	 * mpool is the place to do it.
 	 */
-	if (!LF_ISSET(DB_DURABLE_UNKNOWN | DB_RDONLY)) {
+	if (!((flags) & (DB_DURABLE_UNKNOWN | DB_RDONLY))) {
 		if (F_ISSET(mfp, MP_DURABLE_UNKNOWN)) {
-			if (LF_ISSET(DB_TXN_NOT_DURABLE))
+			if (((flags) & (DB_TXN_NOT_DURABLE)))
 				F_SET(mfp, MP_NOT_DURABLE);
 			F_CLR(mfp, MP_DURABLE_UNKNOWN);
-		} else if (!LF_ISSET(DB_TXN_NOT_DURABLE) !=
+		} else if (!((flags) & (DB_TXN_NOT_DURABLE)) !=
 		    !F_ISSET(mfp, MP_NOT_DURABLE)) {
 			__db_errx(env, DB_STR("3039",
 	     "Cannot open DURABLE and NOT DURABLE handles in the same file"));
@@ -465,7 +466,7 @@ have_mfp:
 		}
 	}
 
-	if (LF_ISSET(DB_MULTIVERSION)) {
+	if (((flags) & (DB_MULTIVERSION))) {
 		atomic_inc(env, &mfp->multiversion);
 		F_SET(dbmfp, MP_MULTIVERSION);
 	}
@@ -508,7 +509,7 @@ have_mfp:
 			F_CLR(mfp, MP_CAN_MMAP);
 		else if (dbmfp->ftype != 0)
 			F_CLR(mfp, MP_CAN_MMAP);
-		else if (LF_ISSET(DB_NOMMAP) || F_ISSET(dbenv, DB_ENV_NOMMAP))
+		else if (((flags) & (DB_NOMMAP)) || F_ISSET(dbenv, DB_ENV_NOMMAP))
 			F_CLR(mfp, MP_CAN_MMAP);
 		else {
 			MPOOL_SYSTEM_LOCK(env);
@@ -615,7 +616,7 @@ __memp_mpf_find(env, dbmfp, hp, path, fl
 		 * We should be able to set mfp to NULL and break out of the
 		 * loop, but I like the idea of checking all the entries.
 		 */
-		if (LF_ISSET(DB_TRUNCATE)) {
+		if (((flags) & (DB_TRUNCATE))) {
 			MUTEX_LOCK(env, mfp->mutex);
 			mfp->deadfile = 1;
 			MUTEX_UNLOCK(env, mfp->mutex);
@@ -699,13 +700,13 @@ __memp_mpf_alloc(dbmp, dbmfp, path, page
 	F_SET(mfp, MP_CAN_MMAP);
 	if (F_ISSET(env->dbenv, DB_ENV_DATABASE_LOCKING))
 		F_SET(mfp, MP_DATABASE_LOCKING);
-	if (LF_ISSET(DB_DIRECT))
+	if (((flags) & (DB_DIRECT)))
 		F_SET(mfp, MP_DIRECT);
-	if (LF_ISSET(DB_DURABLE_UNKNOWN | DB_RDONLY))
+	if (((flags) & (DB_DURABLE_UNKNOWN | DB_RDONLY)))
 		F_SET(mfp, MP_DURABLE_UNKNOWN);
-	if (LF_ISSET(DB_EXTENT))
+	if (((flags) & (DB_EXTENT)))
 		F_SET(mfp, MP_EXTENT);
-	if (LF_ISSET(DB_TXN_NOT_DURABLE))
+	if (((flags) & (DB_TXN_NOT_DURABLE)))
 		F_SET(mfp, MP_NOT_DURABLE);
 
 	/*
@@ -886,12 +887,12 @@ __memp_fclose(dbmfp, flags)
 	 * when we try to flush them.
 	 */
 	deleted = 0;
-	if (!LF_ISSET(DB_MPOOL_NOLOCK))
+	if (!((flags) & (DB_MPOOL_NOLOCK)))
 		MUTEX_LOCK(env, mfp->mutex);
 	if (F_ISSET(dbmfp, MP_MULTIVERSION))
 		atomic_dec(env, &mfp->multiversion);
-	if (--mfp->mpf_cnt == 0 || LF_ISSET(DB_MPOOL_DISCARD)) {
-		if (LF_ISSET(DB_MPOOL_DISCARD) ||
+	if (--mfp->mpf_cnt == 0 || ((flags) & (DB_MPOOL_DISCARD))) {
+		if (((flags) & (DB_MPOOL_DISCARD)) ||
 		    F_ISSET(mfp, MP_TEMP) || mfp->unlink_on_close) {
 			mfp->deadfile = 1;
 		}
@@ -917,14 +918,14 @@ __memp_fclose(dbmfp, flags)
 			 * is holding the lock on it.  See comment in
 			 * __memp_sync_file.
 			 */
-			DB_ASSERT(env, !LF_ISSET(DB_MPOOL_NOLOCK));
+			DB_ASSERT(env, !((flags) & (DB_MPOOL_NOLOCK)));
 			if ((t_ret =
 			    __memp_mf_discard(dbmp, mfp, 0)) != 0 && ret == 0)
 				ret = t_ret;
 			deleted = 1;
 		}
 	}
-	if (!deleted && !LF_ISSET(DB_MPOOL_NOLOCK))
+	if (!deleted && !((flags) & (DB_MPOOL_NOLOCK)))
 		MUTEX_UNLOCK(env, mfp->mutex);
 
 done:	/* Discard the DB_MPOOLFILE structure. */
diff -u -p a/db-5.2.28.NC/src/mp/mp_stat.c b/db-5.2.28.NC/src/mp/mp_stat.c
--- a/db-5.2.28.NC/src/mp/mp_stat.c
+++ b/db-5.2.28.NC/src/mp/mp_stat.c
@@ -168,8 +168,8 @@ __memp_stat(env, gspp, fspp, flags)
 				sp->st_alloc_max_pages =
 				    c_mp->stat.st_alloc_max_pages;
 
-			if (LF_ISSET(DB_STAT_CLEAR)) {
-				if (!LF_ISSET(DB_STAT_SUBSYSTEM))
+			if (((flags) & (DB_STAT_CLEAR))) {
+				if (!((flags) & (DB_STAT_SUBSYSTEM)))
 					__mutex_clear(env, c_mp->mtx_region);
 
 				memset(&c_mp->stat, 0, sizeof(c_mp->stat));
@@ -185,7 +185,7 @@ __memp_stat(env, gspp, fspp, flags)
 		 * add the per-file information.
 		 */
 		if ((ret = __memp_walk_files(env, mp, __memp_file_stats,
-		    sp, NULL, fspp == NULL ? LF_ISSET(DB_STAT_CLEAR) : 0)) != 0)
+		    sp, NULL, fspp == NULL ? ((flags) & (DB_STAT_CLEAR)) : 0)) != 0)
 			return (ret);
 	}
 
@@ -246,7 +246,7 @@ __memp_file_stats(env, mfp, argp, countp
 	sp->st_page_create += mfp->stat.st_page_create;
 	sp->st_page_in += mfp->stat.st_page_in;
 	sp->st_page_out += mfp->stat.st_page_out;
-	if (LF_ISSET(DB_STAT_CLEAR))
+	if (((flags) & (DB_STAT_CLEAR)))
 		memset(&mfp->stat, 0, sizeof(mfp->stat));
 
 	return (0);
@@ -327,7 +327,7 @@ __memp_get_files(env, mfp, argp, countp,
 	*(DB_MPOOL_FSTAT ***)argp = tfsp;
 	(*countp)--;
 
-	if (LF_ISSET(DB_STAT_CLEAR))
+	if (((flags) & (DB_STAT_CLEAR)))
 		memset(&mfp->stat, 0, sizeof(mfp->stat));
 
 	return (0);
@@ -382,15 +382,15 @@ __memp_stat_print(env, flags)
 	int ret;
 
 	orig_flags = flags;
-	LF_CLR(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM);
-	if (flags == 0 || LF_ISSET(DB_STAT_ALL)) {
+	((flags) &= ~(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM));
+	if (flags == 0 || ((flags) & (DB_STAT_ALL))) {
 		ret = __memp_print_stats(env,
-		    LF_ISSET(DB_STAT_ALL) ? flags : orig_flags);
+		    ((flags) & (DB_STAT_ALL)) ? flags : orig_flags);
 		if (flags == 0 || ret != 0)
 			return (ret);
 	}
 
-	if (LF_ISSET(DB_STAT_ALL | DB_STAT_MEMP_HASH) &&
+	if (((flags) & (DB_STAT_ALL | DB_STAT_MEMP_HASH)) &&
 	    (ret = __memp_print_all(env, orig_flags)) != 0)
 		return (ret);
 
@@ -413,7 +413,7 @@ __memp_print_stats(env, flags)
 	if ((ret = __memp_stat(env, &gsp, &fsp, flags)) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL))
+	if (((flags) & (DB_STAT_ALL)))
 		__db_msg(env, "Default cache region information:");
 	__db_dlbytes(env, "Total cache size",
 	    (u_long)gsp->st_gbytes, (u_long)0, (u_long)gsp->st_bytes);
@@ -502,7 +502,7 @@ __memp_print_stats(env, flags)
 	    (u_long)gsp->st_sync_interrupted);
 
 	for (tfsp = fsp; fsp != NULL && *tfsp != NULL; ++tfsp) {
-		if (LF_ISSET(DB_STAT_ALL))
+		if (((flags) & (DB_STAT_ALL)))
 			__db_msg(env, "%s", DB_GLOBAL(db_line));
 		__db_msg(env, "Pool File: %s", (*tfsp)->file_name);
 		__db_dl(env, "Page size", (u_long)(*tfsp)->st_pagesize);
@@ -834,15 +834,14 @@ __memp_stat_wait(env, reginfo, mp, mstat
 			mstat->st_hash_max_wait = tmp_wait;
 			mstat->st_hash_max_nowait = tmp_nowait;
 		}
-		if (LF_ISSET(DB_STAT_CLEAR |
-		    DB_STAT_SUBSYSTEM) == DB_STAT_CLEAR)
+		if (((flags) & (DB_STAT_CLEAR | DB_STAT_SUBSYSTEM)) == DB_STAT_CLEAR)
 			__mutex_clear(env, hp->mtx_hash);
 
 		mstat->st_io_wait += hp->hash_io_wait;
 		mstat->st_mvcc_frozen += hp->hash_frozen;
 		mstat->st_mvcc_thawed += hp->hash_thawed;
 		mstat->st_mvcc_freed += hp->hash_frozen_freed;
-		if (LF_ISSET(DB_STAT_CLEAR)) {
+		if (((flags) & (DB_STAT_CLEAR))) {
 			hp->hash_io_wait = 0;
 			hp->hash_frozen = 0;
 			hp->hash_thawed = 0;
diff -u -p a/db-5.2.28.NC/src/mp/mp_fget.c b/db-5.2.28.NC/src/mp/mp_fget.c
--- a/db-5.2.28.NC/src/mp/mp_fget.c
+++ b/db-5.2.28.NC/src/mp/mp_fget.c
@@ -149,7 +149,7 @@ __memp_fget(dbmfp, pgnoaddr, ip, txn, fl
 	hp = NULL;
 	b_incr = b_lock = h_locked = extending = makecopy = ret = 0;
 
-	if (LF_ISSET(DB_MPOOL_DIRTY)) {
+	if (((flags) & (DB_MPOOL_DIRTY))) {
 		if (F_ISSET(dbmfp, MP_READONLY)) {
 			__db_errx(env, DB_STR_A("3021",
 			    "%s: dirty flag set for readonly file page",
@@ -161,8 +161,8 @@ __memp_fget(dbmfp, pgnoaddr, ip, txn, fl
 			return (ret);
 	}
 
-	dirty = LF_ISSET(DB_MPOOL_DIRTY | DB_MPOOL_EDIT | DB_MPOOL_FREE);
-	LF_CLR(DB_MPOOL_DIRTY | DB_MPOOL_EDIT);
+	dirty = ((flags) & (DB_MPOOL_DIRTY | DB_MPOOL_EDIT | DB_MPOOL_FREE));
+	((flags) &= ~(DB_MPOOL_DIRTY | DB_MPOOL_EDIT));
 
 	/*
 	 * If the transaction is being used to update a multiversion database
@@ -182,7 +182,7 @@ __memp_fget(dbmfp, pgnoaddr, ip, txn, fl
 			    NULL, NULL)) != 0)
 				return (ret);
 		}
-		if ((dirty || LF_ISSET(DB_MPOOL_CREATE | DB_MPOOL_NEW)) &&
+		if ((dirty || ((flags) & (DB_MPOOL_CREATE | DB_MPOOL_NEW))) &&
 		    td->mvcc_mtx == MUTEX_INVALID && (ret =
 		    __mutex_alloc(env, MTX_TXN_MVCC, 0, &td->mvcc_mtx)) != 0)
 			return (ret);
@@ -303,14 +303,14 @@ retry:		MUTEX_LOCK(env, hp->mtx_hash);
 		MUTEX_UNLOCK(env, hp->mtx_hash);
 		h_locked = 0;
 		if (dirty || extending || makecopy || F_ISSET(bhp, BH_FROZEN)) {
-xlatch:			if (LF_ISSET(DB_MPOOL_TRY)) {
+xlatch:			if (((flags) & (DB_MPOOL_TRY))) {
 				if ((ret =
 				    MUTEX_TRYLOCK(env, bhp->mtx_buf)) != 0)
 					goto err;
 			} else
 				MUTEX_LOCK(env, bhp->mtx_buf);
 			F_SET(bhp, BH_EXCLUSIVE);
-		} else if (LF_ISSET(DB_MPOOL_TRY)) {
+		} else if (((flags) & (DB_MPOOL_TRY))) {
 			if ((ret = MUTEX_TRY_READLOCK(env, bhp->mtx_buf)) != 0)
 				goto err;
 		} else
@@ -577,7 +577,7 @@ reuse:			if ((makecopy || F_ISSET(bhp, B
 		/*
 		 * The buffer is not in the pool, so we don't need to free it.
 		 */
-		if (LF_ISSET(DB_MPOOL_FREE) &&
+		if (((flags) & (DB_MPOOL_FREE)) &&
 		    (bhp == NULL || F_ISSET(bhp, BH_FREED) || !makecopy))
 			goto done;
 
@@ -917,7 +917,7 @@ alloc:		/* Allocate a new buffer header
 		MVCC_MPROTECT(bhp->buf, mfp->pagesize,
 		    PROT_READ | PROT_WRITE);
 		if ((ret = __memp_pgread(dbmfp,
-		    bhp, LF_ISSET(DB_MPOOL_CREATE) ? 1 : 0)) != 0)
+		    bhp, ((flags) & (DB_MPOOL_CREATE)) ? 1 : 0)) != 0)
 			goto err;
 		DB_ASSERT(env, read_lsnp != NULL || !SH_CHAIN_HASNEXT(bhp, vc));
 	}
diff -u -p a/db-5.2.28.NC/src/mp/mp_method.c b/db-5.2.28.NC/src/mp/mp_method.c
--- a/db-5.2.28.NC/src/mp/mp_method.c
+++ b/db-5.2.28.NC/src/mp/mp_method.c
@@ -841,7 +841,7 @@ __memp_ftruncate(dbmfp, txn, ip, pgno, f
 	MUTEX_UNLOCK(env, mfp->mutex);
 
 	if (pgno > last_pgno) {
-		if (LF_ISSET(MP_TRUNC_RECOVER))
+		if (((flags) & (MP_TRUNC_RECOVER)))
 			return (0);
 		__db_errx(env, DB_STR("3005",
 		    "Truncate beyond the end of file"));
@@ -849,7 +849,7 @@ __memp_ftruncate(dbmfp, txn, ip, pgno, f
 	}
 
 	pg = pgno;
-	if (!LF_ISSET(MP_TRUNC_NOCACHE))
+	if (!((flags) & (MP_TRUNC_NOCACHE)))
 		do {
 			if (mfp->block_cnt == 0)
 				break;
diff -u -p a/db-5.2.28.NC/src/mp/mp_sync.c b/db-5.2.28.NC/src/mp/mp_sync.c
--- a/db-5.2.28.NC/src/mp/mp_sync.c
+++ b/db-5.2.28.NC/src/mp/mp_sync.c
@@ -57,11 +57,11 @@ __memp_walk_files(env, mp, func, arg, co
 			if ((t_ret = func(env,
 			    mfp, arg, countp, flags)) != 0 && ret == 0)
 				ret = t_ret;
-			if (ret != 0 && !LF_ISSET(DB_STAT_MEMP_NOERROR))
+			if (ret != 0 && !((flags) & (DB_STAT_MEMP_NOERROR)))
 				break;
 		}
 		MUTEX_UNLOCK(env, hp->mtx_hash);
-		if (ret != 0 && !LF_ISSET(DB_STAT_MEMP_NOERROR))
+		if (ret != 0 && !((flags) & (DB_STAT_MEMP_NOERROR)))
 			break;
 	}
 	return (ret);
@@ -318,8 +318,7 @@ __memp_sync_int(env, dbmfp, trickle_max,
 	 * confirm they made it to disk.  Otherwise, we can skip a block if
 	 * it's hard to get.
 	 */
-	required_write = LF_ISSET(DB_SYNC_CACHE |
-	    DB_SYNC_CHECKPOINT | DB_SYNC_FILE | DB_SYNC_QUEUE_EXTENT);
+	required_write = ((flags) & (DB_SYNC_CACHE | DB_SYNC_CHECKPOINT | DB_SYNC_FILE | DB_SYNC_QUEUE_EXTENT));
 
 	/* Get shared configuration information. */
 	MPOOL_SYSTEM_LOCK(env);
@@ -372,7 +371,7 @@ __memp_sync_int(env, dbmfp, trickle_max,
 				 */
 				if (mfp->no_backing_file)
 					continue;
-				if (!LF_ISSET(DB_SYNC_FILE) &&
+				if (!((flags) & (DB_SYNC_FILE)) &&
 				    F_ISSET(mfp, MP_TEMP))
 					continue;
 
@@ -380,7 +379,7 @@ __memp_sync_int(env, dbmfp, trickle_max,
 				 * Ignore files that aren't involved in DB's
 				 * transactional operations during checkpoints.
 				 */
-				if (LF_ISSET(DB_SYNC_CHECKPOINT) &&
+				if (((flags) & (DB_SYNC_CHECKPOINT)) &&
 				    mfp->lsn_off == DB_LSN_OFF_NOTSET)
 					continue;
 
@@ -388,7 +387,7 @@ __memp_sync_int(env, dbmfp, trickle_max,
 				 * Ignore files that aren't Queue extent files
 				 * if we're flushing a Queue file with extents.
 				 */
-				if (LF_ISSET(DB_SYNC_QUEUE_EXTENT) &&
+				if (((flags) & (DB_SYNC_QUEUE_EXTENT)) &&
 				    !F_ISSET(mfp, MP_EXTENT))
 					continue;
 
@@ -432,7 +431,7 @@ __memp_sync_int(env, dbmfp, trickle_max,
 			MUTEX_UNLOCK(env, hp->mtx_hash);
 
 			/* Check if the call has been interrupted. */
-			if (LF_ISSET(DB_SYNC_INTERRUPT_OK) && FLD_ISSET(
+			if (((flags) & (DB_SYNC_INTERRUPT_OK)) && FLD_ISSET(
 			    mp->config_flags, DB_MEMP_SYNC_INTERRUPT)) {
 				STAT(++mp->stat.st_sync_interrupted);
 				if (interruptedp != NULL)
@@ -458,7 +457,7 @@ __memp_sync_int(env, dbmfp, trickle_max,
 	 * If we're trickling buffers, only write enough to reach the correct
 	 * percentage.
 	 */
-	if (LF_ISSET(DB_SYNC_TRICKLE) && ar_cnt > trickle_max)
+	if (((flags) & (DB_SYNC_TRICKLE)) && ar_cnt > trickle_max)
 		ar_cnt = trickle_max;
 
 	/*
@@ -583,7 +582,7 @@ __memp_sync_int(env, dbmfp, trickle_max,
 		MUTEX_UNLOCK(env, bhp->mtx_buf);
 
 		/* Check if the call has been interrupted. */
-		if (LF_ISSET(DB_SYNC_INTERRUPT_OK) &&
+		if (((flags) & (DB_SYNC_INTERRUPT_OK)) &&
 		    FLD_ISSET(mp->config_flags, DB_MEMP_SYNC_INTERRUPT)) {
 			STAT(++mp->stat.st_sync_interrupted);
 			if (interruptedp != NULL)
@@ -597,7 +596,7 @@ __memp_sync_int(env, dbmfp, trickle_max,
 		 * down might reset the value in order to do a fast flush or
 		 * checkpoint.
 		 */
-		if (!LF_ISSET(DB_SYNC_SUPPRESS_WRITE) &&
+		if (!((flags) & (DB_SYNC_SUPPRESS_WRITE)) &&
 		    !FLD_ISSET(mp->config_flags, DB_MEMP_SUPPRESS_WRITE) &&
 		    mp->mp_maxwrite != 0 && wrote_cnt >= mp->mp_maxwrite) {
 			wrote_cnt = 0;
@@ -693,6 +692,7 @@ __memp_sync_file(env, mfp, argp, countp,
 		++dbmfp->ref;
 		break;
 	}
+	dbmfp = dbmfp;
 	MUTEX_UNLOCK(env, dbmp->mutex);
 
 	/* If we don't find a handle we can use, open one. */
@@ -923,6 +923,7 @@ retry:	MUTEX_LOCK(env, dbmp->mutex);
 				return (ret);
 			goto retry;
 		}
+		dbmfp = dbmfp;
 	MUTEX_UNLOCK(env, dbmp->mutex);
 
 	return (0);
diff -u -p a/db-5.2.28.NC/src/mp/mp_bh.c b/db-5.2.28.NC/src/mp/mp_bh.c
--- a/db-5.2.28.NC/src/mp/mp_bh.c
+++ b/db-5.2.28.NC/src/mp/mp_bh.c
@@ -57,6 +57,7 @@ __memp_bhwrite(dbmp, hp, mfp, bhp, open_
 			++dbmfp->ref;
 			break;
 		}
+		dbmfp = dbmfp;
 	MUTEX_UNLOCK(env, dbmp->mutex);
 
 	if (dbmfp != NULL) {
@@ -547,11 +548,11 @@ __memp_bhfree(dbmp, infop, mfp, hp, bhp,
 		pagesize = mfp->pagesize;
 #endif
 
-	DB_ASSERT(env, LF_ISSET(BH_FREE_UNLOCKED) ||
+	DB_ASSERT(env, ((flags) & (BH_FREE_UNLOCKED)) ||
 	    (hp != NULL && MUTEX_IS_OWNED(env, hp->mtx_hash)));
 	DB_ASSERT(env, BH_REFCOUNT(bhp) == 1 &&
 	    !F_ISSET(bhp, BH_DIRTY | BH_FROZEN));
-	DB_ASSERT(env, LF_ISSET(BH_FREE_UNLOCKED) ||
+	DB_ASSERT(env, ((flags) & (BH_FREE_UNLOCKED)) ||
 	    SH_CHAIN_SINGLETON(bhp, vc) || (SH_CHAIN_HASNEXT(bhp, vc) &&
 	    (SH_CHAIN_NEXTP(bhp, vc, __bh)->td_off == bhp->td_off ||
 	    bhp->td_off == INVALID_ROFF ||
@@ -581,7 +582,7 @@ __memp_bhfree(dbmp, infop, mfp, hp, bhp,
 	 * discarding the environment, so the transaction region is already
 	 * gone.
 	 */
-	if (bhp->td_off != INVALID_ROFF && !LF_ISSET(BH_FREE_UNLOCKED)) {
+	if (bhp->td_off != INVALID_ROFF && !((flags) & (BH_FREE_UNLOCKED))) {
 		ret = __txn_remove_buffer(
 		    env, BH_OWNER(env, bhp), hp->mtx_hash);
 		bhp->td_off = INVALID_ROFF;
@@ -599,23 +600,23 @@ no_hp:	if (mfp != NULL)
 	 * Discard the hash bucket's mutex, it's no longer needed, and
 	 * we don't want to be holding it when acquiring other locks.
 	 */
-	if (!LF_ISSET(BH_FREE_UNLOCKED))
+	if (!((flags) & (BH_FREE_UNLOCKED)))
 		MUTEX_UNLOCK(env, hp->mtx_hash);
 
 	/*
 	 * If we're only removing this header from the chain for reuse, we're
 	 * done.
 	 */
-	if (LF_ISSET(BH_FREE_REUSE))
+	if (((flags) & (BH_FREE_REUSE)))
 		return (ret);
 
 	/*
 	 * If we're not reusing the buffer immediately, free the buffer for
 	 * real.
 	 */
-	if (!LF_ISSET(BH_FREE_UNLOCKED))
+	if (!((flags) & (BH_FREE_UNLOCKED)))
 		MUTEX_UNLOCK(env, bhp->mtx_buf);
-	if (LF_ISSET(BH_FREE_FREEMEM)) {
+	if (((flags) & (BH_FREE_FREEMEM))) {
 		if ((ret = __mutex_free(env, &bhp->mtx_buf)) != 0)
 			return (ret);
 		MPOOL_REGION_LOCK(env, infop);
diff -u -p a/db-5.2.28.NC/src/db/db_remove.c b/db-5.2.28.NC/src/db/db_remove.c
--- a/db-5.2.28.NC/src/db/db_remove.c
+++ b/db-5.2.28.NC/src/db/db_remove.c
@@ -81,20 +81,20 @@ __env_dbremove_pp(dbenv, txn, name, subd
 	    (!CDB_LOCKING(env) || !F_ISSET(txn, TXN_FAMILY))) {
 		ret = __db_not_txn_env(env);
 		goto err;
-	} else if (txn != NULL && LF_ISSET(DB_LOG_NO_DATA)) {
+	} else if (txn != NULL && ((flags) & (DB_LOG_NO_DATA))) {
 		ret = EINVAL;
 		__db_errx(env, DB_STR("0690",
 	    "DB_LOG_NO_DATA may not be specified within a transaction."));
 		goto err;
 	}
-	LF_CLR(DB_AUTO_COMMIT);
+	((flags) &= ~(DB_AUTO_COMMIT));
 
 	if ((ret = __db_create_internal(&dbp, env, 0)) != 0)
 		goto err;
-	if (LF_ISSET(DB_TXN_NOT_DURABLE) &&
+	if (((flags) & (DB_TXN_NOT_DURABLE)) &&
 	    (ret = __db_set_flags(dbp, DB_TXN_NOT_DURABLE)) != 0)
 		goto err;
-	LF_CLR(DB_TXN_NOT_DURABLE);
+	((flags) &= ~(DB_TXN_NOT_DURABLE));
 
 	ret = __db_remove_int(dbp, ip, txn, name, subdb, flags);
 
@@ -282,7 +282,7 @@ __db_remove_int(dbp, ip, txn, name, subd
 	 * may have been left around.  Ignore errors because the temporary file
 	 * might not exist.
 	 */
-	if (!F_ISSET(dbp, DB_AM_INMEM) && LF_ISSET(DB_FORCE) &&
+	if (!F_ISSET(dbp, DB_AM_INMEM) && ((flags) & (DB_FORCE)) &&
 	    (ret = __db_backup_name(env, real_name, NULL, &tmpname)) == 0)
 		(void)__os_unlink(env, tmpname, 0);
 
diff -u -p a/db-5.2.28.NC/src/db/db_vrfy.c b/db-5.2.28.NC/src/db/db_vrfy.c
--- a/db-5.2.28.NC/src/db/db_vrfy.c
+++ b/db-5.2.28.NC/src/db/db_vrfy.c
@@ -104,8 +104,8 @@ __db_verify_internal(dbp, fname, dname,
 
 	DB_ILLEGAL_AFTER_OPEN(dbp, "DB->verify");
 
-	if (!LF_ISSET(DB_SALVAGE))
-		LF_SET(DB_UNREF);
+	if (!((flags) & (DB_SALVAGE)))
+		((flags) |= (DB_UNREF));
 
 	ENV_ENTER(env, ip);
 
@@ -148,8 +148,8 @@ __db_verify_arg(dbp, dname, handle, flag
 	 *
 	 * DB_SALVAGE requires an output stream.
 	 */
-	if (LF_ISSET(DB_SALVAGE)) {
-		if (LF_ISSET(~(DB_AGGRESSIVE | DB_PRINTABLE | DB_SALVAGE)))
+	if (((flags) & (DB_SALVAGE))) {
+		if (((flags) & (~(DB_AGGRESSIVE | DB_PRINTABLE | DB_SALVAGE))))
 			return (__db_ferr(env, "DB->verify", 1));
 		if (handle == NULL) {
 			__db_errx(env, DB_STR("0518",
@@ -157,7 +157,7 @@ __db_verify_arg(dbp, dname, handle, flag
 			return (EINVAL);
 		}
 	} else
-		if (LF_ISSET(DB_AGGRESSIVE | DB_PRINTABLE))
+		if (((flags) & (DB_AGGRESSIVE | DB_PRINTABLE)))
 			return (__db_ferr(env, "DB->verify", 1));
 
 	/*
@@ -167,7 +167,7 @@ __db_verify_arg(dbp, dname, handle, flag
 	if ((ret = __db_fcchk(env, "DB->verify", flags,
 	    DB_ORDERCHKONLY, DB_SALVAGE | DB_NOORDERCHK)) != 0)
 		return (ret);
-	if (LF_ISSET(DB_ORDERCHKONLY) && dname == NULL) {
+	if (((flags) & (DB_ORDERCHKONLY)) && dname == NULL) {
 		__db_errx(env, DB_STR("0519",
 		    "DB_ORDERCHKONLY requires a database name"));
 		return (EINVAL);
@@ -218,7 +218,7 @@ __db_verify(dbp, ip, name, subdb, handle
 	F_SET(dbp, DB_AM_VERIFYING);
 
 	/* Initialize any feedback function. */
-	if (!LF_ISSET(DB_SALVAGE) && dbp->db_feedback != NULL)
+	if (!((flags) & (DB_SALVAGE)) && dbp->db_feedback != NULL)
 		dbp->db_feedback(dbp, DB_VERIFY, 0);
 
 	/*
@@ -238,7 +238,7 @@ __db_verify(dbp, ip, name, subdb, handle
 	 * chars where possible.  We won't get here with this flag if
 	 * we're not salvaging.
 	 */
-	if (LF_ISSET(DB_PRINTABLE))
+	if (((flags) & (DB_PRINTABLE)))
 		F_SET(vdp, SALVAGE_PRINTABLE);
 
 	/* Find the real name of the file. */
@@ -308,14 +308,14 @@ __db_verify(dbp, ip, name, subdb, handle
 	 * requires a subdatabase, and assumes that everything but that
 	 * database's sorting/hashing is correct.
 	 */
-	if (LF_ISSET(DB_ORDERCHKONLY)) {
+	if (((flags) & (DB_ORDERCHKONLY))) {
 		ret = __db_vrfy_orderchkonly(dbp, vdp, name, subdb, flags);
 		goto done;
 	}
 
 	sflags = flags;
 	if (dbp->p_internal != NULL)
-		LF_CLR(DB_SALVAGE);
+		((flags) &= ~(DB_SALVAGE));
 
 	/*
 	 * When salvaging, we use a db to keep track of whether we've seen a
@@ -323,7 +323,7 @@ __db_verify(dbp, ip, name, subdb, handle
 	 * If in the end we have not, we assume its key got lost and print it
 	 * with key "UNKNOWN".
 	 */
-	if (LF_ISSET(DB_SALVAGE)) {
+	if (((flags) & (DB_SALVAGE))) {
 		if ((ret = __db_salvage_init(vdp)) != 0)
 			goto err;
 
@@ -332,7 +332,7 @@ __db_verify(dbp, ip, name, subdb, handle
 		 * and only printing the leaves we find.  "has_subdbs" will
 		 * indicate whether we found subdatabases.
 		 */
-		if (!LF_ISSET(DB_AGGRESSIVE) && __db_salvage_all(
+		if (!((flags) & (DB_AGGRESSIVE)) && __db_salvage_all(
 		    dbp, vdp, handle, callback, flags, &has_subdbs) != 0)
 			isbad = 1;
 
@@ -357,7 +357,7 @@ __db_verify(dbp, ip, name, subdb, handle
 	}
 
 	/* If we're verifying, verify inter-page structure. */
-	if (!LF_ISSET(DB_SALVAGE) && isbad == 0)
+	if (!((flags) & (DB_SALVAGE)) && isbad == 0)
 		if ((t_ret = __db_vrfy_structure(dbp,
 		    vdp, name, 0, lp, rp, flags)) != 0) {
 			if (t_ret == DB_VERIFY_BAD)
@@ -371,7 +371,7 @@ __db_verify(dbp, ip, name, subdb, handle
 	 * we haven't been able to put in context.  Then destroy the salvager's
 	 * state-saving database.
 	 */
-	if (LF_ISSET(DB_SALVAGE)) {
+	if (((flags) & (DB_SALVAGE))) {
 		if ((ret = __db_salvage_unknowns(dbp,
 		    vdp, handle, callback, flags)) != 0)
 			isbad = 1;
@@ -388,16 +388,16 @@ __db_verify(dbp, ip, name, subdb, handle
 		ret = t_ret;
 
 	/* Don't display a footer for a database holding other databases. */
-	if (LF_ISSET(DB_SALVAGE | DB_VERIFY_PARTITION) == DB_SALVAGE &&
+	if (((flags) & (DB_SALVAGE | DB_VERIFY_PARTITION)) == DB_SALVAGE &&
 	    (!has_subdbs || F_ISSET(vdp, SALVAGE_PRINTFOOTER)))
 		(void)__db_prfooter(handle, callback);
 
 done: err:
 	/* Send feedback that we're done. */
-	if (!LF_ISSET(DB_SALVAGE) && dbp->db_feedback != NULL)
+	if (!((flags) & (DB_SALVAGE)) && dbp->db_feedback != NULL)
 		dbp->db_feedback(dbp, DB_VERIFY, 100);
 
-	if (LF_ISSET(DB_SALVAGE) &&
+	if (((flags) & (DB_SALVAGE)) &&
 	    (t_ret = __db_salvage_destroy(vdp)) != 0 && ret == 0)
 		ret = t_ret;
 	if (fhp != NULL &&
@@ -678,7 +678,7 @@ __db_vrfy_walkpages(dbp, vdp, handle, ca
 		 * If DB_SALVAGE is set, we inspect our database of completed
 		 * pages, and skip any we've already printed in the subdb pass.
 		 */
-		if (LF_ISSET(DB_SALVAGE) && (__db_salvage_isdone(vdp, i) != 0))
+		if (((flags) & (DB_SALVAGE)) && (__db_salvage_isdone(vdp, i) != 0))
 			continue;
 
 		/*
@@ -713,12 +713,12 @@ __db_vrfy_walkpages(dbp, vdp, handle, ca
 
 err1:			if (ret == 0)
 				ret = t_ret;
-			if (LF_ISSET(DB_SALVAGE))
+			if (((flags) & (DB_SALVAGE)))
 				continue;
 			return (ret);
 		}
 
-		if (LF_ISSET(DB_SALVAGE)) {
+		if (((flags) & (DB_SALVAGE))) {
 			/*
 			 * We pretty much don't want to quit unless a
 			 * bomb hits.  May as well return that something
@@ -834,7 +834,7 @@ err1:			if (ret == 0)
 		    vdp->thread_info, h, dbp->priority)) != 0) {
 			if (ret == 0)
 				ret = t_ret;
-			if (!LF_ISSET(DB_SALVAGE))
+			if (!((flags) & (DB_SALVAGE)))
 				return (ret);
 		}
 	}
@@ -849,7 +849,7 @@ err1:			if (ret == 0)
 			ret = t_ret;
 		if (t_ret == DB_VERIFY_BAD)
 			isbad = 1;
-		else if (!LF_ISSET(DB_SALVAGE))
+		else if (!((flags) & (DB_SALVAGE)))
 			return (ret);
 	}
 
@@ -1735,7 +1735,7 @@ __db_vrfy_orderchkonly(dbp, vdp, name, s
 	mpf = dbp->mpf;
 	currpg = h = NULL;
 
-	LF_CLR(DB_NOORDERCHK);
+	((flags) &= ~(DB_NOORDERCHK));
 
 	/* Open the master database and get the meta_pgno for the subdb. */
 	if ((ret = __db_master_open(dbp,
@@ -1908,7 +1908,7 @@ __db_salvage_pg(dbp, vdp, pgno, h, handl
 	int keyflag, ret, t_ret;
 
 	env = dbp->env;
-	DB_ASSERT(env, LF_ISSET(DB_SALVAGE));
+	DB_ASSERT(env, ((flags) & (DB_SALVAGE)));
 
 	/*
 	 * !!!
@@ -1982,7 +1982,7 @@ __db_salvage_pg(dbp, vdp, pgno, h, handl
 		 * If we're salvaging aggressively, we don't know whether or not
 		 * there's subdatabases, so we wait on all recno pages.
 		 */
-		if (!LF_ISSET(DB_AGGRESSIVE) &&
+		if (!((flags) & (DB_AGGRESSIVE)) &&
 		    !F_ISSET(vdp, SALVAGE_HASSUBDBS) && dbp->type == DB_RECNO)
 			return (__db_salvage_leaf(dbp,
 			    vdp, pgno, h, handle, callback, flags));
@@ -2015,7 +2015,7 @@ __db_salvage_pg(dbp, vdp, pgno, h, handl
 	 */
 	if ((ret = __db_vrfy_getpageinfo(vdp, pgno, &pip)) != 0)
 		return (ret);
-	if (!F_ISSET(pip, VRFY_HAS_SUBDBS) && !LF_ISSET(DB_VERIFY_PARTITION))
+	if (!F_ISSET(pip, VRFY_HAS_SUBDBS) && !((flags) & (DB_VERIFY_PARTITION)))
 		ret = __db_prheader(
 		    dbp, NULL, 0, keyflag, handle, callback, vdp, pgno);
 	if ((t_ret = __db_vrfy_putpageinfo(env, vdp, pip)) != 0 && ret == 0)
@@ -2044,7 +2044,7 @@ __db_salvage_leaf(dbp, vdp, pgno, h, han
 	ENV *env;
 
 	env = dbp->env;
-	DB_ASSERT(env, LF_ISSET(DB_SALVAGE));
+	DB_ASSERT(env, ((flags) & (DB_SALVAGE)));
 
 	/* If we got this page in the subdb pass, we can safely skip it. */
 	if (__db_salvage_isdone(vdp, pgno))
@@ -2372,7 +2372,7 @@ __db_vrfy_duptype(dbp, vdp, pgno, flags)
 	switch (pip->type) {
 	case P_IBTREE:
 	case P_LDUP:
-		if (!LF_ISSET(DB_ST_DUPSORT)) {
+		if (!((flags) & (DB_ST_DUPSORT))) {
 			EPRINT((env, DB_STR_A("0568",
 	    "Page %lu: sorted duplicate set in unsorted-dup database",
 			    "%lu"), (u_long)pgno));
@@ -2381,7 +2381,7 @@ __db_vrfy_duptype(dbp, vdp, pgno, flags)
 		break;
 	case P_IRECNO:
 	case P_LRECNO:
-		if (LF_ISSET(DB_ST_DUPSORT)) {
+		if (((flags) & (DB_ST_DUPSORT))) {
 			EPRINT((env, DB_STR_A("0569",
 	    "Page %lu: unsorted duplicate set in sorted-dup database",
 			    "%lu"), (u_long)pgno));
diff -u -p a/db-5.2.28.NC/src/db/db_iface.c b/db-5.2.28.NC/src/db/db_iface.c
--- a/db-5.2.28.NC/src/db/db_iface.c
+++ b/db-5.2.28.NC/src/db/db_iface.c
@@ -365,7 +365,7 @@ __db_cursor(dbp, ip, txn, dbcp, flags)
 
 	env = dbp->env;
 
-	if (MULTIVERSION(dbp) && txn == NULL && (LF_ISSET(DB_TXN_SNAPSHOT) ||
+	if (MULTIVERSION(dbp) && txn == NULL && (((flags) & (DB_TXN_SNAPSHOT)) ||
 	    F_ISSET(env->dbenv, DB_ENV_TXN_SNAPSHOT))) {
 		if ((ret =
 		    __txn_begin(env, ip, NULL, &txn, DB_TXN_SNAPSHOT)) != 0)
@@ -377,7 +377,7 @@ __db_cursor(dbp, ip, txn, dbcp, flags)
 	    dbp->dname, txn == NULL ? 0 : txn->txnid, flags, &dbp->fileid[0]);
 
 	if ((ret = __db_cursor_int(dbp, ip, txn, dbp->type, PGNO_INVALID,
-	    LF_ISSET(DB_CURSOR_BULK | DB_CURSOR_TRANSIENT | DB_RECOVER),
+	    ((flags) & (DB_CURSOR_BULK | DB_CURSOR_TRANSIENT | DB_RECOVER)),
 	    NULL, &dbc)) != 0)
 		return (ret);
 
@@ -386,23 +386,23 @@ __db_cursor(dbp, ip, txn, dbcp, flags)
 	 * right here.
 	 */
 	if (CDB_LOCKING(env)) {
-		mode = (LF_ISSET(DB_WRITELOCK)) ? DB_LOCK_WRITE :
-		    ((LF_ISSET(DB_WRITECURSOR) || txn != NULL) ?
+		mode = (((flags) & (DB_WRITELOCK))) ? DB_LOCK_WRITE :
+		    ((((flags) & (DB_WRITECURSOR)) || txn != NULL) ?
 		    DB_LOCK_IWRITE : DB_LOCK_READ);
 		if ((ret = __lock_get(env, dbc->locker, 0,
 		    &dbc->lock_dbt, mode, &dbc->mylock)) != 0)
 			goto err;
-		if (LF_ISSET(DB_WRITECURSOR))
+		if (((flags) & (DB_WRITECURSOR)))
 			F_SET(dbc, DBC_WRITECURSOR);
-		if (LF_ISSET(DB_WRITELOCK))
+		if (((flags) & (DB_WRITELOCK)))
 			F_SET(dbc, DBC_WRITER);
 	}
 
-	if (LF_ISSET(DB_READ_UNCOMMITTED) ||
+	if (((flags) & (DB_READ_UNCOMMITTED)) ||
 	    (txn != NULL && F_ISSET(txn, TXN_READ_UNCOMMITTED)))
 		F_SET(dbc, DBC_READ_UNCOMMITTED);
 
-	if (LF_ISSET(DB_READ_COMMITTED) ||
+	if (((flags) & (DB_READ_COMMITTED)) ||
 	    (txn != NULL && F_ISSET(txn, TXN_READ_COMMITTED)))
 		F_SET(dbc, DBC_READ_COMMITTED);
 
@@ -429,25 +429,24 @@ __db_cursor_arg(dbp, flags)
 	/*
 	 * DB_READ_COMMITTED and DB_READ_UNCOMMITTED require locking.
 	 */
-	if (LF_ISSET(DB_READ_COMMITTED | DB_READ_UNCOMMITTED)) {
+	if (((flags) & (DB_READ_COMMITTED | DB_READ_UNCOMMITTED))) {
 		if (!LOCKING_ON(env))
 			return (__db_fnl(env, "DB->cursor"));
 	}
 
-	LF_CLR(DB_CURSOR_BULK |
-	    DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_TXN_SNAPSHOT);
+	((flags) &= ~(DB_CURSOR_BULK | DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_TXN_SNAPSHOT));
 
 	/* Check for invalid function flags. */
-	if (LF_ISSET(DB_WRITECURSOR)) {
+	if (((flags) & (DB_WRITECURSOR))) {
 		if (DB_IS_READONLY(dbp))
 			return (__db_rdonly(env, "DB->cursor"));
 		if (!CDB_LOCKING(env))
 			return (__db_ferr(env, "DB->cursor", 0));
-		LF_CLR(DB_WRITECURSOR);
-	} else if (LF_ISSET(DB_WRITELOCK)) {
+		((flags) &= ~(DB_WRITECURSOR));
+	} else if (((flags) & (DB_WRITELOCK))) {
 		if (DB_IS_READONLY(dbp))
 			return (__db_rdonly(env, "DB->cursor"));
-		LF_CLR(DB_WRITELOCK);
+		((flags) &= ~(DB_WRITELOCK));
 	}
 
 	if (flags != 0)
@@ -684,8 +683,8 @@ __db_get_pp(dbp, txn, key, data, flags)
 	STRIP_AUTO_COMMIT(flags);
 	DB_ILLEGAL_BEFORE_OPEN(dbp, "DB->get");
 
-	ignore_lease = LF_ISSET(DB_IGNORE_LEASE) ? 1 : 0;
-	LF_CLR(DB_IGNORE_LEASE);
+	ignore_lease = ((flags) & (DB_IGNORE_LEASE)) ? 1 : 0;
+	((flags) &= ~(DB_IGNORE_LEASE));
 
 	if ((ret = __db_get_arg(dbp, key, data, flags)) != 0) {
 		__dbt_userfree(env, key, NULL, data);
@@ -703,7 +702,7 @@ __db_get_pp(dbp, txn, key, data, flags)
 			goto err;
 	}
 
-	if (LF_ISSET(DB_READ_UNCOMMITTED))
+	if (((flags) & (DB_READ_UNCOMMITTED)))
 		mode = DB_READ_UNCOMMITTED;
 	else if ((flags & DB_OPFLAGS_MASK) == DB_CONSUME ||
 	    (flags & DB_OPFLAGS_MASK) == DB_CONSUME_WAIT) {
@@ -717,7 +716,7 @@ __db_get_pp(dbp, txn, key, data, flags)
 
 	/* Check for consistent transaction usage. */
 	if ((ret = __db_check_txn(dbp, txn, DB_LOCK_INVALIDID,
-	    mode == DB_WRITELOCK || LF_ISSET(DB_RMW) ? 0 : 1)) != 0)
+	    mode == DB_WRITELOCK || ((flags) & (DB_RMW)) ? 0 : 1)) != 0)
 		goto err;
 
 	ret = __db_get(dbp, ip, txn, key, data, flags);
@@ -768,12 +767,12 @@ __db_get(dbp, ip, txn, key, data, flags)
 	 * case.
 	 */
 	mode = DB_CURSOR_TRANSIENT;
-	if (LF_ISSET(DB_READ_UNCOMMITTED)) {
+	if (((flags) & (DB_READ_UNCOMMITTED))) {
 		mode |= DB_READ_UNCOMMITTED;
-		LF_CLR(DB_READ_UNCOMMITTED);
-	} else if (LF_ISSET(DB_READ_COMMITTED)) {
+		((flags) &= ~(DB_READ_UNCOMMITTED));
+	} else if (((flags) & (DB_READ_COMMITTED))) {
 		mode |= DB_READ_COMMITTED;
-		LF_CLR(DB_READ_COMMITTED);
+		((flags) &= ~(DB_READ_COMMITTED));
 	} else if ((flags & DB_OPFLAGS_MASK) == DB_CONSUME ||
 	    (flags & DB_OPFLAGS_MASK) == DB_CONSUME_WAIT)
 		mode |= DB_WRITELOCK;
@@ -797,8 +796,8 @@ __db_get(dbp, ip, txn, key, data, flags)
 	 */
 	SET_RET_MEM(dbc, dbp);
 
-	if (LF_ISSET(~(DB_RMW | DB_MULTIPLE)) == 0)
-		LF_SET(DB_SET);
+	if (((flags) & (~(DB_RMW | DB_MULTIPLE))) == 0)
+		((flags) |= (DB_SET));
 
 #ifdef HAVE_PARTITION
 	if (F_ISSET(dbc, DBC_PARTITIONED))
@@ -837,23 +836,23 @@ __db_get_arg(dbp, key, data, flags)
 	 * flag in a path where CDB may have been configured.
 	 */
 	dirty = 0;
-	if (LF_ISSET(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW)) {
+	if (((flags) & (DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW))) {
 		if (!LOCKING_ON(env))
 			return (__db_fnl(env, "DB->get"));
 		if ((ret = __db_fcchk(env, "DB->get",
 		    flags, DB_READ_UNCOMMITTED, DB_READ_COMMITTED)) != 0)
 			return (ret);
-		if (LF_ISSET(DB_READ_COMMITTED | DB_READ_UNCOMMITTED))
+		if (((flags) & (DB_READ_COMMITTED | DB_READ_UNCOMMITTED)))
 			dirty = 1;
-		LF_CLR(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW);
+		((flags) &= ~(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW));
 	}
 
 	multi = 0;
-	if (LF_ISSET(DB_MULTIPLE | DB_MULTIPLE_KEY)) {
-		if (LF_ISSET(DB_MULTIPLE_KEY))
+	if (((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY))) {
+		if (((flags) & (DB_MULTIPLE_KEY)))
 			goto multi_err;
-		multi = LF_ISSET(DB_MULTIPLE) ? 1 : 0;
-		LF_CLR(DB_MULTIPLE);
+		multi = ((flags) & (DB_MULTIPLE)) ? 1 : 0;
+		((flags) &= ~(DB_MULTIPLE));
 	}
 
 	/* Check for invalid function flags. */
@@ -879,7 +878,7 @@ __db_get_arg(dbp, key, data, flags)
 		if (dirty) {
 			__db_errx(env, DB_STR_A("0583",
 		    "%s is not supported with DB_CONSUME or DB_CONSUME_WAIT",
-			    "%s"), LF_ISSET(DB_READ_UNCOMMITTED) ?
+			    "%s"), ((flags) & (DB_READ_UNCOMMITTED)) ?
 			     "DB_READ_UNCOMMITTED" : "DB_READ_COMMITTED");
 			return (EINVAL);
 		}
@@ -929,8 +928,8 @@ err:		return (__db_ferr(env, "DB->get",
 	}
 
 	/* Check invalid partial key. */
-	if (F_ISSET(key, DB_DBT_PARTIAL) && !(LF_ISSET(DB_CONSUME) &&
-	    LF_ISSET(DB_CONSUME_WAIT) && LF_ISSET(DB_SET_RECNO))) {
+	if (F_ISSET(key, DB_DBT_PARTIAL) && !(((flags) & (DB_CONSUME)) &&
+	    ((flags) & (DB_CONSUME_WAIT)) && ((flags) & (DB_SET_RECNO)))) {
 		__db_errx(env, DB_STR("0708",
 		    "Invalid positioning flag combined with DB_DBT_PARTIAL"));
 		return (EINVAL);
@@ -1165,7 +1164,7 @@ __db_open_pp(dbp, txn, fname, dname, typ
 	 * client, so there's a race condition.
 	 */
 	if (IS_REP_CLIENT(env) && !F_ISSET(dbp, DB_AM_NOT_DURABLE))
-		LF_CLR(DB_CREATE);
+		((flags) &= ~(DB_CREATE));
 
 	/*
 	 * Create local transaction as necessary, check for consistent
@@ -1180,7 +1179,7 @@ __db_open_pp(dbp, txn, fname, dname, typ
 		ret = __db_not_txn_env(env);
 		goto err;
 	}
-	LF_CLR(DB_AUTO_COMMIT);
+	((flags) &= ~(DB_AUTO_COMMIT));
 
 	/*
 	 * We check arguments after possibly creating a local transaction,
@@ -1202,8 +1201,8 @@ __db_open_pp(dbp, txn, fname, dname, typ
 	 * rename and remove so we can be sure they're fully sync'ed, so
 	 * we provide an override flag for the purpose.
 	 */
-	if (dname == NULL && !IS_RECOVERING(env) && !LF_ISSET(DB_RDONLY) &&
-	    !LF_ISSET(DB_RDWRMASTER) && F_ISSET(dbp, DB_AM_SUBDB)) {
+	if (dname == NULL && !IS_RECOVERING(env) && !((flags) & (DB_RDONLY)) &&
+	    !((flags) & (DB_RDWRMASTER)) && F_ISSET(dbp, DB_AM_SUBDB)) {
 		__db_errx(env, DB_STR("0590",
     "files containing multiple databases may only be opened read-only"));
 		ret = EINVAL;
@@ -1277,13 +1276,13 @@ __db_open_arg(dbp, txn, fname, dname, ty
 	DB_RDWRMASTER | DB_READ_UNCOMMITTED | DB_THREAD | DB_TRUNCATE)
 	if ((ret = __db_fchk(env, "DB->open", flags, OKFLAGS)) != 0)
 		return (ret);
-	if (LF_ISSET(DB_EXCL) && !LF_ISSET(DB_CREATE))
+	if (((flags) & (DB_EXCL)) && !((flags) & (DB_CREATE)))
 		return (__db_ferr(env, "DB->open", 1));
-	if (LF_ISSET(DB_RDONLY) && LF_ISSET(DB_CREATE))
+	if (((flags) & (DB_RDONLY)) && ((flags) & (DB_CREATE)))
 		return (__db_ferr(env, "DB->open", 1));
 
 #ifdef	HAVE_VXWORKS
-	if (LF_ISSET(DB_TRUNCATE)) {
+	if (((flags) & (DB_TRUNCATE))) {
 		__db_errx(env, DB_STR("0591",
 		    "DB_TRUNCATE not supported on VxWorks"));
 		return (DB_OPNOTSUP);
@@ -1291,7 +1290,7 @@ __db_open_arg(dbp, txn, fname, dname, ty
 #endif
 	switch (type) {
 	case DB_UNKNOWN:
-		if (LF_ISSET(DB_CREATE|DB_TRUNCATE)) {
+		if (((flags) & (DB_CREATE | DB_TRUNCATE))) {
 			__db_errx(env, DB_STR("0592",
 	    "DB_UNKNOWN type specified with DB_CREATE or DB_TRUNCATE"));
 			return (EINVAL);
@@ -1349,27 +1348,27 @@ __db_open_arg(dbp, txn, fname, dname, ty
 	 * You can't specify threads during DB->open if subsystems in the
 	 * environment weren't configured with them.
 	 */
-	if (LF_ISSET(DB_THREAD) && !F_ISSET(env, ENV_DBLOCAL | ENV_THREAD)) {
+	if (((flags) & (DB_THREAD)) && !F_ISSET(env, ENV_DBLOCAL | ENV_THREAD)) {
 		__db_errx(env, DB_STR("0596",
 		    "environment not created using DB_THREAD"));
 		return (EINVAL);
 	}
 
 	/* DB_MULTIVERSION requires a database configured for transactions. */
-	if (LF_ISSET(DB_MULTIVERSION) && !IS_REAL_TXN(txn)) {
+	if (((flags) & (DB_MULTIVERSION)) && !IS_REAL_TXN(txn)) {
 		__db_errx(env, DB_STR("0597",
 		    "DB_MULTIVERSION illegal without a transaction specified"));
 		return (EINVAL);
 	}
 
-	if (LF_ISSET(DB_MULTIVERSION) && type == DB_QUEUE) {
+	if (((flags) & (DB_MULTIVERSION)) && type == DB_QUEUE) {
 		__db_errx(env, DB_STR("0598",
 		    "DB_MULTIVERSION illegal with queue databases"));
 		return (EINVAL);
 	}
 
 	/* DB_TRUNCATE is neither transaction recoverable nor lockable. */
-	if (LF_ISSET(DB_TRUNCATE) && (LOCKING_ON(env) || txn != NULL)) {
+	if (((flags) & (DB_TRUNCATE)) && (LOCKING_ON(env) || txn != NULL)) {
 		__db_errx(env, DB_STR_A("0599",
 		    "DB_TRUNCATE illegal with %s specified", "%s"),
 		    LOCKING_ON(env) ? "locking" : "transactions");
@@ -1418,8 +1417,8 @@ __db_pget_pp(dbp, txn, skey, pkey, data,
 
 	DB_ILLEGAL_BEFORE_OPEN(dbp, "DB->pget");
 
-	ignore_lease = LF_ISSET(DB_IGNORE_LEASE) ? 1 : 0;
-	LF_CLR(DB_IGNORE_LEASE);
+	ignore_lease = ((flags) & (DB_IGNORE_LEASE)) ? 1 : 0;
+	((flags) &= ~(DB_IGNORE_LEASE));
 
 	if ((ret = __db_pget_arg(dbp, pkey, flags)) != 0 ||
 	    (ret = __db_get_arg(dbp, skey, data, flags)) != 0) {
@@ -1475,12 +1474,12 @@ __db_pget(dbp, ip, txn, skey, pkey, data
 	int ret, t_ret;
 
 	mode = DB_CURSOR_TRANSIENT;
-	if (LF_ISSET(DB_READ_UNCOMMITTED)) {
+	if (((flags) & (DB_READ_UNCOMMITTED))) {
 		mode |= DB_READ_UNCOMMITTED;
-		LF_CLR(DB_READ_UNCOMMITTED);
-	} else if (LF_ISSET(DB_READ_COMMITTED)) {
+		((flags) &= ~(DB_READ_UNCOMMITTED));
+	} else if (((flags) & (DB_READ_COMMITTED))) {
 		mode |= DB_READ_COMMITTED;
-		LF_CLR(DB_READ_COMMITTED);
+		((flags) &= ~(DB_READ_COMMITTED));
 	}
 
 	if ((ret = __db_cursor(dbp, ip, txn, &dbc, mode)) != 0)
@@ -1543,14 +1542,14 @@ __db_pget_arg(dbp, pkey, flags)
 		return (EINVAL);
 	}
 
-	if (LF_ISSET(DB_MULTIPLE | DB_MULTIPLE_KEY)) {
+	if (((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY))) {
 		__db_errx(env,DB_STR("0602",
 "DB_MULTIPLE and DB_MULTIPLE_KEY may not be used on secondary indices"));
 		return (EINVAL);
 	}
 
 	/* DB_CONSUME makes no sense on a secondary index. */
-	LF_CLR(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW);
+	((flags) &= ~(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW));
 	switch (flags) {
 	case DB_CONSUME:
 	case DB_CONSUME_WAIT:
@@ -1679,11 +1678,11 @@ __db_put_arg(dbp, key, data, flags)
 		return (EINVAL);
 	}
 
-	if (LF_ISSET(DB_MULTIPLE_KEY | DB_MULTIPLE)) {
-		if (LF_ISSET(DB_MULTIPLE) && LF_ISSET(DB_MULTIPLE_KEY))
+	if (((flags) & (DB_MULTIPLE_KEY | DB_MULTIPLE))) {
+		if (((flags) & (DB_MULTIPLE)) && ((flags) & (DB_MULTIPLE_KEY)))
 			goto err;
 
-		switch (LF_ISSET(DB_OPFLAGS_MASK)) {
+		switch (((flags) & (DB_OPFLAGS_MASK))) {
 		case 0:
 		case DB_OVERWRITE_DUP:
 			break;
@@ -1699,7 +1698,7 @@ __db_put_arg(dbp, key, data, flags)
 			return (EINVAL);
 		}
 	}
-	if (LF_ISSET(DB_MULTIPLE)) {
+	if (((flags) & (DB_MULTIPLE))) {
 		if (!F_ISSET(data, DB_DBT_BULK)) {
 			__db_errx(env, DB_STR("0607",
 		    "DB->put with DB_MULTIPLE requires a bulk data buffer"));
@@ -1708,7 +1707,7 @@ __db_put_arg(dbp, key, data, flags)
 	}
 
 	/* Check for invalid function flags. */
-	switch (LF_ISSET(DB_OPFLAGS_MASK)) {
+	switch (((flags) & (DB_OPFLAGS_MASK))) {
 	case 0:
 	case DB_NOOVERWRITE:
 	case DB_OVERWRITE_DUP:
@@ -1735,7 +1734,7 @@ err:		return (__db_ferr(env, "DB->put",
 	if (((returnkey && key != NULL) || !returnkey) &&
 	    (ret = __dbt_ferr(dbp, "key", key, returnkey)) != 0)
 		return (ret);
-	if (!LF_ISSET(DB_MULTIPLE_KEY) &&
+	if (!((flags) & (DB_MULTIPLE_KEY)) &&
 	    (ret = __dbt_ferr(dbp, "data", data, 0)) != 0)
 		return (ret);
 
@@ -1762,7 +1761,7 @@ err:		return (__db_ferr(env, "DB->put",
 	}
 
 	if ((flags != DB_APPEND && (ret = __dbt_usercopy(env, key)) != 0) ||
-	    (!LF_ISSET(DB_MULTIPLE_KEY) &&
+	    (!((flags) & (DB_MULTIPLE_KEY)) &&
 	    (ret = __dbt_usercopy(env, data)) != 0))
 		return (ret);
 
@@ -1976,12 +1975,12 @@ __db_associate_foreign_arg(fdbp, dbp, ca
 		    "The associating database must be a secondary index."));
 		return (EINVAL);
 	}
-	if (LF_ISSET(DB_FOREIGN_NULLIFY) && callback == NULL) {
+	if (((flags) & (DB_FOREIGN_NULLIFY)) && callback == NULL) {
 		__db_errx(env, DB_STR("0614",
 		    "When specifying a delete action of nullify, a callback "
 		    "function needs to be configured"));
 		return (EINVAL);
-	} else if (!LF_ISSET(DB_FOREIGN_NULLIFY) && callback != NULL) {
+	} else if (!((flags) & (DB_FOREIGN_NULLIFY)) && callback != NULL) {
 		__db_errx(env, DB_STR("0615",
 		    "When not specifying a delete action of nullify, a "
 		    "callback function cannot be configured"));
@@ -2324,8 +2323,8 @@ __dbc_get_pp(dbc, key, data, flags)
 	dbp = dbc->dbp;
 	env = dbp->env;
 
-	ignore_lease = LF_ISSET(DB_IGNORE_LEASE) ? 1 : 0;
-	LF_CLR(DB_IGNORE_LEASE);
+	ignore_lease = ((flags) & (DB_IGNORE_LEASE)) ? 1 : 0;
+	((flags) &= ~(DB_IGNORE_LEASE));
 	if ((ret = __dbc_get_arg(dbc, key, data, flags)) != 0) {
 		__dbt_userfree(env, key, NULL, data);
 		return (ret);
@@ -2383,20 +2382,20 @@ __dbc_get_arg(dbc, key, data, flags)
 	 * flag in a path where CDB may have been configured.
 	 */
 	dirty = 0;
-	if (LF_ISSET(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW)) {
+	if (((flags) & (DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW))) {
 		if (!LOCKING_ON(env))
 			return (__db_fnl(env, "DBcursor->get"));
-		if (LF_ISSET(DB_READ_UNCOMMITTED))
+		if (((flags) & (DB_READ_UNCOMMITTED)))
 			dirty = 1;
-		LF_CLR(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW);
+		((flags) &= ~(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW));
 	}
 
 	multi = 0;
-	if (LF_ISSET(DB_MULTIPLE | DB_MULTIPLE_KEY)) {
+	if (((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY))) {
 		multi = 1;
-		if (LF_ISSET(DB_MULTIPLE) && LF_ISSET(DB_MULTIPLE_KEY))
+		if (((flags) & (DB_MULTIPLE)) && ((flags) & (DB_MULTIPLE_KEY)))
 			goto multi_err;
-		LF_CLR(DB_MULTIPLE | DB_MULTIPLE_KEY);
+		((flags) &= ~(DB_MULTIPLE | DB_MULTIPLE_KEY));
 	}
 
 	/* Check for invalid function flags. */
@@ -2511,7 +2510,7 @@ err:		__dbt_userfree(env, key, NULL, dat
 		return (__db_curinval(env));
 
 	/* Check for consistent transaction usage. */
-	if (LF_ISSET(DB_RMW) &&
+	if (((flags) & (DB_RMW)) &&
 	    (ret = __db_check_txn(dbp, dbc->txn, dbc->locker, 0)) != 0)
 		return (ret);
 
@@ -2587,8 +2586,8 @@ __dbc_pget_pp(dbc, skey, pkey, data, fla
 	dbp = dbc->dbp;
 	env = dbp->env;
 
-	ignore_lease = LF_ISSET(DB_IGNORE_LEASE) ? 1 : 0;
-	LF_CLR(DB_IGNORE_LEASE);
+	ignore_lease = ((flags) & (DB_IGNORE_LEASE)) ? 1 : 0;
+	((flags) &= ~(DB_IGNORE_LEASE));
 	if ((ret = __dbc_pget_arg(dbc, pkey, flags)) != 0 ||
 	    (ret = __dbc_get_arg(dbc, skey, data, flags)) != 0) {
 		__dbt_userfree(env, skey, pkey, data);
@@ -2636,13 +2635,13 @@ __dbc_pget_arg(dbc, pkey, flags)
 		return (EINVAL);
 	}
 
-	if (LF_ISSET(DB_MULTIPLE | DB_MULTIPLE_KEY)) {
+	if (((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY))) {
 		__db_errx(env, DB_STR("0625",
     "DB_MULTIPLE and DB_MULTIPLE_KEY may not be used on secondary indices"));
 		return (EINVAL);
 	}
 
-	switch (LF_ISSET(DB_OPFLAGS_MASK)) {
+	switch (((flags) & (DB_OPFLAGS_MASK))) {
 	case DB_CONSUME:
 	case DB_CONSUME_WAIT:
 		/* These flags make no sense on a secondary index. */
@@ -2653,7 +2652,7 @@ __dbc_pget_arg(dbc, pkey, flags)
 		if (pkey == NULL) {
 			__db_errx(env, DB_STR_A("0626",
 			    "%s requires both a secondary and a primary key",
-			    "%s"), LF_ISSET(DB_GET_BOTH) ?
+			    "%s"), ((flags) & (DB_GET_BOTH)) ?
 			    "DB_GET_BOTH" : "DB_GET_BOTH_RANGE");
 			return (EINVAL);
 		}
diff -u -p a/db-5.2.28.NC/src/db/db_pr.c b/db-5.2.28.NC/src/db/db_pr.c
--- a/db-5.2.28.NC/src/db/db_pr.c
+++ b/db-5.2.28.NC/src/db/db_pr.c
@@ -70,12 +70,12 @@ __db_dumptree(dbp, txn, op, name, first,
 	for (flags = 0; *op != '\0'; ++op)
 		switch (*op) {
 		case 'a':
-			LF_SET(DB_PR_PAGE);
+			((flags) |= (DB_PR_PAGE));
 			break;
 		case 'h':
 			break;
 		case 'r':
-			LF_SET(DB_PR_RECOVERYTEST);
+			((flags) |= (DB_PR_RECOVERYTEST));
 			break;
 		default:
 			return (EINVAL);
@@ -181,12 +181,12 @@ __db_prdb(dbp, flags)
 		__db_msg(env, "bt_meta: %lu bt_root: %lu",
 		    (u_long)bt->bt_meta, (u_long)bt->bt_root);
 		__db_msg(env, "bt_minkey: %lu", (u_long)bt->bt_minkey);
-		if (!LF_ISSET(DB_PR_RECOVERYTEST))
+		if (!((flags) & (DB_PR_RECOVERYTEST)))
 			__db_msg(env, "bt_compare: %#lx bt_prefix: %#lx",
 			    P_TO_ULONG(bt->bt_compare),
 			    P_TO_ULONG(bt->bt_prefix));
 #ifdef HAVE_COMPRESSION
-		if (!LF_ISSET(DB_PR_RECOVERYTEST))
+		if (!((flags) & (DB_PR_RECOVERYTEST)))
 			__db_msg(env, "bt_compress: %#lx bt_decompress: %#lx",
 			    P_TO_ULONG(bt->bt_compress),
 			    P_TO_ULONG(bt->bt_decompress));
@@ -208,7 +208,7 @@ __db_prdb(dbp, flags)
 		__db_msg(env, "meta_pgno: %lu", (u_long)h->meta_pgno);
 		__db_msg(env, "h_ffactor: %lu", (u_long)h->h_ffactor);
 		__db_msg(env, "h_nelem: %lu", (u_long)h->h_nelem);
-		if (!LF_ISSET(DB_PR_RECOVERYTEST))
+		if (!((flags) & (DB_PR_RECOVERYTEST)))
 			__db_msg(env, "h_hash: %#lx", P_TO_ULONG(h->h_hash));
 		break;
 	case DB_QUEUE:
@@ -439,7 +439,7 @@ __db_meta(env, dbp, dbmeta, fn, flags)
 	 * If we're doing recovery testing, don't display the free list,
 	 * it may have changed and that makes the dump diff not work.
 	 */
-	if (dbp != NULL && !LF_ISSET(DB_PR_RECOVERYTEST)) {
+	if (dbp != NULL && !((flags) & (DB_PR_RECOVERYTEST))) {
 		mpf = dbp->mpf;
 		__db_msgadd(
 		    env, &mb, "\tfree list: %lu", (u_long)dbmeta->free);
@@ -698,7 +698,7 @@ __db_prpage_int(env, mbp, dbp, lead, h,
 	 * If we're doing recovery testing and this page is P_INVALID,
 	 * assume it's a page that's on the free list, and don't display it.
 	 */
-	if (LF_ISSET(DB_PR_RECOVERYTEST) && TYPE(h) == P_INVALID)
+	if (((flags) & (DB_PR_RECOVERYTEST)) && TYPE(h) == P_INVALID)
 		return (0);
 
 	if ((s = __db_pagetype_to_string(TYPE(h))) == NULL) {
@@ -714,7 +714,7 @@ __db_prpage_int(env, mbp, dbp, lead, h,
 	 * LSNs on a metadata page will be different from the original after an
 	 * abort, in some cases.  Don't display them if we're testing recovery.
 	 */
-	if (!LF_ISSET(DB_PR_RECOVERYTEST) ||
+	if (!((flags) & (DB_PR_RECOVERYTEST)) ||
 	    (TYPE(h) != P_BTREEMETA && TYPE(h) != P_HASHMETA &&
 	    TYPE(h) != P_QAMMETA && TYPE(h) != P_QAMDATA &&
 	    TYPE(h) != P_HEAPMETA))
@@ -743,7 +743,7 @@ __db_prpage_int(env, mbp, dbp, lead, h,
 	case P_QAMMETA:
 		return (__db_qmeta(env, dbp, (QMETA *)h, flags));
 	case P_QAMDATA:				/* Should be meta->start. */
-		if (!LF_ISSET(DB_PR_PAGE) || dbp == NULL)
+		if (!((flags) & (DB_PR_PAGE)) || dbp == NULL)
 			return (0);
 
 		qlen = ((QUEUE *)dbp->q_internal)->re_len;
@@ -765,7 +765,7 @@ __db_prpage_int(env, mbp, dbp, lead, h,
 	case P_HEAPMETA:
 		return (__db_heapmeta(env, dbp, (HEAPMETA *)h, flags));
 	case P_IHEAP:
-		if (!LF_ISSET(DB_PR_PAGE))
+		if (!((flags) & (DB_PR_PAGE)))
 			return (0);
 		return (__db_heapint(dbp, (HEAPPG *)h, flags));
 	default:
@@ -800,7 +800,7 @@ __db_prpage_int(env, mbp, dbp, lead, h,
 	__db_msgadd(env, mbp, " offset: %4lu", (u_long)HOFFSET(h));
 	DB_MSGBUF_FLUSH(env, mbp);
 
-	if (dbp == NULL || TYPE(h) == P_INVALID || !LF_ISSET(DB_PR_PAGE))
+	if (dbp == NULL || TYPE(h) == P_INVALID || !((flags) & (DB_PR_PAGE)))
 		return (0);
 
 	if (data != NULL)
@@ -1108,7 +1108,7 @@ __db_prflags(env, mbp, flags, fn, prefix
 
 	sep = prefix == NULL ? "" : prefix;
 	for (found = 0, fnp = fn; fnp->mask != 0; ++fnp)
-		if (LF_ISSET(fnp->mask)) {
+		if (((flags) & (fnp->mask))) {
 			__db_msgadd(env, mbp, "%s%s", sep, fnp->name);
 			sep = ", ";
 			found = 1;
diff -u -p a/db-5.2.28.NC/src/db/db_open.c b/db-5.2.28.NC/src/db/db_open.c
--- a/db-5.2.28.NC/src/db/db_open.c
+++ b/db-5.2.28.NC/src/db/db_open.c
@@ -457,7 +457,7 @@ __db_chk_meta(env, dbp, meta, flags)
 		 * We cannot add this to __db_metaswap because that gets done
 		 * later after we've verified the checksum or decrypted.
 		 */
-		if (LF_ISSET(DB_CHK_META)) {
+		if (((flags) & (DB_CHK_META))) {
 			swapped = 0;
 chk_retry:		if ((ret =
 			    __db_check_chksum(env, NULL, env->crypto_handle,
@@ -476,11 +476,11 @@ chk_retry:		if ((ret =
 
 #ifdef HAVE_CRYPTO
 	ret = __crypto_decrypt_meta(env,
-	     dbp, (u_int8_t *)meta, LF_ISSET(DB_CHK_META));
+	     dbp, (u_int8_t *)meta, ((flags) & (DB_CHK_META)));
 #endif
 
 	/* Now that we're decrypted, we can check LSN. */
-	if (LOGGING_ON(env) && !LF_ISSET(DB_CHK_NOLSN)) {
+	if (LOGGING_ON(env) && !((flags) & (DB_CHK_NOLSN))) {
 		/*
 		 * This gets called both before and after swapping, so we
 		 * need to check ourselves.  If we already swapped it above,
@@ -603,7 +603,7 @@ swap_retry:
 		flags = meta->flags;
 		if (F_ISSET(dbp, DB_AM_SWAP))
 			M_32_SWAP(flags);
-		if (LF_ISSET(BTM_RECNO))
+		if (((flags) & (BTM_RECNO)))
 			dbp->type = DB_RECNO;
 		else
 			dbp->type = DB_BTREE;
diff -u -p a/db-5.2.28.NC/src/db/db_meta.c b/db-5.2.28.NC/src/db/db_meta.c
--- a/db-5.2.28.NC/src/db/db_meta.c
+++ b/db-5.2.28.NC/src/db/db_meta.c
@@ -468,7 +468,7 @@ no_sort:
 		case P_LRECNO:
 		case P_LDUP:
 			if (h->entries > 0 && (h->pgno == last_pgno ||
-			    !LF_ISSET(DB_LOG_NO_DATA))) {
+			    !((flags) & (DB_LOG_NO_DATA)))) {
 				ldbt.size += h->entries * sizeof(db_indx_t);
 				ddbt.data = (u_int8_t *)h + HOFFSET(h);
 				ddbt.size = dbp->pgsize - HOFFSET(h);
diff -u -p a/db-5.2.28.NC/src/db/db_setid.c b/db-5.2.28.NC/src/db/db_setid.c
--- a/db-5.2.28.NC/src/db/db_setid.c
+++ b/db-5.2.28.NC/src/db/db_setid.c
@@ -44,7 +44,7 @@ __env_fileid_reset_pp(dbenv, name, flags
 
 	ENV_ENTER(env, ip);
 	REPLICATION_WRAP(env,
-	    (__env_fileid_reset(env, ip, name, LF_ISSET(DB_ENCRYPT) ? 1 : 0)),
+	    (__env_fileid_reset(env, ip, name, ((flags) & (DB_ENCRYPT)) ? 1 : 0)),
 	    1, ret);
 	ENV_LEAVE(env, ip);
 	return (ret);
diff -u -p a/db-5.2.28.NC/src/db/db_rename.c b/db-5.2.28.NC/src/db/db_rename.c
--- a/db-5.2.28.NC/src/db/db_rename.c
+++ b/db-5.2.28.NC/src/db/db_rename.c
@@ -82,7 +82,7 @@ __env_dbrename_pp(dbenv, txn, name, subd
 			goto err;
 		}
 
-	LF_CLR(DB_AUTO_COMMIT);
+	((flags) &= ~(DB_AUTO_COMMIT));
 
 	if ((ret = __db_create_internal(&dbp, env, 0)) != 0)
 		goto err;
lock on line 53 in function __db_walk_cursors in file ../bd-orig/db-5.2.28.NC/src/db/db.c
diff -u -p a/db-5.2.28.NC/src/db/db.c b/db-5.2.28.NC/src/db/db.c
--- a/db-5.2.28.NC/src/db/db.c
+++ b/db-5.2.28.NC/src/db/db.c
@@ -89,8 +89,10 @@ __db_master_open(subdbp, ip, txn, name,
 	*dbpp = NULL;
 
 	/* Open up a handle on the main database. */
-	if ((ret = __db_create_internal(&dbp, subdbp->env, 0)) != 0)
-		return (ret);
+	if ((ret = __db_create_internal(&dbp, subdbp->env, 0)) != 0) {
+		
+			return (ret);
+		}
 
 	/*
 	 * It's always a btree.
@@ -109,8 +111,8 @@ __db_master_open(subdbp, ip, txn, name,
 	 * DB_EXCL to the subdb, not the actual file.  We only got here
 	 * because there was a subdb specified.
 	 */
-	LF_CLR(DB_EXCL);
-	LF_SET(DB_RDWRMASTER);
+	((flags) &= ~(DB_EXCL));
+	((flags) |= (DB_RDWRMASTER));
 	if ((ret = __db_open(dbp, ip, txn,
 	    name, NULL, DB_BTREE, flags, mode, PGNO_BASE_MD)) != 0)
 		goto err;
@@ -176,11 +178,13 @@ __db_master_update(mdbp, sdbp, ip, txn,
 	 * Might we modify the master database?  If so, we'll need to lock.
 	 */
 	modify = (!F_ISSET(mdbp, DB_AM_RDONLY) &&
-	    (action != MU_OPEN || LF_ISSET(DB_CREATE))) ? 1 : 0;
+	    (action != MU_OPEN || ((flags) & (DB_CREATE)))) ? 1 : 0;
 
 	if ((ret = __db_cursor(mdbp, ip, txn, &dbc,
-	    (CDB_LOCKING(env) && modify) ? DB_WRITECURSOR : 0)) != 0)
-		return (ret);
+	    (CDB_LOCKING(env) && modify) ? DB_WRITECURSOR : 0)) != 0) {
+		
+			return (ret);
+		}
 
 	/*
 	 * Point the cursor at the record.
@@ -314,7 +318,7 @@ __db_master_update(mdbp, sdbp, ip, txn,
 		 */
 		switch (ret) {
 		case 0:
-			if (LF_ISSET(DB_CREATE) && LF_ISSET(DB_EXCL)) {
+			if (((flags) & (DB_CREATE)) && ((flags) & (DB_EXCL))) {
 				ret = EEXIST;
 				goto err;
 			}
@@ -322,7 +326,7 @@ __db_master_update(mdbp, sdbp, ip, txn,
 			DB_NTOHL_SWAP(env, &sdbp->meta_pgno);
 			goto done;
 		case DB_NOTFOUND:
-			if (LF_ISSET(DB_CREATE))
+			if (((flags) & (DB_CREATE)))
 				break;
 			/*
 			 * No db_err, it is reasonable to remove a
@@ -421,8 +425,10 @@ __env_dbreg_setup(dbp, txn, fname, dname
 	    ) {
 		if ((ret = __dbreg_setup(dbp,
 		    F_ISSET(dbp, DB_AM_INMEM) ? dname: fname,
-		    F_ISSET(dbp, DB_AM_INMEM) ? NULL : dname, id)) != 0)
-			return (ret);
+		    F_ISSET(dbp, DB_AM_INMEM) ? NULL : dname, id)) != 0) {
+			
+				return (ret);
+			}
 
 		/*
 		 * If we're actively logging and our caller isn't a
@@ -430,8 +436,10 @@ __env_dbreg_setup(dbp, txn, fname, dname
 		 * this dbp a log fileid.
 		 */
 		if (DBENV_LOGGING(env) && !F_ISSET(dbp, DB_AM_RECOVER) &&
-		    (ret = __dbreg_new_id(dbp, txn)) != 0)
-			return (ret);
+		    (ret = __dbreg_new_id(dbp, txn)) != 0) {
+			
+				return (ret);
+			}
 	}
 	return (0);
 }
@@ -470,23 +478,31 @@ __env_setup(dbp, txn, fname, dname, id,
 		if (dbenv->mp_gbytes == 0 &&
 		    dbenv->mp_bytes < dbp->pgsize * DB_MINPAGECACHE &&
 		    (ret = __memp_set_cachesize(
-		    dbenv, 0, dbp->pgsize * DB_MINPAGECACHE, 0)) != 0)
-			return (ret);
+		    dbenv, 0, dbp->pgsize * DB_MINPAGECACHE, 0)) != 0) {
+			
+				return (ret);
+			}
 
 		if ((ret = __env_open(dbenv, NULL, DB_CREATE |
-		    DB_INIT_MPOOL | DB_PRIVATE | LF_ISSET(DB_THREAD), 0)) != 0)
-			return (ret);
+		    DB_INIT_MPOOL | DB_PRIVATE | ((flags) & (DB_THREAD)), 0)) != 0) {
+			
+				return (ret);
+			}
 	}
 
 	/* Join the underlying cache. */
 	if ((!F_ISSET(dbp, DB_AM_INMEM) || dname == NULL) &&
-	    (ret = __env_mpool(dbp, fname, flags)) != 0)
-		return (ret);
+	    (ret = __env_mpool(dbp, fname, flags)) != 0) {
+		
+			return (ret);
+		}
 
 	/* We may need a per-thread mutex. */
-	if (LF_ISSET(DB_THREAD) && (ret = __mutex_alloc(
-	    env, MTX_DB_HANDLE, DB_MUTEX_PROCESS_ONLY, &dbp->mutex)) != 0)
-		return (ret);
+	if (((flags) & (DB_THREAD)) && (ret = __mutex_alloc(
+	    env, MTX_DB_HANDLE, DB_MUTEX_PROCESS_ONLY, &dbp->mutex)) != 0) {
+		
+			return (ret);
+		}
 
 	/*
 	 * Set up a bookkeeping entry for this database in the log region,
@@ -496,8 +512,10 @@ __env_setup(dbp, txn, fname, dname, id,
 	 */
 	if (LOGGING_ON(env) &&
 	    (!F_ISSET(dbp, DB_AM_INMEM) || dname == NULL) &&
-	    (ret = __env_dbreg_setup(dbp, txn, fname, dname, id)) != 0)
-		return (ret);
+	    (ret = __env_dbreg_setup(dbp, txn, fname, dname, id)) != 0) {
+		
+			return (ret);
+		}
 
 	/*
 	 * Insert ourselves into the ENV's dblist.  We allocate a
@@ -529,6 +547,7 @@ __env_setup(dbp, txn, fname, dname, id,
 		if (ldbp->adj_fileid > maxid)
 			maxid = ldbp->adj_fileid;
 	}
+	ldbp = ldbp;
 
 	/*
 	 * If ldbp is NULL, we didn't find a match. Assign the dbp an
@@ -578,8 +597,10 @@ __env_mpool(dbp, fname, flags)
 	lsn_off = F_ISSET(dbp, DB_AM_NOT_DURABLE) ? DB_LSN_OFF_NOTSET : 0;
 
 	/* It's possible that this database is already open. */
-	if (F_ISSET(dbp, DB_AM_OPEN_CALLED))
-		return (0);
+	if (F_ISSET(dbp, DB_AM_OPEN_CALLED)) {
+		
+			return (0);
+		}
 
 	/*
 	 * If we need to pre- or post-process a file's pages on I/O, set the
@@ -677,11 +698,10 @@ __env_mpool(dbp, fname, flags)
 #endif
 		if (F_ISSET(dbp, DB_AM_TXN) &&
 		    dbp->type != DB_QUEUE && dbp->type != DB_UNKNOWN)
-			LF_SET(DB_MULTIVERSION);
+			((flags) |= (DB_MULTIVERSION));
 
 	if ((ret = __memp_fopen(mpf, NULL, fname, &dbp->dirname,
-	    LF_ISSET(DB_CREATE | DB_DURABLE_UNKNOWN | DB_MULTIVERSION |
-		DB_NOMMAP | DB_ODDFILESIZE | DB_RDONLY | DB_TRUNCATE) |
+	    ((flags) & (DB_CREATE | DB_DURABLE_UNKNOWN | DB_MULTIVERSION | DB_NOMMAP | DB_ODDFILESIZE | DB_RDONLY | DB_TRUNCATE)) |
 	    (F_ISSET(env->dbenv, DB_ENV_DIRECT_DB) ? DB_DIRECT : 0) |
 	    (F_ISSET(dbp, DB_AM_NOT_DURABLE) ? DB_TXN_NOT_DURABLE : 0),
 	    0, dbp->pgsize)) != 0) {
@@ -740,8 +760,10 @@ __db_close(dbp, txn, flags)
 	 * If we've deferred the close because the logging of the close failed,
 	 * return our failure right away without destroying the handle.
 	 */
-	if (deferred_close)
-		return (ret);
+	if (deferred_close) {
+		
+			return (ret);
+		}
 
 	/* !!!
 	 * This code has an apparent race between the moment we read and
@@ -810,7 +832,7 @@ __db_refresh(dbp, txn, flags, deferred_c
 	 * sync without an mpool file.
 	 */
 	if (dbp->mpf == NULL)
-		LF_SET(DB_NOSYNC);
+		((flags) |= (DB_NOSYNC));
 
 	/* If never opened, or not currently open, it's easy. */
 	if (!F_ISSET(dbp, DB_AM_OPEN_CALLED))
@@ -859,7 +881,7 @@ __db_refresh(dbp, txn, flags, deferred_c
 	 * entire buffer cache is searched.  If we're in recovery, don't flush
 	 * the file, it's not necessary.
 	 */
-	if (!LF_ISSET(DB_NOSYNC) &&
+	if (!((flags) & (DB_NOSYNC)) &&
 	    !F_ISSET(dbp, DB_AM_DISCARD | DB_AM_RECOVER) &&
 	    (t_ret = __db_sync(dbp)) != 0 && ret == 0)
 		ret = t_ret;
@@ -912,7 +934,7 @@ __db_refresh(dbp, txn, flags, deferred_c
 	 * entire buffer cache is searched.  If we're in recovery, don't flush
 	 * the file, it's not necessary.
 	 */
-	if (resync && !LF_ISSET(DB_NOSYNC) &&
+	if (resync && !((flags) & (DB_NOSYNC)) &&
 	    !F_ISSET(dbp, DB_AM_DISCARD | DB_AM_RECOVER) &&
 	    (t_ret = __memp_fsync(dbp->mpf)) != 0 && ret == 0)
 		ret = t_ret;
@@ -967,8 +989,10 @@ never_opened:
 				 * screwed.  Panic.
 				 */
 				if ((ret =
-				    __txn_closeevent(env, txn, dbp)) != 0)
-					return (__env_panic(env, ret));
+				    __txn_closeevent(env, txn, dbp)) != 0) {
+					
+						return (__env_panic(env, ret));
+					}
 				if (deferred_closep != NULL)
 					*deferred_closep = 1;
 				return (t_ret);
@@ -1115,12 +1139,18 @@ never_opened:
 		save_flags = F_ISSET(dbp, DB_AM_INMEM |
 		    DB_AM_RDONLY | DB_AM_TXN);
 
-		if ((ret = __bam_db_create(dbp)) != 0)
-			return (ret);
-		if ((ret = __ham_db_create(dbp)) != 0)
-			return (ret);
-		if ((ret = __qam_db_create(dbp)) != 0)
-			return (ret);
+		if ((ret = __bam_db_create(dbp)) != 0) {
+			
+				return (ret);
+			}
+		if ((ret = __ham_db_create(dbp)) != 0) {
+			
+				return (ret);
+			}
+		if ((ret = __qam_db_create(dbp)) != 0) {
+			
+				return (ret);
+			}
 
 		/* Restore flags */
 		dbp->flags = dbp->orig_flags | save_flags;
@@ -1245,10 +1275,14 @@ __db_disassociate_foreign(sdbp)
 	DB_FOREIGN_INFO *f_info, *tmp;
 	int ret;
 
-	if (sdbp->s_foreign == NULL)
-		return (0);
-	if ((ret = __os_malloc(sdbp->env, sizeof(DB_FOREIGN_INFO), &tmp)) != 0)
-		return (ret);
+	if (sdbp->s_foreign == NULL) {
+		
+			return (0);
+		}
+	if ((ret = __os_malloc(sdbp->env, sizeof(DB_FOREIGN_INFO), &tmp)) != 0) {
+		
+			return (ret);
+		}
 
 	fdbp = sdbp->s_foreign;
 	ret = 0;
@@ -1283,8 +1317,10 @@ __db_log_page(dbp, txn, lsn, pgno, page)
 	DB_LSN new_lsn;
 	int ret;
 
-	if (!LOGGING_ON(dbp->env) || txn == NULL)
-		return (0);
+	if (!LOGGING_ON(dbp->env) || txn == NULL) {
+		
+			return (0);
+		}
 
 	memset(&page_dbt, 0, sizeof(page_dbt));
 	page_dbt.size = dbp->pgsize;
@@ -1298,6 +1334,39 @@ __db_log_page(dbp, txn, lsn, pgno, page)
 	return (ret);
 }
 
+union instance43 {struct input41{u_int32_t indx;db_pgno_t pgno;u_int32_t *countp;ENV *env;DBC *my_dbc;DBC *dbc;DB *ldbp;void *args;int ret;} input41;
+struct output40{DBC *dbc;} output40;};
+void * function44(void *ctx42);
+void *function44(void *ctx42) {
+	{
+		struct output40 *outcontext38=&(((union instance43 *)ctx42)->output40);
+		struct input41 *incontext39=&(((union instance43 *)ctx42)->input41);
+		u_int32_t indx=incontext39->indx;
+		db_pgno_t pgno=incontext39->pgno;
+		u_int32_t *countp=incontext39->countp;
+		ENV *env=incontext39->env;
+		DBC *my_dbc=incontext39->my_dbc;
+		DBC *dbc=incontext39->dbc;
+		DB *ldbp=incontext39->ldbp;
+		void *args=incontext39->args;
+		int ret=incontext39->ret;
+		ret = ret;
+		{
+			loop:
+			TAILQ_FOREACH (dbc,&ldbp->active_queue,links)
+				if ((ret = (func)(dbc, my_dbc, countp, pgno, indx, args)) != 0)
+					break;
+			dbc = dbc;
+			if (ret == DB_LOCK_NOTGRANTED) {
+				liblock_relock_in_cs(MLOCK(env, ldbp->mutex));
+				goto loop;
+			}
+		}
+		outcontext38->dbc = dbc;
+		return (void *)(uintptr_t)ret;
+	}
+}
+
 /*
  * __db_walk_cursors
  *	Walk all cursors for a database.
@@ -1330,21 +1399,56 @@ int __db_walk_cursors(dbp, my_dbc, func,
 	for (*countp = 0;
 	    ldbp != NULL && ldbp->adj_fileid == dbp->adj_fileid;
 	    ldbp = TAILQ_NEXT(ldbp, dblistlinks)) {
-	  MUTEX_LOCK(env, ldbp->mutex); // jll
+	  { union instance43 instance43 = {
+	  	{
+		  	indx,
+			  pgno,
+			  countp,
+			  env,
+			  my_dbc,
+			  dbc,
+			  ldbp,
+			  args,
+			  ret,
+		  },
+	  };
+	  #if 0
+{
+	  struct output40 *outcontext38 = &(((union instance43 *)ctx42)->output40);
+	  struct input41 *incontext39 = &(((union instance43 *)ctx42)->input41);
+	  u_int32_t indx = incontext39->indx;
+	  db_pgno_t pgno = incontext39->pgno;
+	  u_int32_t *countp = incontext39->countp;
+	  ENV *env = incontext39->env;
+	  DBC *my_dbc = incontext39->my_dbc;
+	  DBC *dbc = incontext39->dbc;
+	  DB *ldbp = incontext39->ldbp;
+	  void *args = incontext39->args;
+	  int ret = incontext39->ret;
+	  ret = ret;{ // jll
 loop:
 		TAILQ_FOREACH(dbc, &ldbp->active_queue, links)
 			if ((ret = (func)(dbc, my_dbc,
 			    countp, pgno, indx, args)) != 0)
 				break;
+				dbc = dbc;
 		/*
 		 * We use the error to communicate that function
 		 * dropped the mutex.
 		 */
 		if (ret == DB_LOCK_NOTGRANTED) {
-			MUTEX_LOCK(env, ldbp->mutex); // jll
+			liblock_relock_in_cs(MLOCK(env, ldbp->mutex)); // jll
 			goto loop;
 		}
-		MUTEX_UNLOCK(env, ldbp->mutex);
+		}outcontext38->dbc = dbc;
+		
+		__RETURN__((void *)(uintptr_t)ret);
+		}
+#endif
+		ret =(int)(uintptr_t)(liblock_execute_operation(env, ldbp->mutex,
+					  (void *)(uintptr_t)(&instance43), &function44));
+		dbc = instance43.output40.dbc;
+		}
 		if (ret != 0)
 			break;
 	}
@@ -1385,8 +1489,10 @@ __db_backup_name(env, name, txn, backup)
 	 * use the entire filename for the backup name.
 	 */
 	len = strlen(name) + strlen(BACKUP_PREFIX) + 2 * MAX_INT_TO_HEX + 1;
-	if ((ret = __os_malloc(env, len, &retp)) != 0)
-		return (ret);
+	if ((ret = __os_malloc(env, len, &retp)) != 0) {
+		
+			return (ret);
+		}
 
 	/*
 	 * Create the name.  Backup file names are in one of 2 forms: in a
@@ -1450,15 +1556,21 @@ __db_testcopy(env, dbp, name)
 		name = R_ADDR(dbmp->reginfo, mpf->mfp->path_off);
 	}
 
-	if (dbp != NULL && dbp->type == DB_QUEUE)
-		return (__qam_testdocopy(dbp, name));
+	if (dbp != NULL && dbp->type == DB_QUEUE) {
+		
+			return (__qam_testdocopy(dbp, name));
+		}
 	else
 #ifdef HAVE_PARTITION
-	if (dbp != NULL && DB_IS_PARTITIONED(dbp))
-		return (__part_testdocopy(dbp, name));
+	if (dbp != NULL && DB_IS_PARTITIONED(dbp)) {
+		
+			return (__part_testdocopy(dbp, name));
+		}
 	else
 #endif
-		return (__db_testdocopy(env, name));
+		{
+			return (__db_testdocopy(env, name));
+		}
 }
 
 static int
@@ -1472,8 +1584,10 @@ __qam_testdocopy(dbp, name)
 	char buf[DB_MAXPATHLEN], *dir;
 
 	filelist = NULL;
-	if ((ret = __db_testdocopy(dbp->env, name)) != 0)
-		return (ret);
+	if ((ret = __db_testdocopy(dbp->env, name)) != 0) {
+		
+			return (ret);
+		}
 
 	/* Call ENV_GET_THREAD_INFO to get a valid DB_THREAD_INFO */
 	ENV_GET_THREAD_INFO(dbp->env, ip);
@@ -1481,14 +1595,18 @@ __qam_testdocopy(dbp, name)
 	    (ret = __qam_gen_filelist(dbp, ip, &filelist)) != 0)
 		goto done;
 
-	if (filelist == NULL)
-		return (0);
+	if (filelist == NULL) {
+		
+			return (0);
+		}
 	dir = ((QUEUE *)dbp->q_internal)->dir;
 	for (fp = filelist; fp->mpf != NULL; fp++) {
 		snprintf(buf, sizeof(buf),
 		    QUEUE_EXTENT, dir, PATH_SEPARATOR[0], name, fp->id);
-		if ((ret = __db_testdocopy(dbp->env, buf)) != 0)
-			return (ret);
+		if ((ret = __db_testdocopy(dbp->env, buf)) != 0) {
+			
+				return (ret);
+			}
 	}
 
 done:	__os_free(dbp->env, filelist);
@@ -1515,8 +1633,10 @@ __db_testdocopy(env, name)
 
 	/* Create the real backing file name. */
 	if ((ret = __db_appname(env,
-	    DB_APP_DATA, name, NULL, &real_name)) != 0)
-		return (ret);
+	    DB_APP_DATA, name, NULL, &real_name)) != 0) {
+		
+			return (ret);
+		}
 
 	/*
 	 * !!!
diff -u -p a/db-5.2.28.NC/src/db/db_am.c b/db-5.2.28.NC/src/db/db_am.c
--- a/db-5.2.28.NC/src/db/db_am.c
+++ b/db-5.2.28.NC/src/db/db_am.c
@@ -23,6 +23,64 @@ static int __db_secondary_get __P((DB *,
 static int __dbc_set_priority __P((DBC *, DB_CACHE_PRIORITY));
 static int __dbc_get_priority __P((DBC *, DB_CACHE_PRIORITY* ));
 
+union instance60 {struct input58{DBC *dbc;DB *dbp;} input58;};
+union instance53 {struct input51{DBTYPE dbtype;ENV *env;DB_TXN *txn;DBC *dbc;DB *dbp;int flags;} input51;
+struct output50{DBC *dbc;int ret;} output50;};
+void * function61(void *ctx59);
+void *function61(void *ctx59) {
+	{
+		struct input58 *incontext56=&(((union instance60 *)ctx59)->input58);
+		DBC *dbc=incontext56->dbc;
+		DB *dbp=incontext56->dbp;
+		{
+			TAILQ_INSERT_TAIL(&dbp->active_queue, dbc, links);
+			F_SET(dbc, DBC_ACTIVE);
+		}
+		return NULL;
+	}
+}
+
+void * function54(void *ctx52);
+void *function54(void *ctx52) {
+	{
+		struct output50 *outcontext48=&(((union instance53 *)ctx52)->output50);
+		struct input51 *incontext49=&(((union instance53 *)ctx52)->input51);
+		int ret;
+		int ret46;
+		DBTYPE dbtype=incontext49->dbtype;
+		ENV *env=incontext49->env;
+		DB_TXN *txn=incontext49->txn;
+		DBC *dbc=incontext49->dbc;
+		DB *dbp=incontext49->dbp;
+		int flags=incontext49->flags;
+		{
+			ret46 = 0;
+#ifndef HAVE_NO_DB_REFCOUNT
+
+			if (IS_REAL_TXN(txn) && !((flags) & (DBC_OPD | DBC_DUPLICATE)) && !F_ISSET(dbp, DB_AM_RECOVER) && dbp->log_filename != NULL && !IS_REP_CLIENT(env) && (ret = __txn_record_fname(env, txn, dbp->log_filename)) != 0) {
+				ret46 = 45 + 1;
+				goto done47;
+			}
+#endif
+
+			TAILQ_FOREACH (dbc,&dbp->free_queue,links)
+				if (dbtype == dbc->dbtype) {
+					TAILQ_REMOVE(&dbp->free_queue, dbc, links);
+					F_CLR(dbc, ~DBC_OWN_LID);
+					break;
+				}
+			dbc = dbc;
+			done47:
+			{
+				
+			}
+		}
+		outcontext48->dbc = dbc;
+		outcontext48->ret = ret;
+		return (void *)(uintptr_t)ret46;
+	}
+}
+
 /*
  * __db_cursor_int --
  *	Internal routine to create a cursor.
@@ -41,6 +99,7 @@ __db_cursor_int(dbp, ip, txn, dbtype, ro
 	DB_LOCKER *locker;
 	DBC **dbcp;
 {
+	int ret46;
 	DBC *dbc;
 	DBC_INTERNAL *cp;
 	ENV *env;
@@ -59,7 +118,29 @@ __db_cursor_int(dbp, ip, txn, dbtype, ro
 	 * right type.  With off page dups we may have different kinds
 	 * of cursors on the queue for a single database.
 	 */
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance53 instance53 = {
+		{
+			dbtype,
+			env,
+			txn,
+			dbc,
+			dbp,
+			flags,
+		},
+	};
+	#if 0
+{
+	struct output50 *outcontext48 = &(((union instance53 *)ctx52)->output50);
+	struct input51 *incontext49 = &(((union instance53 *)ctx52)->input51);
+	int ret;
+	int ret46;
+	DBTYPE dbtype = incontext49->dbtype;
+	ENV *env = incontext49->env;
+	DB_TXN *txn = incontext49->txn;
+	DBC *dbc = incontext49->dbc;
+	DB *dbp = incontext49->dbp;
+	int flags = incontext49->flags;{
+	ret46 = 0;
 
 #ifndef HAVE_NO_DB_REFCOUNT
 	/*
@@ -73,13 +154,12 @@ __db_cursor_int(dbp, ip, txn, dbtype, ro
 	 * this, but we don't have that information.
 	 */
 	if (IS_REAL_TXN(txn) &&
-	    !LF_ISSET(DBC_OPD | DBC_DUPLICATE) &&
+	    !((flags) & (DBC_OPD | DBC_DUPLICATE)) &&
 	    !F_ISSET(dbp, DB_AM_RECOVER) &&
 	    dbp->log_filename != NULL && !IS_REP_CLIENT(env) &&
 	    (ret = __txn_record_fname(env, txn, dbp->log_filename)) != 0) {
-		MUTEX_UNLOCK(env, dbp->mutex);
-		return (ret);
-	}
+		ret46 = 45 + 1;
+		__GOTO__(done47);}
 
 #endif
 
@@ -89,11 +169,34 @@ __db_cursor_int(dbp, ip, txn, dbtype, ro
 			F_CLR(dbc, ~DBC_OWN_LID);
 			break;
 		}
-	MUTEX_UNLOCK(env, dbp->mutex);
+		dbc = dbc;
+	done47: {
+		
+	}
+	}outcontext48->dbc = dbc;
+	outcontext48->ret = ret;
+	
+	__RETURN__((void *)(uintptr_t)ret46);
+	}
+#endif
+	ret46 =(int)(uintptr_t)(liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance53),
+				  &function54));
+	dbc = instance53.output50.dbc;
+	ret = instance53.output50.ret;
+	}
+	if (ret46) {
+		if (ret46 == 45 + 1)
+			{
+				return(ret);
+			}
+		
+	}
 
 	if (dbc == NULL) {
-		if ((ret = __os_calloc(env, 1, sizeof(DBC), &dbc)) != 0)
-			return (ret);
+		if ((ret = __os_calloc(env, 1, sizeof(DBC), &dbc)) != 0) {
+			
+				return (ret);
+			}
 		allocated = 1;
 		dbc->flags = 0;
 
@@ -259,7 +362,7 @@ __db_cursor_int(dbp, ip, txn, dbtype, ro
 		 */
 		if (locker != NULL)
 			dbc->locker = locker;
-		else if (LF_ISSET(DB_RECOVER))
+		else if (((flags) & (DB_RECOVER)))
 			dbc->locker = NULL;
 		else {
 			if (dbc->lref == NULL) {
@@ -295,14 +398,14 @@ __db_cursor_int(dbp, ip, txn, dbtype, ro
 	 * a full search avoids taking write locks necessary to maintain
 	 * consistent numbering.
 	 */
-	if (LF_ISSET(DB_CURSOR_BULK) && dbtype == DB_BTREE &&
+	if (((flags) & (DB_CURSOR_BULK)) && dbtype == DB_BTREE &&
 	    !F_ISSET(dbp, DB_AM_RECNUM))
 		F_SET(dbc, DBC_BULK);
-	if (LF_ISSET(DB_CURSOR_TRANSIENT))
+	if (((flags) & (DB_CURSOR_TRANSIENT)))
 		F_SET(dbc, DBC_TRANSIENT);
-	if (LF_ISSET(DBC_OPD))
+	if (((flags) & (DBC_OPD)))
 		F_SET(dbc, DBC_OPD);
-	if (F_ISSET(dbp, DB_AM_RECOVER) || LF_ISSET(DB_RECOVER))
+	if (F_ISSET(dbp, DB_AM_RECOVER) || ((flags) & (DB_RECOVER)))
 		F_SET(dbc, DBC_RECOVER);
 	if (F_ISSET(dbp, DB_AM_COMPENSATE))
 		F_SET(dbc, DBC_DONTLOCK);
@@ -371,10 +474,24 @@ __db_cursor_int(dbp, ip, txn, dbtype, ro
 	else
 		ENV_GET_THREAD_INFO(env, dbc->thread_info);
 
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance60 instance60 = {
+		{
+			dbc,
+			dbp,
+		},
+	};
+	#if 0
+{
+	struct input58 *incontext56 = &(((union instance60 *)ctx59)->input58);
+	DBC *dbc = incontext56->dbc;
+	DB *dbp = incontext56->dbp;{
 	TAILQ_INSERT_TAIL(&dbp->active_queue, dbc, links);
 	F_SET(dbc, DBC_ACTIVE);
-	MUTEX_UNLOCK(env, dbp->mutex);
+	}__RETURN__(NULL);
+	}
+#endif
+	liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance60),
+				  &function61); }
 
 	*dbcp = dbc;
 	return (0);
@@ -420,12 +537,14 @@ __db_put(dbp, ip, txn, key, data, flags)
 	 * position-dependent.
 	 */
 	cursor_flags = DB_WRITELOCK;
-	if (LF_ISSET(DB_MULTIPLE | DB_MULTIPLE_KEY))
+	if (((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY)))
 		cursor_flags |= DB_CURSOR_BULK;
 	else
 		cursor_flags |= DB_CURSOR_TRANSIENT;
-	if ((ret = __db_cursor(dbp, ip, txn, &dbc, cursor_flags)) != 0)
-		return (ret);
+	if ((ret = __db_cursor(dbp, ip, txn, &dbc, cursor_flags)) != 0) {
+		
+			return (ret);
+		}
 
 	DEBUG_LWRITE(dbc, txn, "DB->put", key, data, flags);
 	PERFMON6(env, db, put, dbp->fname,
@@ -483,7 +602,7 @@ __db_put(dbp, ip, txn, key, data, flags)
 	    !DB_IS_PRIMARY(dbp) && LIST_FIRST(&dbp->f_primaries) == NULL) {
 		ret = __dbc_put(dbc, key, data, flags);
 #endif
-	} else if (LF_ISSET(DB_MULTIPLE)) {
+	} else if (((flags) & (DB_MULTIPLE))) {
 		ret = 0;
 		memset(&tkey, 0, sizeof(tkey));
 		if (dbp->type == DB_QUEUE || dbp->type == DB_RECNO) {
@@ -506,11 +625,11 @@ __db_put(dbp, ip, txn, key, data, flags)
 			if (bulk_kptr == NULL || bulk_ptr == NULL)
 				break;
 			ret = __dbc_put(dbc, &tkey, &tdata,
-			    LF_ISSET(DB_OPFLAGS_MASK));
+			    ((flags) & (DB_OPFLAGS_MASK)));
 			if (ret == 0)
 				++key->doff;
 		}
-	} else if (LF_ISSET(DB_MULTIPLE_KEY)) {
+	} else if (((flags) & (DB_MULTIPLE_KEY))) {
 		ret = 0;
 		memset(&tkey, 0, sizeof(tkey));
 		if (dbp->type == DB_QUEUE || dbp->type == DB_RECNO) {
@@ -529,7 +648,7 @@ __db_put(dbp, ip, txn, key, data, flags)
 			if (bulk_ptr == NULL)
 				break;
 			ret = __dbc_put(dbc, &tkey, &tdata,
-			    LF_ISSET(DB_OPFLAGS_MASK));
+			    ((flags) & (DB_OPFLAGS_MASK)));
 			if (ret == 0)
 				++key->doff;
 		}
@@ -570,10 +689,12 @@ __db_del(dbp, ip, txn, key, flags)
 	COMPQUIET(bulk_ptr, NULL);
 	/* Allocate a cursor. */
 	cursor_flags = DB_WRITELOCK;
-	if (LF_ISSET(DB_MULTIPLE | DB_MULTIPLE_KEY))
+	if (((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY)))
 		cursor_flags |= DB_CURSOR_BULK;
-	if ((ret = __db_cursor(dbp, ip, txn, &dbc, cursor_flags)) != 0)
-		return (ret);
+	if ((ret = __db_cursor(dbp, ip, txn, &dbc, cursor_flags)) != 0) {
+		
+			return (ret);
+		}
 
 	DEBUG_LWRITE(dbc, txn, "DB->del", key, NULL, flags);
 	PERFMON5(env, db, del,
@@ -599,7 +720,7 @@ __db_del(dbp, ip, txn, key, flags)
 	F_SET(&data, DB_DBT_USERMEM);
 	tkey = *key;
 
-	f_init = LF_ISSET(DB_MULTIPLE_KEY) ? DB_GET_BOTH : DB_SET;
+	f_init = ((flags) & (DB_MULTIPLE_KEY)) ? DB_GET_BOTH : DB_SET;
 	f_next = DB_NEXT_DUP;
 
 	/*
@@ -611,7 +732,7 @@ __db_del(dbp, ip, txn, key, flags)
 		f_next |= DB_RMW;
 	}
 
-	if (LF_ISSET(DB_MULTIPLE | DB_MULTIPLE_KEY)) {
+	if (((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY))) {
 		if (dbp->type == DB_QUEUE || dbp->type == DB_RECNO) {
 			memset(&tkey, 0, sizeof(tkey));
 			tkey.data = &recno;
@@ -623,7 +744,7 @@ __db_del(dbp, ip, txn, key, flags)
 bulk_next:	if (dbp->type == DB_QUEUE || dbp->type == DB_RECNO)
 			DB_MULTIPLE_RECNO_NEXT(bulk_ptr, key,
 			    recno, data.data, data.size);
-		else if (LF_ISSET(DB_MULTIPLE))
+		else if (((flags) & (DB_MULTIPLE)))
 			DB_MULTIPLE_NEXT(bulk_ptr, key, tkey.data, tkey.size);
 		else
 			DB_MULTIPLE_KEY_NEXT(bulk_ptr, key,
@@ -679,7 +800,7 @@ bulk_next:	if (dbp->type == DB_QUEUE ||
 		 * Hash "quick delete" removes all on-page duplicates.  We
 		 * can't do that if deleting specific key/data pairs.
 		 */
-		if (dbp->type == DB_HASH && !LF_ISSET(DB_MULTIPLE_KEY)) {
+		if (dbp->type == DB_HASH && !((flags) & (DB_MULTIPLE_KEY))) {
 			DBC *sdbc;
 			sdbc = dbc;
 #ifdef HAVE_PARTITION
@@ -710,7 +831,7 @@ bulk_next:	if (dbp->type == DB_QUEUE ||
 		 * exact records they want deleted.  We don't need to walk
 		 * through a set of duplicates.
 		 */
-		if (LF_ISSET(DB_MULTIPLE_KEY))
+		if (((flags) & (DB_MULTIPLE_KEY)))
 			break;
 
 		F_SET(&tkey, DB_DBT_ISSET);
@@ -722,7 +843,7 @@ bulk_next:	if (dbp->type == DB_QUEUE ||
 		}
 	}
 
-next:	if (ret == 0 && LF_ISSET(DB_MULTIPLE | DB_MULTIPLE_KEY)) {
+next:	if (ret == 0 && ((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY))) {
 		++key->doff;
 		goto bulk_next;
 	}
@@ -750,16 +871,20 @@ __db_sync(dbp)
 	ret = 0;
 
 	/* If the database was read-only, we're done. */
-	if (F_ISSET(dbp, DB_AM_RDONLY))
-		return (0);
+	if (F_ISSET(dbp, DB_AM_RDONLY)) {
+		
+			return (0);
+		}
 
 	/* If it's a Recno tree, write the backing source text file. */
 	if (dbp->type == DB_RECNO)
 		ret = __ram_writeback(dbp);
 
 	/* If the database was never backed by a database file, we're done. */
-	if (F_ISSET(dbp, DB_AM_INMEM))
-		return (ret);
+	if (F_ISSET(dbp, DB_AM_INMEM)) {
+		
+			return (ret);
+		}
 #ifdef HAVE_PARTITION
 	if (DB_IS_PARTITIONED(dbp))
 		ret = __partition_sync(dbp);
@@ -775,6 +900,23 @@ __db_sync(dbp)
 	return (ret);
 }
 
+union instance67 {struct input65{ENV *env;DB *dbp;DB *sdbp;} input65;};
+void * function68(void *ctx66);
+void *function68(void *ctx66) {
+	{
+		struct input65 *incontext63=&(((union instance67 *)ctx66)->input65);
+		ENV *env=incontext63->env;
+		DB *dbp=incontext63->dbp;
+		DB *sdbp=incontext63->sdbp;
+		{
+			DB_ASSERT(env, sdbp->s_refcnt == 0);
+			sdbp->s_refcnt = 1;
+			LIST_INSERT_HEAD(&dbp->s_secondaries, sdbp, s_links);
+		}
+		return NULL;
+	}
+}
+
 /*
  * __db_associate --
  *	Associate another database as a secondary index to this one.
@@ -811,7 +953,7 @@ __db_associate(dbp, ip, txn, sdbp, callb
 	 * error.
 	 */
 	build = 0;
-	if (LF_ISSET(DB_CREATE)) {
+	if (((flags) & (DB_CREATE))) {
 		FLD_SET(sdbp->s_assoc_flags, DB_ASSOC_CREATE);
 
 		if ((ret = __db_cursor(sdbp, ip, txn, &sdbc, 0)) != 0)
@@ -858,7 +1000,7 @@ __db_associate(dbp, ip, txn, sdbp, callb
 
 	F_SET(sdbp, DB_AM_SECONDARY);
 
-	if (LF_ISSET(DB_IMMUTABLE_KEY))
+	if (((flags) & (DB_IMMUTABLE_KEY)))
 		FLD_SET(sdbp->s_assoc_flags, DB_ASSOC_IMMUTABLE_KEY);
 
 	/*
@@ -866,13 +1008,29 @@ __db_associate(dbp, ip, txn, sdbp, callb
 	 * so that we see any updates that occur while we're walking
 	 * the primary.
 	 */
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance67 instance67 = {
+		{
+			env,
+			dbp,
+			sdbp,
+		},
+	};
+	#if 0
+{
+	struct input65 *incontext63 = &(((union instance67 *)ctx66)->input65);
+	ENV *env = incontext63->env;
+	DB *dbp = incontext63->dbp;
+	DB *sdbp = incontext63->sdbp;{
 
 	/* See __db_s_next for an explanation of secondary refcounting. */
 	DB_ASSERT(env, sdbp->s_refcnt == 0);
 	sdbp->s_refcnt = 1;
 	LIST_INSERT_HEAD(&dbp->s_secondaries, sdbp, s_links);
-	MUTEX_UNLOCK(env, dbp->mutex);
+	}__RETURN__(NULL);
+	}
+#endif
+	liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance67),
+				  &function68); }
 
 	if (build) {
 		/*
@@ -961,6 +1119,26 @@ __db_secondary_get(sdbp, txn, skey, data
 	return (__db_pget_pp(sdbp, txn, skey, NULL, data, flags));
 }
 
+union instance74 {struct input72{ENV *env;DB *sdbp;int doclose;} input72;};
+void * function75(void *ctx73);
+void *function75(void *ctx73) {
+	{
+		struct input72 *incontext70=&(((union instance74 *)ctx73)->input72);
+		ENV *env=incontext70->env;
+		DB *sdbp=incontext70->sdbp;
+		int doclose=incontext70->doclose;
+		doclose = doclose;
+		{
+			DB_ASSERT(env, sdbp->s_refcnt != 0);
+			if (--sdbp->s_refcnt == 0) {
+				LIST_REMOVE(sdbp, s_links);
+				doclose = 1;
+			}
+		}
+		return (void *)(uintptr_t)doclose;
+	}
+}
+
 /*
  * __db_secondary_close --
  *	Wrapper function for DB->close() which we use on secondaries to
@@ -991,7 +1169,20 @@ __db_secondary_close(sdbp, flags)
 	primary = sdbp->s_primary;
 	env = primary->env;
 
-	MUTEX_LOCK(env, primary->mutex);
+	{ union instance74 instance74 = {
+		{
+			env,
+			sdbp,
+			doclose,
+		},
+	};
+	#if 0
+{
+	struct input72 *incontext70 = &(((union instance74 *)ctx73)->input72);
+	ENV *env = incontext70->env;
+	DB *sdbp = incontext70->sdbp;
+	int doclose = incontext70->doclose;
+	doclose = doclose;{
 	/*
 	 * Check the refcount--if it was at 1 when we were called, no
 	 * thread is currently updating this secondary through the primary,
@@ -1007,7 +1198,13 @@ __db_secondary_close(sdbp, flags)
 		/* We don't want to call close while the mutex is held. */
 		doclose = 1;
 	}
-	MUTEX_UNLOCK(env, primary->mutex);
+	}
+	__RETURN__((void *)(uintptr_t)doclose);
+	}
+#endif
+	doclose =(int)(uintptr_t)(liblock_execute_operation(env, primary->mutex, (void *)(uintptr_t)(&instance74),
+				  &function75));
+	}
 
 	/*
 	 * sdbp->close is this function;  call the real one explicitly if
@@ -1016,6 +1213,20 @@ __db_secondary_close(sdbp, flags)
 done:	return (doclose ? __db_close(sdbp, NULL, flags) : 0);
 }
 
+union instance81 {struct input79{DB_FOREIGN_INFO *f_info;DB *fdbp;} input79;};
+void * function82(void *ctx80);
+void *function82(void *ctx80) {
+	{
+		struct input79 *incontext77=&(((union instance81 *)ctx80)->input79);
+		DB_FOREIGN_INFO *f_info=incontext77->f_info;
+		DB *fdbp=incontext77->fdbp;
+		{
+			LIST_INSERT_HEAD(&fdbp->f_primaries, f_info, f_links);
+		}
+		return NULL;
+	}
+}
+
 /*
  * __db_associate_foreign --
  *	Associate this database (fdbp) as a foreign constraint to another
@@ -1058,9 +1269,23 @@ __db_associate_foreign(fdbp, pdbp, callb
 	 * say, fdbp->f_primaries lists all databases for which fdbp is a
 	 * foreign constraint.
 	 */
-	MUTEX_LOCK(env, fdbp->mutex);
+	{ union instance81 instance81 = {
+		{
+			f_info,
+			fdbp,
+		},
+	};
+	#if 0
+{
+	struct input79 *incontext77 = &(((union instance81 *)ctx80)->input79);
+	DB_FOREIGN_INFO *f_info = incontext77->f_info;
+	DB *fdbp = incontext77->fdbp;{
 	LIST_INSERT_HEAD(&fdbp->f_primaries, f_info, f_links);
-	MUTEX_UNLOCK(env, fdbp->mutex);
+	}__RETURN__(NULL);
+	}
+#endif
+	liblock_execute_operation(env, fdbp->mutex, (void *)(uintptr_t)(&instance81),
+				  &function82); }
 
 	/*
 	* Associate fdbp as pdbp's foreign db, for referential integrity
@@ -1068,8 +1293,10 @@ __db_associate_foreign(fdbp, pdbp, callb
 	* currently have no way of removing pdbp from the old foreign db's list
 	* of primaries.
 	*/
-	if (pdbp->s_foreign != NULL)
-		return (EINVAL);
+	if (pdbp->s_foreign != NULL) {
+		
+			return (EINVAL);
+		}
 	pdbp->s_foreign = fdbp;
 
 	return (ret);
@@ -1089,8 +1316,10 @@ __dbc_get_priority(dbc, priority)
 	DBC *dbc;
 	DB_CACHE_PRIORITY *priority;
 {
-	if (dbc->priority == DB_PRIORITY_UNCHANGED)
-		return (__memp_get_priority(dbc->dbp->mpf, priority));
+	if (dbc->priority == DB_PRIORITY_UNCHANGED) {
+		
+			return (__memp_get_priority(dbc->dbp->mpf, priority));
+		}
 	else
 		*priority = dbc->priority;
 
diff -u -p a/db-5.2.28.NC/src/db/db_cam.c b/db-5.2.28.NC/src/db/db_cam.c
--- a/db-5.2.28.NC/src/db/db_cam.c
+++ b/db-5.2.28.NC/src/db/db_cam.c
@@ -76,6 +76,50 @@ static inline int __dbc_put_secondaries
  *
  * PUBLIC: int __dbc_close __P((DBC *));
  */
+union instance95 {struct input93{DB_TXN *txn;DBC *dbc;DBC *opd;DB *dbp;} input93;};
+union instance88 {struct input86{ENV *env;DBC *dbc;DBC *opd;DB *dbp;} input86;};
+void * function96(void *ctx94);
+void *function96(void *ctx94) {
+	{
+		struct input93 *incontext91=&(((union instance95 *)ctx94)->input93);
+		DB_TXN *txn=incontext91->txn;
+		DBC *dbc=incontext91->dbc;
+		DBC *opd=incontext91->opd;
+		DB *dbp=incontext91->dbp;
+		{
+			if (opd != NULL) {
+				if (txn != NULL)
+					txn->cursors--;
+				TAILQ_INSERT_TAIL(&dbp->free_queue, opd, links);
+			}
+			TAILQ_INSERT_TAIL(&dbp->free_queue, dbc, links);
+		}
+		return NULL;
+	}
+}
+
+void * function89(void *ctx87);
+void *function89(void *ctx87) {
+	{
+		struct input86 *incontext84=&(((union instance88 *)ctx87)->input86);
+		ENV *env=incontext84->env;
+		DBC *dbc=incontext84->dbc;
+		DBC *opd=incontext84->opd;
+		DB *dbp=incontext84->dbp;
+		{
+			if (opd != NULL) {
+				DB_ASSERT(env, F_ISSET(opd, DBC_ACTIVE));
+				F_CLR(opd, DBC_ACTIVE);
+				TAILQ_REMOVE(&dbp->active_queue, opd, links);
+			}
+			DB_ASSERT(env, F_ISSET(dbc, DBC_ACTIVE));
+			F_CLR(dbc, DBC_ACTIVE);
+			TAILQ_REMOVE(&dbp->active_queue, dbc, links);
+		}
+		return NULL;
+	}
+}
+
 int
 __dbc_close(dbc)
 	DBC *dbc;
@@ -104,7 +148,21 @@ __dbc_close(dbc)
 	 * access specific cursor close routine, btree depends on having that
 	 * order of operations.
 	 */
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance88 instance88 = {
+		{
+			env,
+			dbc,
+			opd,
+			dbp,
+		},
+	};
+	#if 0
+{
+	struct input86 *incontext84 = &(((union instance88 *)ctx87)->input86);
+	ENV *env = incontext84->env;
+	DBC *dbc = incontext84->dbc;
+	DBC *opd = incontext84->opd;
+	DB *dbp = incontext84->dbp;{
 
 	if (opd != NULL) {
 		DB_ASSERT(env, F_ISSET(opd, DBC_ACTIVE));
@@ -115,7 +173,11 @@ __dbc_close(dbc)
 	F_CLR(dbc, DBC_ACTIVE);
 	TAILQ_REMOVE(&dbp->active_queue, dbc, links);
 
-	MUTEX_UNLOCK(env, dbp->mutex);
+	}__RETURN__(NULL);
+	}
+#endif
+	liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance88),
+				  &function89); }
 
 	/* Call the access specific cursor close routine. */
 	if ((t_ret =
@@ -154,14 +216,32 @@ __dbc_close(dbc)
 		txn->cursors--;
 
 	/* Move the cursor(s) to the free queue. */
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance95 instance95 = {
+		{
+			txn,
+			dbc,
+			opd,
+			dbp,
+		},
+	};
+	#if 0
+{
+	struct input93 *incontext91 = &(((union instance95 *)ctx94)->input93);
+	DB_TXN *txn = incontext91->txn;
+	DBC *dbc = incontext91->dbc;
+	DBC *opd = incontext91->opd;
+	DB *dbp = incontext91->dbp;{
 	if (opd != NULL) {
 		if (txn != NULL)
 			txn->cursors--;
 		TAILQ_INSERT_TAIL(&dbp->free_queue, opd, links);
 	}
 	TAILQ_INSERT_TAIL(&dbp->free_queue, dbc, links);
-	MUTEX_UNLOCK(env, dbp->mutex);
+	}__RETURN__(NULL);
+	}
+#endif
+	liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance95),
+				  &function96); }
 
 	if (txn != NULL && F_ISSET(txn, TXN_PRIVATE) && txn->cursors == 0 &&
 	    (t_ret = __txn_commit(txn, 0)) != 0 && ret == 0)
@@ -170,6 +250,20 @@ __dbc_close(dbc)
 	return (ret);
 }
 
+union instance102 {struct input100{DBC *dbc;DB *dbp;} input100;};
+void * function103(void *ctx101);
+void *function103(void *ctx101) {
+	{
+		struct input100 *incontext98=&(((union instance102 *)ctx101)->input100);
+		DBC *dbc=incontext98->dbc;
+		DB *dbp=incontext98->dbp;
+		{
+			TAILQ_REMOVE(&dbp->free_queue, dbc, links);
+		}
+		return NULL;
+	}
+}
+
 /*
  * __dbc_destroy --
  *	Destroy the cursor, called after DBC->close.
@@ -188,9 +282,23 @@ __dbc_destroy(dbc)
 	env = dbp->env;
 
 	/* Remove the cursor from the free queue. */
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance102 instance102 = {
+		{
+			dbc,
+			dbp,
+		},
+	};
+	#if 0
+{
+	struct input100 *incontext98 = &(((union instance102 *)ctx101)->input100);
+	DBC *dbc = incontext98->dbc;
+	DB *dbp = incontext98->dbp;{
 	TAILQ_REMOVE(&dbp->free_queue, dbc, links);
-	MUTEX_UNLOCK(env, dbp->mutex);
+	}__RETURN__(NULL);
+	}
+#endif
+	liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance102),
+				  &function103); }
 
 	/* Free up allocated memory. */
 	if (dbc->my_rskey.data != NULL)
@@ -258,8 +366,10 @@ __dbc_cmp(dbc, other_dbc, result)
 #endif
 
 #ifdef HAVE_COMPRESSION
-	if (DB_IS_COMPRESSED(dbc->dbp))
-		return (__bamc_compress_cmp(dbc, other_dbc, result));
+	if (DB_IS_COMPRESSED(dbc->dbp)) {
+		
+			return (__bamc_compress_cmp(dbc, other_dbc, result));
+		}
 #endif
 
 	curr_dbc = dbc;
@@ -366,18 +476,24 @@ __dbc_count(dbc, recnop)
 		break;
 	case DB_HASH:
 		if (dbc->internal->opd == NULL) {
-			if ((ret = __hamc_count(dbc, recnop)) != 0)
-				return (ret);
+			if ((ret = __hamc_count(dbc, recnop)) != 0) {
+				
+					return (ret);
+				}
 			break;
 		}
 		/* FALLTHROUGH */
 	case DB_BTREE:
 #ifdef HAVE_COMPRESSION
-		if (DB_IS_COMPRESSED(dbc->dbp))
-			return (__bamc_compress_count(dbc, recnop));
+		if (DB_IS_COMPRESSED(dbc->dbp)) {
+			
+				return (__bamc_compress_count(dbc, recnop));
+			}
 #endif
-		if ((ret = __bamc_count(dbc, recnop)) != 0)
-			return (ret);
+		if ((ret = __bamc_count(dbc, recnop)) != 0) {
+			
+				return (ret);
+			}
 		break;
 	case DB_UNKNOWN:
 	default:
@@ -613,11 +729,13 @@ __dbc_idup(dbc_orig, dbcp, flags)
 	if ((ret = __db_cursor_int(dbp, dbc_orig->thread_info,
 	    dbc_orig->txn, dbc_orig->dbtype, dbc_orig->internal->root,
 	    F_ISSET(dbc_orig, DBC_OPD) | DBC_DUPLICATE,
-	    dbc_orig->locker, &dbc_n)) != 0)
-		return (ret);
+	    dbc_orig->locker, &dbc_n)) != 0) {
+		
+			return (ret);
+		}
 
 	/* Position the cursor if requested, acquiring the necessary locks. */
-	if (LF_ISSET(DB_POSITION)) {
+	if (((flags) & (DB_POSITION))) {
 		int_n = dbc_n->internal;
 		int_orig = dbc_orig->internal;
 
@@ -719,8 +837,10 @@ __dbc_newopd(dbc_parent, root, oldopd, d
 
 	if ((ret = __db_cursor_int(dbp, dbc_parent->thread_info,
 	    dbc_parent->txn,
-	    dbtype, root, DBC_OPD, dbc_parent->locker, &opd)) != 0)
-		return (ret);
+	    dbtype, root, DBC_OPD, dbc_parent->locker, &opd)) != 0) {
+		
+			return (ret);
+		}
 
 	opd->priority = dbc_parent->priority;
 	opd->internal->pdbc = dbc_parent;
@@ -738,8 +858,10 @@ __dbc_newopd(dbc_parent, root, oldopd, d
 	 * leave the main cursor in our caller with a non-NULL pointer
 	 * to a freed off-page dup cursor.
 	 */
-	if (oldopd != NULL && (ret = __dbc_close(oldopd)) != 0)
-		return (ret);
+	if (oldopd != NULL && (ret = __dbc_close(oldopd)) != 0) {
+		
+			return (ret);
+		}
 
 	return (0);
 }
@@ -758,13 +880,17 @@ __dbc_get(dbc, key, data, flags)
 {
 	F_CLR(dbc, DBC_ERROR);
 #ifdef HAVE_PARTITION
-	if (F_ISSET(dbc, DBC_PARTITIONED))
-		return (__partc_get(dbc, key, data, flags));
+	if (F_ISSET(dbc, DBC_PARTITIONED)) {
+		
+			return (__partc_get(dbc, key, data, flags));
+		}
 #endif
 
 #ifdef HAVE_COMPRESSION
-	if (DB_IS_COMPRESSED(dbc->dbp))
-		return (__bamc_compress_get(dbc, key, data, flags));
+	if (DB_IS_COMPRESSED(dbc->dbp)) {
+		
+			return (__bamc_compress_get(dbc, key, data, flags));
+		}
 #endif
 
 	return (__dbc_iget(dbc, key, data, flags));
@@ -816,13 +942,13 @@ __dbc_iget(dbc, key, data, flags)
 	    dbc->txn == NULL ? 0 : dbc->txn->txnid, key, data, flags);
 
 	/* Clear OR'd in additional bits so we can check for flag equality. */
-	tmp_rmw = LF_ISSET(DB_RMW);
-	LF_CLR(DB_RMW);
+	tmp_rmw = ((flags) & (DB_RMW));
+	((flags) &= ~(DB_RMW));
 
 	SET_READ_LOCKING_FLAGS(dbc, tmp_read_locking);
 
-	multi = LF_ISSET(DB_MULTIPLE|DB_MULTIPLE_KEY);
-	LF_CLR(DB_MULTIPLE|DB_MULTIPLE_KEY);
+	multi = ((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY));
+	((flags) &= ~(DB_MULTIPLE | DB_MULTIPLE_KEY));
 
 	/*
 	 * Return a cursor's record number.  It has nothing to do with the
@@ -1212,8 +1338,10 @@ __dbc_put_resolve_key(dbc, oldkey, oldda
 	 * cursor is on a deleted key, we return DB_NOTFOUND.
 	 */
 	memset(oldkey, 0, sizeof(DBT));
-	if ((ret = __dbc_get(dbc, oldkey, olddata, rmw | DB_CURRENT)) != 0)
-		return (ret == DB_KEYEMPTY ? DB_NOTFOUND : ret);
+	if ((ret = __dbc_get(dbc, oldkey, olddata, rmw | DB_CURRENT)) != 0) {
+		
+			return (ret == DB_KEYEMPTY ? DB_NOTFOUND : ret);
+		}
 
 	/* Record that we've looked for the old record. */
 	FLD_SET(*put_statep, DBC_PUT_HAVEREC);
@@ -1342,8 +1470,10 @@ __dbc_put_partial(dbc, pkey, data, orig_
 		 * specified key.  Dup a cursor (so we have the same
 		 * locking info) and do a c_get.
 		 */
-		if ((ret = __dbc_idup(dbc, &pdbc, 0)) != 0)
-			return (ret);
+		if ((ret = __dbc_idup(dbc, &pdbc, 0)) != 0) {
+			
+				return (ret);
+			}
 
 		/*
 		 * When doing a put with DB_CURRENT, partial data items have
@@ -1359,8 +1489,10 @@ __dbc_put_partial(dbc, pkey, data, orig_
 		}
 		if ((t_ret = __dbc_close(pdbc)) != 0)
 			ret = t_ret;
-		if (ret != 0)
-			return (ret);
+		if (ret != 0) {
+			
+				return (ret);
+			}
 
 		FLD_SET(*put_statep, DBC_PUT_HAVEREC);
 	}
@@ -1424,8 +1556,10 @@ __dbc_put_fixed_len(dbc, data, out_data)
 		 */
 		if (F_ISSET(data, DB_DBT_PARTIAL)) {
 		       if ((ret = __os_realloc(
-			    env, re_len, &out_data->data)) != 0)
-				return (ret);
+			    env, re_len, &out_data->data)) != 0) {
+				
+					return (ret);
+				}
 		       /*
 			* In the partial case, we have built the item into
 			* out_data already using __db_buildpartial. Just need
@@ -1434,8 +1568,10 @@ __dbc_put_fixed_len(dbc, data, out_data)
 		       size = out_data->size;
 		} else {
 			if ((ret = __os_malloc(
-			    env, re_len, &out_data->data)) != 0)
-				return (ret);
+			    env, re_len, &out_data->data)) != 0) {
+				
+					return (ret);
+				}
 			memcpy(out_data->data, data->data, size);
 		}
 		memset((u_int8_t *)out_data->data + size, re_pad,
@@ -2029,19 +2165,25 @@ __dbc_put(dbc, key, data, flags)
 	 * just skip to the "normal" put.
 	 */
 	if (DB_IS_PRIMARY(dbp) &&
-	    ((ret = __dbc_put_primary(dbc, key, data, flags)) != 0))
-		return (ret);
+	    ((ret = __dbc_put_primary(dbc, key, data, flags)) != 0)) {
+		
+			return (ret);
+		}
 
 	/*
 	 * If this is an append operation, the insert was done prior to the
 	 * secondary updates, so we are finished.
 	 */
-	if (flags == DB_APPEND)
-		return (ret);
+	if (flags == DB_APPEND) {
+		
+			return (ret);
+		}
 
 #ifdef HAVE_COMPRESSION
-	if (DB_IS_COMPRESSED(dbp))
-		return (__bamc_compress_put(dbc, key, data, flags));
+	if (DB_IS_COMPRESSED(dbp)) {
+		
+			return (__bamc_compress_put(dbc, key, data, flags));
+		}
 #endif
 
 	return (__dbc_iput(dbc, key, data, flags));
@@ -2270,8 +2412,10 @@ err:	for (; noldskey > 0; noldskey--, to
 	FREE_IF_NEEDED(env, &oldskey);
 	if (sdbc != NULL && (t_ret = __dbc_close(sdbc)) != 0 && ret == 0)
 		ret = t_ret;
-	if (ret == 0 && nsame == nskey)
-		return (DB_KEYEXIST);
+	if (ret == 0 && nsame == nskey) {
+		
+			return (DB_KEYEXIST);
+		}
 	return (ret);
 }
 
@@ -2483,8 +2627,8 @@ __dbc_pget(dbc, skey, pkey, data, flags)
 	}
 
 	/* Clear OR'd in additional bits so we can check for flag equality. */
-	tmp_rmw = LF_ISSET(DB_RMW);
-	LF_CLR(DB_RMW);
+	tmp_rmw = ((flags) & (DB_RMW));
+	((flags) &= ~(DB_RMW));
 
 	SET_READ_LOCKING_FLAGS(dbc, tmp_read_locking);
 	/*
@@ -2567,8 +2711,10 @@ __dbc_pget(dbc, skey, pkey, data, flags)
 	if (F_ISSET(dbc, DBC_PARTITIONED | DBC_TRANSIENT))
 		dbc_n = dbc;
 	else {
-		if ((ret = __dbc_dup(dbc, &dbc_n, tmp_flags)) != 0)
-			return (ret);
+		if ((ret = __dbc_dup(dbc, &dbc_n, tmp_flags)) != 0) {
+			
+				return (ret);
+			}
 		F_SET(dbc_n, DBC_TRANSIENT);
 	}
 
@@ -2743,7 +2889,7 @@ __dbc_pget_recno(sdbc, pkey, data, flags
 	pdbc = NULL;
 	ret = t_ret = 0;
 
-	rmw = LF_ISSET(DB_RMW);
+	rmw = ((flags) & (DB_RMW));
 
 	memset(&discardme, 0, sizeof(DBT));
 	F_SET(&discardme, DB_DBT_USERMEM | DB_DBT_PARTIAL);
@@ -2764,8 +2910,10 @@ __dbc_pget_recno(sdbc, pkey, data, flags
 		memset(&primary_key, 0, sizeof(DBT));
 		F_SET(&primary_key, DB_DBT_MALLOC);
 		if ((ret = __dbc_get(sdbc,
-		    &discardme, &primary_key, rmw | DB_CURRENT)) != 0)
-			return (ret);
+		    &discardme, &primary_key, rmw | DB_CURRENT)) != 0) {
+			
+				return (ret);
+			}
 
 		/*
 		 * Open a cursor on the primary, set it to the right record,
@@ -2790,11 +2938,15 @@ perr:		__os_ufree(env, primary_key.data)
 		if (pdbc != NULL &&
 		    (t_ret = __dbc_close(pdbc)) != 0 && ret == 0)
 			ret = t_ret;
-		if (ret != 0)
-			return (ret);
+		if (ret != 0) {
+			
+				return (ret);
+			}
 	} else if ((ret = __db_retcopy(env, data, &oob,
-		    sizeof(oob), &sdbc->rkey->data, &sdbc->rkey->ulen)) != 0)
-			return (ret);
+		    sizeof(oob), &sdbc->rkey->data, &sdbc->rkey->ulen)) != 0) {
+			
+				return (ret);
+			}
 
 	/*
 	 * If the secondary is an rbtree, we want its record number, whether
@@ -2802,11 +2954,15 @@ perr:		__os_ufree(env, primary_key.data)
 	 *
 	 * If it's not an rbtree, return RECNO_OOB in "pkey".
 	 */
-	if (F_ISSET(sdbp, DB_AM_RECNUM))
-		return (__dbc_get(sdbc, &discardme, pkey, flags));
+	if (F_ISSET(sdbp, DB_AM_RECNUM)) {
+		
+			return (__dbc_get(sdbc, &discardme, pkey, flags));
+		}
 	else
-		return (__db_retcopy(env, pkey, &oob,
+		{
+			return (__db_retcopy(env, pkey, &oob,
 		    sizeof(oob), &sdbc->rdata->data, &sdbc->rdata->ulen));
+		}
 }
 
 /*
@@ -2853,8 +3009,10 @@ __dbc_del_secondary(dbc)
 	memset(&skey, 0, sizeof(DBT));
 	memset(&pkey, 0, sizeof(DBT));
 	F_SET(&skey, DB_DBT_PARTIAL | DB_DBT_USERMEM);
-	if ((ret = __dbc_get(dbc, &skey, &pkey, DB_CURRENT)) != 0)
-		return (ret);
+	if ((ret = __dbc_get(dbc, &skey, &pkey, DB_CURRENT)) != 0) {
+		
+			return (ret);
+		}
 
 	SWAP_IF_NEEDED(dbc->dbp, &pkey);
 	DEBUG_LWRITE(dbc, dbc->txn, "del_secondary", &skey, &pkey, 0);
@@ -2870,8 +3028,10 @@ __dbc_del_secondary(dbc)
 	 * anyway.
 	 */
 	if ((ret = __db_cursor_int(pdbp, dbc->thread_info, dbc->txn,
-	    pdbp->type, PGNO_INVALID, 0, dbc->locker, &pdbc)) != 0)
-		return (ret);
+	    pdbp->type, PGNO_INVALID, 0, dbc->locker, &pdbc)) != 0) {
+		
+			return (ret);
+		}
 
 	/*
 	 * See comment in __dbc_put--if we're in CDB,
@@ -2938,8 +3098,10 @@ __dbc_del_primary(dbc)
 	 */
 	memset(&pkey, 0, sizeof(DBT));
 	memset(&data, 0, sizeof(DBT));
-	if ((ret = __dbc_get(dbc, &pkey, &data, DB_CURRENT)) != 0)
-		return (ret);
+	if ((ret = __dbc_get(dbc, &pkey, &data, DB_CURRENT)) != 0) {
+		
+			return (ret);
+		}
 
 	memset(&skey, 0, sizeof(DBT));
 	for (ret = __db_s_first(dbp, &sdbp);
@@ -3064,8 +3226,10 @@ __dbc_del_foreign(dbc)
 
 	memset(&fkey, 0, sizeof(DBT));
 	memset(&data, 0, sizeof(DBT));
-	if ((ret = __dbc_get(dbc, &fkey, &data, DB_CURRENT)) != 0)
-		return (ret);
+	if ((ret = __dbc_get(dbc, &fkey, &data, DB_CURRENT)) != 0) {
+		
+			return (ret);
+		}
 
 	LIST_FOREACH(f_info, &(dbp->f_primaries), f_links) {
 		sdbp = f_info->dbp;
@@ -3073,7 +3237,7 @@ __dbc_del_foreign(dbc)
 		flags = f_info->flags;
 
 		rmw = (STD_LOCKING(dbc) &&
-		    !LF_ISSET(DB_FOREIGN_ABORT)) ? DB_RMW : 0;
+		    !((flags) & (DB_FOREIGN_ABORT))) ? DB_RMW : 0;
 
 		/*
 		 * Handle CDB locking.  Some of this is copied from
@@ -3094,11 +3258,11 @@ __dbc_del_foreign(dbc)
 		 * primary via __db_cursor_int to avoid deadlocking.
 		 */
 		sdbc = pdbc = NULL;
-		if (!LF_ISSET(DB_FOREIGN_ABORT) && CDB_LOCKING(env) &&
+		if (!((flags) & (DB_FOREIGN_ABORT)) && CDB_LOCKING(env) &&
 		    !F_ISSET(env->dbenv, DB_ENV_CDB_ALLDB)) {
 			ret = __db_cursor(sdbp,
 			    dbc->thread_info, dbc->txn, &sdbc, DB_WRITECURSOR);
-			if (LF_ISSET(DB_FOREIGN_NULLIFY) && ret == 0) {
+			if (((flags) & (DB_FOREIGN_NULLIFY)) && ret == 0) {
 				ret = __db_cursor_int(pdbp,
 				    dbc->thread_info, dbc->txn, pdbp->type,
 				    PGNO_INVALID, 0, dbc->locker, &pdbc);
@@ -3107,7 +3271,7 @@ __dbc_del_foreign(dbc)
 		} else {
 			ret = __db_cursor_int(sdbp, dbc->thread_info, dbc->txn,
 			    sdbp->type, PGNO_INVALID, 0, dbc->locker, &sdbc);
-			if (LF_ISSET(DB_FOREIGN_NULLIFY) && ret == 0)
+			if (((flags) & (DB_FOREIGN_NULLIFY)) && ret == 0)
 				ret = __db_cursor_int(pdbp, dbc->thread_info,
 				    dbc->txn, pdbp->type, PGNO_INVALID, 0,
 				    dbc->locker, &pdbc);
@@ -3120,7 +3284,7 @@ __dbc_del_foreign(dbc)
 		if (CDB_LOCKING(env) && F_ISSET(env->dbenv, DB_ENV_CDB_ALLDB)) {
 			DB_ASSERT(env, sdbc->mylock.off == LOCK_INVALID);
 			F_SET(sdbc, DBC_WRITER);
-			if (LF_ISSET(DB_FOREIGN_NULLIFY) && pdbc != NULL) {
+			if (((flags) & (DB_FOREIGN_NULLIFY)) && pdbc != NULL) {
 				DB_ASSERT(env,
 				    pdbc->mylock.off == LOCK_INVALID);
 				F_SET(pdbc, DBC_WRITER);
@@ -3146,22 +3310,26 @@ __dbc_del_foreign(dbc)
 		if (ret == DB_NOTFOUND) {
 			/* No entry means no constraint */
 			ret = __dbc_close(sdbc);
-			if (LF_ISSET(DB_FOREIGN_NULLIFY) &&
+			if (((flags) & (DB_FOREIGN_NULLIFY)) &&
 			    (t_ret = __dbc_close(pdbc)) != 0)
 				ret = t_ret;
-			if (ret != 0)
-				return (ret);
+			if (ret != 0) {
+				
+					return (ret);
+				}
 			continue;
 		} else if (ret != 0) {
 			/* Just return the error code from the pget */
 			(void)__dbc_close(sdbc);
-			if (LF_ISSET(DB_FOREIGN_NULLIFY))
+			if (((flags) & (DB_FOREIGN_NULLIFY)))
 				(void)__dbc_close(pdbc);
 			return (ret);
-		} else if (LF_ISSET(DB_FOREIGN_ABORT)) {
+		} else if (((flags) & (DB_FOREIGN_ABORT))) {
 			/* If the record exists and ABORT is set, we're done */
-			if ((ret = __dbc_close(sdbc)) != 0)
-				return (ret);
+			if ((ret = __dbc_close(sdbc)) != 0) {
+				
+					return (ret);
+				}
 			return (DB_FOREIGN_CONFLICT);
 		}
 
@@ -3170,7 +3338,7 @@ __dbc_del_foreign(dbc)
 		 * is either DB_FOREIGN_CASCADE or DB_FOREIGN_NULLIFY.
 		 */
 		while (ret == 0) {
-			if (LF_ISSET(DB_FOREIGN_CASCADE)) {
+			if (((flags) & (DB_FOREIGN_CASCADE))) {
 				/*
 				 * Don't use the DB_UPDATE_SECONDARY flag,
 				 * since we want the delete to cascade into the
@@ -3181,7 +3349,7 @@ __dbc_del_foreign(dbc)
 	    "Attempt to execute cascading delete in a foreign index failed"));
 					break;
 				}
-			} else if (LF_ISSET(DB_FOREIGN_NULLIFY)) {
+			} else if (((flags) & (DB_FOREIGN_NULLIFY))) {
 				changed = 0;
 				if ((ret = f_info->callback(sdbp,
 				    &pkey, &data, &fkey, &changed)) != 0) {
@@ -3212,16 +3380,32 @@ __dbc_del_foreign(dbc)
 			ret = 0;
 		if ((t_ret = __dbc_close(sdbc)) != 0 && ret == 0)
 			ret = t_ret;
-		if (LF_ISSET(DB_FOREIGN_NULLIFY) &&
+		if (((flags) & (DB_FOREIGN_NULLIFY)) &&
 		    (t_ret = __dbc_close(pdbc)) != 0 && ret == 0)
 			ret = t_ret;
-		if (ret != 0)
-			return (ret);
+		if (ret != 0) {
+			
+				return (ret);
+			}
 	}
 
 	return (ret);
 }
 
+void * function110(void *ctx108);
+void *function110(void *ctx108) {
+	{
+		DB *sdbp;
+		DB *pdbp=(DB *)(uintptr_t)ctx108;
+		{
+			sdbp = LIST_FIRST(&pdbp->s_secondaries);
+			if (sdbp != NULL)
+				sdbp->s_refcnt++;
+		}
+		return (void *)(uintptr_t)sdbp;
+	}
+}
+
 /*
  * __db_s_first --
  *	Get the first secondary, if any are present, from the primary.
@@ -3234,19 +3418,55 @@ __db_s_first(pdbp, sdbpp)
 {
 	DB *sdbp;
 
-	MUTEX_LOCK(pdbp->env, pdbp->mutex);
+	{
+	#if 0
+{
+	DB *sdbp;
+	DB *pdbp = (DB *)(uintptr_t)ctx108;{
 	sdbp = LIST_FIRST(&pdbp->s_secondaries);
 
 	/* See __db_s_next. */
 	if (sdbp != NULL)
 		sdbp->s_refcnt++;
-	MUTEX_UNLOCK(pdbp->env, pdbp->mutex);
+	}
+	__RETURN__((void *)(uintptr_t)sdbp);
+	}
+#endif
+	sdbp =(DB *)(uintptr_t)(liblock_execute_operation(pdbp->env, pdbp->mutex,
+				  (void *)(uintptr_t)(pdbp), &function110));
+	}
 
 	*sdbpp = sdbp;
 
 	return (0);
 }
 
+union instance116 {struct input114{ENV *env;DB *closeme;DB *sdbp;} input114;
+struct output113{DB *closeme;} output113;};
+void * function117(void *ctx115);
+void *function117(void *ctx115) {
+	{
+		struct output113 *outcontext111=&(((union instance116 *)ctx115)->output113);
+		struct input114 *incontext112=&(((union instance116 *)ctx115)->input114);
+		ENV *env=incontext112->env;
+		DB *closeme=incontext112->closeme;
+		DB *sdbp=incontext112->sdbp;
+		closeme = closeme;
+		{
+			DB_ASSERT(env, sdbp->s_refcnt != 0);
+			if (--sdbp->s_refcnt == 0) {
+				LIST_REMOVE(sdbp, s_links);
+				closeme = sdbp;
+			}
+			sdbp = LIST_NEXT(sdbp, s_links);
+			if (sdbp != NULL)
+				sdbp->s_refcnt++;
+		}
+		outcontext111->closeme = closeme;
+		return (void *)(uintptr_t)sdbp;
+	}
+}
+
 /*
  * __db_s_next --
  *	Get the next secondary in the list.
@@ -3290,7 +3510,21 @@ __db_s_next(sdbpp, txn)
 	env = pdbp->env;
 	closeme = NULL;
 
-	MUTEX_LOCK(env, pdbp->mutex);
+	{ union instance116 instance116 = {
+		{
+			env,
+			closeme,
+			sdbp,
+		},
+	};
+	#if 0
+{
+	struct output113 *outcontext111 = &(((union instance116 *)ctx115)->output113);
+	struct input114 *incontext112 = &(((union instance116 *)ctx115)->input114);
+	ENV *env = incontext112->env;
+	DB *closeme = incontext112->closeme;
+	DB *sdbp = incontext112->sdbp;
+	closeme = closeme;{
 	DB_ASSERT(env, sdbp->s_refcnt != 0);
 	if (--sdbp->s_refcnt == 0) {
 		LIST_REMOVE(sdbp, s_links);
@@ -3299,7 +3533,15 @@ __db_s_next(sdbpp, txn)
 	sdbp = LIST_NEXT(sdbp, s_links);
 	if (sdbp != NULL)
 		sdbp->s_refcnt++;
-	MUTEX_UNLOCK(env, pdbp->mutex);
+	}outcontext111->closeme = closeme;
+	
+	__RETURN__((void *)(uintptr_t)sdbp);
+	}
+#endif
+	sdbp =(DB *)(uintptr_t)(liblock_execute_operation(env, pdbp->mutex, (void *)(uintptr_t)(&instance116),
+				  &function117));
+	closeme = instance116.output113.closeme;
+	}
 
 	*sdbpp = sdbp;
 
@@ -3314,6 +3556,26 @@ __db_s_next(sdbpp, txn)
 	return (ret);
 }
 
+union instance123 {struct input121{ENV *env;DB *sdbp;int doclose;} input121;};
+void * function124(void *ctx122);
+void *function124(void *ctx122) {
+	{
+		struct input121 *incontext119=&(((union instance123 *)ctx122)->input121);
+		ENV *env=incontext119->env;
+		DB *sdbp=incontext119->sdbp;
+		int doclose=incontext119->doclose;
+		doclose = doclose;
+		{
+			DB_ASSERT(env, sdbp->s_refcnt != 0);
+			if (--sdbp->s_refcnt == 0) {
+				LIST_REMOVE(sdbp, s_links);
+				doclose = 1;
+			}
+		}
+		return (void *)(uintptr_t)doclose;
+	}
+}
+
 /*
  * __db_s_done --
  *	Properly decrement the refcount on a secondary database handle we're
@@ -3334,13 +3596,32 @@ __db_s_done(sdbp, txn)
 	env = pdbp->env;
 	doclose = 0;
 
-	MUTEX_LOCK(env, pdbp->mutex);
+	{ union instance123 instance123 = {
+		{
+			env,
+			sdbp,
+			doclose,
+		},
+	};
+	#if 0
+{
+	struct input121 *incontext119 = &(((union instance123 *)ctx122)->input121);
+	ENV *env = incontext119->env;
+	DB *sdbp = incontext119->sdbp;
+	int doclose = incontext119->doclose;
+	doclose = doclose;{
 	DB_ASSERT(env, sdbp->s_refcnt != 0);
 	if (--sdbp->s_refcnt == 0) {
 		LIST_REMOVE(sdbp, s_links);
 		doclose = 1;
 	}
-	MUTEX_UNLOCK(env, pdbp->mutex);
+	}
+	__RETURN__((void *)(uintptr_t)doclose);
+	}
+#endif
+	doclose =(int)(uintptr_t)(liblock_execute_operation(env, pdbp->mutex, (void *)(uintptr_t)(&instance123),
+				  &function124));
+	}
 
 	if (doclose == 0)
 		ret = 0;
@@ -3349,6 +3630,23 @@ __db_s_done(sdbp, txn)
 	return (ret);
 }
 
+union instance130 {struct input128{DB *pdbp;int count;} input128;};
+void * function131(void *ctx129);
+void *function131(void *ctx129) {
+	{
+		struct input128 *incontext126=&(((union instance130 *)ctx129)->input128);
+		DB *sdbp;
+		DB *pdbp=incontext126->pdbp;
+		int count=incontext126->count;
+		count = count;
+		{
+			for (sdbp = LIST_FIRST(&pdbp->s_secondaries);sdbp != NULL;sdbp = LIST_NEXT(sdbp, s_links))
+				++count;
+		}
+		return (void *)(uintptr_t)count;
+	}
+}
+
 /*
  * __db_s_count --
  *	Count the number of secondaries associated with a given primary.
@@ -3364,12 +3662,30 @@ __db_s_count(pdbp)
 	env = pdbp->env;
 	count = 0;
 
-	MUTEX_LOCK(env, pdbp->mutex);
+	{ union instance130 instance130 = {
+		{
+			pdbp,
+			count,
+		},
+	};
+	#if 0
+{
+	struct input128 *incontext126 = &(((union instance130 *)ctx129)->input128);
+	DB *sdbp;
+	DB *pdbp = incontext126->pdbp;
+	int count = incontext126->count;
+	count = count;{
 	for (sdbp = LIST_FIRST(&pdbp->s_secondaries);
 	    sdbp != NULL;
 	    sdbp = LIST_NEXT(sdbp, s_links))
 		++count;
-	MUTEX_UNLOCK(env, pdbp->mutex);
+	}
+	__RETURN__((void *)(uintptr_t)count);
+	}
+#endif
+	count =(int)(uintptr_t)(liblock_execute_operation(env, pdbp->mutex, (void *)(uintptr_t)(&instance130),
+				  &function131));
+	}
 
 	return (count);
 }
@@ -3404,8 +3720,10 @@ __db_buildpartial(dbp, oldrec, partial,
 	nbytes = __db_partsize(oldrec->size, partial);
 	newrec->size = nbytes;
 
-	if ((ret = __os_malloc(env, nbytes, &buf)) != 0)
-		return (ret);
+	if ((ret = __os_malloc(env, nbytes, &buf)) != 0) {
+		
+			return (ret);
+		}
 	newrec->data = buf;
 
 	/* Nul or pad out the buffer, for any part that isn't specified. */
@@ -3460,7 +3778,9 @@ __db_partsize(nbytes, data)
 	 * plus the bytes we are adding (size).
 	 */
 	if (nbytes < data->doff + data->dlen)		/* Case 1 */
+		{
 		return (data->doff + data->size);
+		}
 
 	return (nbytes + data->size - data->dlen);	/* Case 2 */
 }
diff -u -p a/db-5.2.28.NC/src/db/db_method.c b/db-5.2.28.NC/src/db/db_method.c
--- a/db-5.2.28.NC/src/db/db_method.c
+++ b/db-5.2.28.NC/src/db/db_method.c
@@ -123,7 +123,7 @@ db_create(dbpp, dbenv, flags)
 	 * If we are opening an XA database, make sure we don't have a global XA
 	 * transaction running.
 	 */
-	if (LF_ISSET(DB_XA_CREATE)) {
+	if (((flags) & (DB_XA_CREATE))) {
 		XA_NO_TXN(ip, ret);
 		if (ret != 0)
 			goto err;
@@ -343,11 +343,11 @@ __dbh_am_chk(dbp, flags)
 	 * application calls the methods the options become restricted.  The
 	 * idea is to quit as soon as an illegal method combination is called.
 	 */
-	if ((LF_ISSET(DB_OK_BTREE) && FLD_ISSET(dbp->am_ok, DB_OK_BTREE)) ||
-	    (LF_ISSET(DB_OK_HASH) && FLD_ISSET(dbp->am_ok, DB_OK_HASH)) ||
-	    (LF_ISSET(DB_OK_HEAP) && FLD_ISSET(dbp->am_ok, DB_OK_HEAP)) ||
-	    (LF_ISSET(DB_OK_QUEUE) && FLD_ISSET(dbp->am_ok, DB_OK_QUEUE)) ||
-	    (LF_ISSET(DB_OK_RECNO) && FLD_ISSET(dbp->am_ok, DB_OK_RECNO))) {
+	if ((((flags) & (DB_OK_BTREE)) && FLD_ISSET(dbp->am_ok, DB_OK_BTREE)) ||
+	    (((flags) & (DB_OK_HASH)) && FLD_ISSET(dbp->am_ok, DB_OK_HASH)) ||
+	    (((flags) & (DB_OK_HEAP)) && FLD_ISSET(dbp->am_ok, DB_OK_HEAP)) ||
+	    (((flags) & (DB_OK_QUEUE)) && FLD_ISSET(dbp->am_ok, DB_OK_QUEUE)) ||
+	    (((flags) & (DB_OK_RECNO)) && FLD_ISSET(dbp->am_ok, DB_OK_RECNO))) {
 		FLD_CLR(dbp->am_ok, ~flags);
 		return (0);
 	}
@@ -840,7 +840,7 @@ __db_get_flags(dbp, flagsp)
 #endif
 		DB_ASSERT(dbp->env, f == 0);
 		if (F_ISSET(dbp, mapped_flag) == mapped_flag)
-			LF_SET(db_flags[i]);
+			((flags) |= (db_flags[i]));
 	}
 
 	*flagsp = flags;
@@ -863,12 +863,12 @@ __db_set_flags(dbp, flags)
 
 	env = dbp->env;
 
-	if (LF_ISSET(DB_ENCRYPT) && !CRYPTO_ON(env)) {
+	if (((flags) & (DB_ENCRYPT)) && !CRYPTO_ON(env)) {
 		__db_errx(env, DB_STR("0508",
 		    "Database environment not configured for encryption"));
 		return (EINVAL);
 	}
-	if (LF_ISSET(DB_TXN_NOT_DURABLE))
+	if (((flags) & (DB_TXN_NOT_DURABLE)))
 		ENV_REQUIRES_CONFIG(env,
 		    env->tx_handle, "DB_NOT_DURABLE", DB_INIT_TXN);
 
diff -u -p a/db-5.2.28.NC/src/db/partition.c b/db-5.2.28.NC/src/db/partition.c
--- a/db-5.2.28.NC/src/db/partition.c
+++ b/db-5.2.28.NC/src/db/partition.c
@@ -108,9 +108,9 @@ __partition_init(dbp, flags)
 	int ret;
 
 	if ((part = dbp->p_internal) != NULL) {
-		if ((LF_ISSET(DBMETA_PART_RANGE) &&
+		if ((((flags) & (DBMETA_PART_RANGE)) &&
 		    F_ISSET(part, PART_CALLBACK)) ||
-		    (LF_ISSET(DBMETA_PART_CALLBACK) &&
+		    (((flags) & (DBMETA_PART_CALLBACK)) &&
 		    F_ISSET(part, PART_RANGE))) {
 			__db_errx(dbp->env, DB_STR("0645",
 			    "Cannot specify callback and range keys."));
@@ -119,9 +119,9 @@ __partition_init(dbp, flags)
 	} else if ((ret = __os_calloc(dbp->env, 1, sizeof(*part), &part)) != 0)
 		return (ret);
 
-	if (LF_ISSET(DBMETA_PART_RANGE))
+	if (((flags) & (DBMETA_PART_RANGE)))
 		F_SET(part, PART_RANGE);
-	if (LF_ISSET(DBMETA_PART_CALLBACK))
+	if (((flags) & (DBMETA_PART_CALLBACK)))
 		F_SET(part, PART_CALLBACK);
 	dbp->p_internal = part;
 	/* Set up AM-specific methods that do not require an open. */
@@ -437,7 +437,7 @@ __partition_chk_meta(dbp, ip, txn, flags
 
 	if (FLD_ISSET(meta->metaflags, DBMETA_PART_CALLBACK) &&
 	     part->callback == NULL && !IS_RECOVERING(env) &&
-	     !F_ISSET(dbp, DB_AM_RECOVER) && !LF_ISSET(DB_RDWRMASTER)) {
+	     !F_ISSET(dbp, DB_AM_RECOVER) && !((flags) & (DB_RDWRMASTER))) {
 		__db_errx(env, DB_STR("0653",
 		    "Partition callback not specified."));
 		ret = EINVAL;
@@ -452,7 +452,7 @@ __partition_chk_meta(dbp, ip, txn, flags
 	}
 
 	if (part->nparts == 0) {
-		if (LF_ISSET(DB_CREATE) && meta->nparts == 0) {
+		if (((flags) & (DB_CREATE)) && meta->nparts == 0) {
 			__db_errx(env, DB_STR("0655",
 			    "Zero paritions specified."));
 			ret = EINVAL;
@@ -557,8 +557,8 @@ __partition_setup_keys(dbc, part, meta,
 			ret = 0;
 			goto done;
 		}
-		if (!LF_ISSET(DB_CREATE) && !F_ISSET(dbp, DB_AM_RECOVER) &&
-		    !LF_ISSET(DB_RDWRMASTER)) {
+		if (!((flags) & (DB_CREATE)) && !F_ISSET(dbp, DB_AM_RECOVER) &&
+		    !((flags) & (DB_RDWRMASTER))) {
 			__db_errx(env, DB_STR("0659", "No range keys found."));
 			ret = EINVAL;
 			goto err;
@@ -579,7 +579,7 @@ __partition_setup_keys(dbc, part, meta,
 		have_keys = 1;
 	}
 
-	if (LF_ISSET(DB_CREATE) && have_keys == 0) {
+	if (((flags) & (DB_CREATE)) && have_keys == 0) {
 		/* Insert the keys into the master database. */
 		for (i = 0; i < part->nparts - 1; i++) {
 			if ((ret = __db_put(dbp, dbc->thread_info,
@@ -839,8 +839,8 @@ __partc_get_pp(dbc, key, data, flags)
 	dbp = dbc->dbp;
 	env = dbp->env;
 
-	ignore_lease = LF_ISSET(DB_IGNORE_LEASE) ? 1 : 0;
-	LF_CLR(DB_IGNORE_LEASE);
+	ignore_lease = ((flags) & (DB_IGNORE_LEASE)) ? 1 : 0;
+	((flags) &= ~(DB_IGNORE_LEASE));
 	if ((ret = __dbc_get_arg(dbc, key, data, flags)) != 0)
 		return (ret);
 
@@ -1842,9 +1842,9 @@ __part_verify(dbp, vdp, fname, handle, c
 		goto err;
 	part = dbp->p_internal;
 
-	if (LF_ISSET(DB_SALVAGE)) {
+	if (((flags) & (DB_SALVAGE))) {
 		/* If we are being aggressive we don't want to dump the keys. */
-		if (LF_ISSET(DB_AGGRESSIVE))
+		if (((flags) & (DB_AGGRESSIVE)))
 			dbp->p_internal = NULL;
 		ret = __db_prheader(dbp,
 		    NULL, 0, 0, handle, callback, vdp, PGNO_BASE_MD);
diff -u -p a/db-5.2.28.NC/src/db/db_compact.c b/db-5.2.28.NC/src/db/db_compact.c
--- a/db-5.2.28.NC/src/db/db_compact.c
+++ b/db-5.2.28.NC/src/db/db_compact.c
@@ -107,13 +107,13 @@ __db_compact_int(dbp, ip, txn, start, st
 
 	if (IS_DB_AUTO_COMMIT(dbp, txn)) {
 		txn_local = 1;
-		LF_SET(DB_AUTO_COMMIT);
+		((flags) |= (DB_AUTO_COMMIT));
 	} else
 		txn_local = 0;
-	if (!LF_ISSET(DB_FREE_SPACE | DB_FREELIST_ONLY))
+	if (!((flags) & (DB_FREE_SPACE | DB_FREELIST_ONLY)))
 		goto no_free;
-	if (LF_ISSET(DB_FREELIST_ONLY))
-		LF_SET(DB_FREE_SPACE);
+	if (((flags) & (DB_FREELIST_ONLY)))
+		((flags) |= (DB_FREE_SPACE));
 
 #ifdef HAVE_FTRUNCATE
 	/* Sort the freelist and set up the in-memory list representation. */
@@ -122,14 +122,14 @@ __db_compact_int(dbp, ip, txn, start, st
 
 	if ((ret = __db_free_truncate(dbp, ip,
 	     txn, flags, c_data, &list, &nelems, &last_pgno)) != 0) {
-		LF_CLR(DB_FREE_SPACE);
+		((flags) &= ~(DB_FREE_SPACE));
 		goto terr;
 	}
 
 	/* If the freelist is empty and we are not filling, get out. */
-	if (nelems == 0 && LF_ISSET(DB_FREELIST_ONLY)) {
+	if (nelems == 0 && ((flags) & (DB_FREELIST_ONLY))) {
 		ret = 0;
-		LF_CLR(DB_FREE_SPACE);
+		((flags) &= ~(DB_FREE_SPACE));
 		goto terr;
 	}
 	if ((ret = __db_setup_freelist(dbp, list, nelems)) != 0) {
@@ -151,7 +151,7 @@ terr:	if (txn_local) {
 
 	/* Save the number truncated so far, we will add what we get below. */
 	truncated = c_data->compact_pages_truncated;
-	if (LF_ISSET(DB_FREELIST_ONLY))
+	if (((flags) & (DB_FREELIST_ONLY)))
 		goto done;
 #endif
 
@@ -259,13 +259,13 @@ err:		if (txn_local && txn != NULL) {
 	 * Then calculate how many pages we have truncated and release
 	 * the in-memory free list.
 	 */
-done:	if (LF_ISSET(DB_FREE_SPACE)) {
+done:	if (((flags) & (DB_FREE_SPACE))) {
 		DBMETA *meta;
 		db_pgno_t pgno;
 
 		pgno = PGNO_BASE_MD;
 		isdone = 1;
-		if (ret == 0 && !LF_ISSET(DB_FREELIST_ONLY) &&
+		if (ret == 0 && !((flags) & (DB_FREELIST_ONLY)) &&
 		    __memp_fget(dbp->mpf, &pgno, ip, txn, 0, &meta) == 0) {
 			isdone = meta->free == PGNO_INVALID;
 			ret = __memp_fput(dbp->mpf, ip, meta, dbp->priority);
@@ -525,7 +525,7 @@ __db_exchange_page(dbc, pgp, opg, newpgn
 	 * For HASH we may reuse the old page for an even higher numbered
 	 * page.  Otherwise we free the old page.
 	 */
-	if (!LF_ISSET(DB_EXCH_FREE)) {
+	if (!((flags) & (DB_EXCH_FREE))) {
 		NEXT_PGNO(*pgp) = PREV_PGNO(*pgp) = PGNO_INVALID;
 		ret = __memp_fput(dbp->mpf,
 		    dbc->thread_info, *pgp, dbc->priority);
@@ -536,7 +536,7 @@ __db_exchange_page(dbc, pgp, opg, newpgn
 	if (ret != 0)
 		return (ret);
 
-	if (!LF_ISSET(DB_EXCH_PARENT))
+	if (!((flags) & (DB_EXCH_PARENT)))
 		goto done;
 
 	/* Update the parent. */
diff -u -p a/db-5.2.28.NC/src/db/db_stati.c b/db-5.2.28.NC/src/db/db_stati.c
--- a/db-5.2.28.NC/src/db/db_stati.c
+++ b/db-5.2.28.NC/src/db/db_stati.c
@@ -47,8 +47,10 @@ __db_stat_pp(dbp, txn, spp, flags)
 
 	DB_ILLEGAL_BEFORE_OPEN(dbp, "DB->stat");
 
-	if ((ret = __db_stat_arg(dbp, flags)) != 0)
-		return (ret);
+	if ((ret = __db_stat_arg(dbp, flags)) != 0) {
+		
+			return (ret);
+		}
 
 	ENV_ENTER(env, ip);
 
@@ -91,11 +93,13 @@ __db_stat(dbp, ip, txn, spp, flags)
 
 	/* Acquire a cursor. */
 	if ((ret = __db_cursor(dbp, ip, txn,
-	     &dbc, LF_ISSET(DB_READ_COMMITTED | DB_READ_UNCOMMITTED))) != 0)
-		return (ret);
+	     &dbc, ((flags) & (DB_READ_COMMITTED | DB_READ_UNCOMMITTED)))) != 0) {
+		
+			return (ret);
+		}
 
 	DEBUG_LWRITE(dbc, NULL, "DB->stat", NULL, NULL, flags);
-	LF_CLR(DB_READ_COMMITTED | DB_READ_UNCOMMITTED);
+	((flags) &= ~(DB_READ_COMMITTED | DB_READ_UNCOMMITTED));
 #ifdef HAVE_PARTITION
 	if (DB_IS_PARTITIONED(dbp))
 		ret = __partition_stat(dbc, spp, flags);
@@ -141,7 +145,7 @@ __db_stat_arg(dbp, flags)
 	env = dbp->env;
 
 	/* Check for invalid function flags. */
-	LF_CLR(DB_READ_COMMITTED | DB_READ_UNCOMMITTED);
+	((flags) &= ~(DB_READ_COMMITTED | DB_READ_UNCOMMITTED));
 	switch (flags) {
 	case 0:
 	case DB_FAST_STAT:
@@ -177,8 +181,10 @@ __db_stat_print_pp(dbp, flags)
 	 * The actual argument checking is simple, do it inline.
 	 */
 	if ((ret = __db_fchk(env,
-	    "DB->stat_print", flags, DB_FAST_STAT | DB_STAT_ALL)) != 0)
-		return (ret);
+	    "DB->stat_print", flags, DB_FAST_STAT | DB_STAT_ALL)) != 0) {
+		
+			return (ret);
+		}
 
 	ENV_ENTER(env, ip);
 
@@ -218,11 +224,15 @@ __db_stat_print(dbp, ip, flags)
 	(void)time(&now);
 	__db_msg(dbp->env, "%.24s\tLocal time", __os_ctime(&now, time_buf));
 
-	if (LF_ISSET(DB_STAT_ALL) && (ret = __db_print_all(dbp, flags)) != 0)
-		return (ret);
-
-	if ((ret = __db_print_stats(dbp, ip, flags)) != 0)
-		return (ret);
+	if (((flags) & (DB_STAT_ALL)) && (ret = __db_print_all(dbp, flags)) != 0) {
+		
+			return (ret);
+		}
+
+	if ((ret = __db_print_stats(dbp, ip, flags)) != 0) {
+		
+			return (ret);
+		}
 
 	return (0);
 }
@@ -244,8 +254,10 @@ __db_print_stats(dbp, ip, flags)
 	env = dbp->env;
 
 	/* Acquire a cursor. */
-	if ((ret = __db_cursor(dbp, ip, NULL, &dbc, 0)) != 0)
-		return (ret);
+	if ((ret = __db_cursor(dbp, ip, NULL, &dbc, 0)) != 0) {
+		
+			return (ret);
+		}
 
 	DEBUG_LWRITE(dbc, NULL, "DB->stat_print", NULL, NULL, 0);
 
@@ -372,6 +384,38 @@ __db_print_all(dbp, flags)
 	return (0);
 }
 
+union instance137 {struct input135{ENV *env;DBC *dbc;DB *dbp;int ret;} input135;};
+void * function138(void *ctx136);
+void *function138(void *ctx136) {
+	{
+		struct input135 *incontext133=&(((union instance137 *)ctx136)->input135);
+		int t_ret;
+		ENV *env=incontext133->env;
+		DBC *dbc=incontext133->dbc;
+		DB *dbp=incontext133->dbp;
+		int ret=incontext133->ret;
+		ret = ret;
+		{
+			__db_msg(env, "Active queue:");
+			TAILQ_FOREACH (dbc,&dbp->active_queue,links)
+				if ((t_ret = __db_print_citem(dbc)) != 0 && ret == 0)
+					ret = t_ret;
+			dbc = dbc;
+			__db_msg(env, "Join queue:");
+			TAILQ_FOREACH (dbc,&dbp->join_queue,links)
+				if ((t_ret = __db_print_citem(dbc)) != 0 && ret == 0)
+					ret = t_ret;
+			dbc = dbc;
+			__db_msg(env, "Free queue:");
+			TAILQ_FOREACH (dbc,&dbp->free_queue,links)
+				if ((t_ret = __db_print_citem(dbc)) != 0 && ret == 0)
+					ret = t_ret;
+			dbc = dbc;
+		}
+		return (void *)(uintptr_t)ret;
+	}
+}
+
 /*
  * __db_print_cursor --
  *	Display the cursor active and free queues.
@@ -390,20 +434,45 @@ __db_print_cursor(dbp)
 	__db_msg(env, "DB handle cursors:");
 
 	ret = 0;
-	MUTEX_LOCK(dbp->env, dbp->mutex);
+	{ union instance137 instance137 = {
+		{
+			env,
+			dbc,
+			dbp,
+			ret,
+		},
+	};
+	#if 0
+{
+	struct input135 *incontext133 = &(((union instance137 *)ctx136)->input135);
+	int t_ret;
+	ENV *env = incontext133->env;
+	DBC *dbc = incontext133->dbc;
+	DB *dbp = incontext133->dbp;
+	int ret = incontext133->ret;
+	ret = ret;{
 	__db_msg(env, "Active queue:");
 	TAILQ_FOREACH(dbc, &dbp->active_queue, links)
 		if ((t_ret = __db_print_citem(dbc)) != 0 && ret == 0)
 			ret = t_ret;
+			dbc = dbc;
 	__db_msg(env, "Join queue:");
 	TAILQ_FOREACH(dbc, &dbp->join_queue, links)
 		if ((t_ret = __db_print_citem(dbc)) != 0 && ret == 0)
 			ret = t_ret;
+			dbc = dbc;
 	__db_msg(env, "Free queue:");
 	TAILQ_FOREACH(dbc, &dbp->free_queue, links)
 		if ((t_ret = __db_print_citem(dbc)) != 0 && ret == 0)
 			ret = t_ret;
-	MUTEX_UNLOCK(dbp->env, dbp->mutex);
+			dbc = dbc;
+	}
+	__RETURN__((void *)(uintptr_t)ret);
+	}
+#endif
+	ret =(int)(uintptr_t)(liblock_execute_operation(dbp->env, dbp->mutex, (void *)(uintptr_t)(&instance137),
+				  &function138));
+	}
 
 	return (ret);
 }
diff -u -p a/db-5.2.28.NC/src/db/db_setlsn.c b/db-5.2.28.NC/src/db/db_setlsn.c
--- a/db-5.2.28.NC/src/db/db_setlsn.c
+++ b/db-5.2.28.NC/src/db/db_setlsn.c
@@ -47,7 +47,7 @@ __env_lsn_reset_pp(dbenv, name, flags)
 
 	ENV_ENTER(env, ip);
 	REPLICATION_WRAP(env,
-	    (__env_lsn_reset(env, ip, name, LF_ISSET(DB_ENCRYPT) ? 1 : 0)),
+	    (__env_lsn_reset(env, ip, name, ((flags) & (DB_ENCRYPT)) ? 1 : 0)),
 	    1, ret);
 	ENV_LEAVE(env, ip);
 	return (ret);
diff -u -p a/db-5.2.28.NC/src/db/db_join.c b/db-5.2.28.NC/src/db/db_join.c
--- a/db-5.2.28.NC/src/db/db_join.c
+++ b/db-5.2.28.NC/src/db/db_join.c
@@ -30,6 +30,20 @@ static int __db_join_put __P((DBC *, DBT
  */
 #define	SORTED_SET(jc, n)   ((jc)->j_curslist[(n)]->dbp->dup_compare != NULL)
 
+union instance144 {struct input142{DBC *dbc;DB *primary;} input142;};
+void * function145(void *ctx143);
+void *function145(void *ctx143) {
+	{
+		struct input142 *incontext140=&(((union instance144 *)ctx143)->input142);
+		DBC *dbc=incontext140->dbc;
+		DB *primary=incontext140->primary;
+		{
+			TAILQ_INSERT_TAIL(&primary->join_queue, dbc, links);
+		}
+		return NULL;
+	}
+}
+
 /*
  * This is the duplicate-assisted join functionality.  Right now we're
  * going to write it such that we return one item at a time, although
@@ -178,7 +192,7 @@ __db_join(primary, curslist, dbcp, flags
 	 * If DB_JOIN_NOSORT is not set, optimize secondary cursors by
 	 * sorting in order of increasing cardinality.
 	 */
-	if (!LF_ISSET(DB_JOIN_NOSORT))
+	if (!((flags) & (DB_JOIN_NOSORT)))
 		qsort(jc->j_curslist, ncurs, sizeof(DBC *), __db_join_cmp);
 
 	/*
@@ -209,9 +223,23 @@ __db_join(primary, curslist, dbcp, flags
 
 	*dbcp = dbc;
 
-	MUTEX_LOCK(env, primary->mutex);
+	{ union instance144 instance144 = {
+		{
+			dbc,
+			primary,
+		},
+	};
+	#if 0
+{
+	struct input142 *incontext140 = &(((union instance144 *)ctx143)->input142);
+	DBC *dbc = incontext140->dbc;
+	DB *primary = incontext140->primary;{
 	TAILQ_INSERT_TAIL(&primary->join_queue, dbc, links);
-	MUTEX_UNLOCK(env, primary->mutex);
+	}__RETURN__(NULL);
+	}
+#endif
+	liblock_execute_operation(env, primary->mutex, (void *)(uintptr_t)(&instance144),
+				  &function145); }
 
 	return (0);
 
@@ -314,10 +342,12 @@ __db_join_get_pp(dbc, key, data, flags)
 	/* Save the original flags value. */
 	save_flags = flags;
 
-	if (LF_ISSET(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW)) {
-		if (!LOCKING_ON(env))
-			return (__db_fnl(env, "DBC->get"));
-		LF_CLR(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW);
+	if (((flags) & (DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW))) {
+		if (!LOCKING_ON(env)) {
+			
+				return (__db_fnl(env, "DBC->get"));
+			}
+		((flags) &= ~(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW));
 	}
 
 	switch (flags) {
@@ -385,13 +415,13 @@ __db_join_get(dbc, key_arg, data_arg, fl
 	env = dbp->env;
 	jc = (JOIN_CURSOR *)dbc->internal;
 
-	operation = LF_ISSET(DB_OPFLAGS_MASK);
+	operation = ((flags) & (DB_OPFLAGS_MASK));
 
 	/* !!!
 	 * If the set of flags here changes, check that __db_join_primget
 	 * is updated to handle them properly.
 	 */
-	opmods = LF_ISSET(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW);
+	opmods = ((flags) & (DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW));
 
 	/*
 	 * Since we are fetching the key as a datum in the secondary indices,
@@ -614,8 +644,10 @@ mem_err:			__db_errx(env, DB_STR_A("0517
 			goto err;
 	}
 
-err:	if (ret != 0)
-		return (ret);
+err:	if (ret != 0) {
+		
+			return (ret);
+		}
 
 	if (0) {
 samekey:	/*
@@ -623,8 +655,10 @@ samekey:	/*
 		 * it should be the current datum of all the secondary cursors.
 		 */
 		if ((ret = __dbc_get(jc->j_workcurs[0],
-		    &jc->j_key, key_n, DB_CURRENT | opmods)) != 0)
-			return (ret);
+		    &jc->j_key, key_n, DB_CURRENT | opmods)) != 0) {
+			
+				return (ret);
+			}
 		F_CLR(jc, JOIN_RETRY);
 	}
 
@@ -655,8 +689,10 @@ samekey:	/*
 	 * If DB_JOIN_ITEM is set, we return it; otherwise we do the lookup
 	 * in the primary and then return.
 	 */
-	if (operation == DB_JOIN_ITEM)
-		return (0);
+	if (operation == DB_JOIN_ITEM) {
+		
+			return (0);
+		}
 
 	/*
 	 * If data_arg->flags == 0--that is, if DB is managing the
@@ -677,7 +713,7 @@ samekey:	/*
 	    jc->j_curslist[0]->txn, jc->j_curslist[0]->locker, key_n,
 	    db_manage_data ? &jc->j_rdata : data_arg, opmods)) != 0) {
 		if (ret == DB_NOTFOUND) {
-			if (LF_ISSET(DB_READ_UNCOMMITTED) ||
+			if (((flags) & (DB_READ_UNCOMMITTED)) ||
 			    (jc->j_curslist[0]->txn != NULL && F_ISSET(
 			    jc->j_curslist[0]->txn, TXN_READ_UNCOMMITTED)))
 				goto retry;
@@ -706,6 +742,20 @@ samekey:	/*
 	return (ret);
 }
 
+union instance151 {struct input149{DBC *dbc;DB *dbp;} input149;};
+void * function152(void *ctx150);
+void *function152(void *ctx150) {
+	{
+		struct input149 *incontext147=&(((union instance151 *)ctx150)->input149);
+		DBC *dbc=incontext147->dbc;
+		DB *dbp=incontext147->dbp;
+		{
+			TAILQ_REMOVE(&dbp->join_queue, dbc, links);
+		}
+		return NULL;
+	}
+}
+
 /*
  * __db_join_close --
  *	DBC->close for join cursors.
@@ -733,9 +783,23 @@ __db_join_close(dbc)
 	 * must happen before any action that can fail and return, or else
 	 * __db_close may loop indefinitely.
 	 */
-	MUTEX_LOCK(env, dbp->mutex);
+	{ union instance151 instance151 = {
+		{
+			dbc,
+			dbp,
+		},
+	};
+	#if 0
+{
+	struct input149 *incontext147 = &(((union instance151 *)ctx150)->input149);
+	DBC *dbc = incontext147->dbc;
+	DB *dbp = incontext147->dbp;{
 	TAILQ_REMOVE(&dbp->join_queue, dbc, links);
-	MUTEX_UNLOCK(env, dbp->mutex);
+	}__RETURN__(NULL);
+	}
+#endif
+	liblock_execute_operation(env, dbp->mutex, (void *)(uintptr_t)(&instance151),
+				  &function152); }
 
 	ENV_ENTER(env, ip);
 	/*
@@ -820,8 +884,10 @@ __db_join_getnext(dbc, key, data, exhaus
 			 * above.
 			 */
 			if ((ret = __db_retcopy(dbp->env, data, ldata.data,
-			    ldata.size, &data->data, &data->size)) != 0)
-				return (ret);
+			    ldata.size, &data->data, &data->size)) != 0) {
+				
+					return (ret);
+				}
 			__os_ufree(dbp->env, ldata.data);
 			return (0);
 		}
@@ -859,8 +925,10 @@ __db_join_cmp(a, b)
 	dbcb = *((DBC * const *)b);
 
 	if (__dbc_count(dbca, &counta) != 0 ||
-	    __dbc_count(dbcb, &countb) != 0)
-		return (0);
+	    __dbc_count(dbcb, &countb) != 0) {
+		
+			return (0);
+		}
 
 	return ((long)counta - (long)countb);
 }
@@ -884,8 +952,10 @@ __db_join_primget(dbp, ip, txn, locker,
 	int ret, t_ret;
 
 	if ((ret = __db_cursor_int(dbp, ip,
-	    txn, dbp->type, PGNO_INVALID, 0, locker, &dbc)) != 0)
-		return (ret);
+	    txn, dbp->type, PGNO_INVALID, 0, locker, &dbc)) != 0) {
+		
+			return (ret);
+		}
 
 	/*
 	 * The only allowable flags here are the two flags copied into "opmods"
@@ -893,16 +963,16 @@ __db_join_primget(dbp, ip, txn, locker,
 	 * op on the c_get call, the latter on the cursor call.  It's a DB bug
 	 * if we allow any other flags down in here.
 	 */
-	rmw = LF_ISSET(DB_RMW);
-	if (LF_ISSET(DB_READ_UNCOMMITTED) ||
+	rmw = ((flags) & (DB_RMW));
+	if (((flags) & (DB_READ_UNCOMMITTED)) ||
 	    (txn != NULL && F_ISSET(txn, TXN_READ_UNCOMMITTED)))
 		F_SET(dbc, DBC_READ_UNCOMMITTED);
 
-	if (LF_ISSET(DB_READ_COMMITTED) ||
+	if (((flags) & (DB_READ_COMMITTED)) ||
 	    (txn != NULL && F_ISSET(txn, TXN_READ_COMMITTED)))
 		F_SET(dbc, DBC_READ_COMMITTED);
 
-	LF_CLR(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW);
+	((flags) &= ~(DB_READ_COMMITTED | DB_READ_UNCOMMITTED | DB_RMW));
 	DB_ASSERT(dbp->env, flags == 0);
 
 	F_SET(dbc, DBC_TRANSIENT);
diff -u -p a/db-5.2.28.NC/src/db/db_ovfl_vrfy.c b/db-5.2.28.NC/src/db/db_ovfl_vrfy.c
--- a/db-5.2.28.NC/src/db/db_ovfl_vrfy.c
+++ b/db-5.2.28.NC/src/db/db_ovfl_vrfy.c
@@ -200,7 +200,7 @@ __db_vrfy_ovfl_structure(dbp, vdp, pgno,
 		 * overflow chains used as Btree duplicate keys may be
 		 * referenced multiply from a single Btree leaf page.
 		 */
-		if (LF_ISSET(DB_ST_OVFL_LEAF)) {
+		if (((flags) & (DB_ST_OVFL_LEAF))) {
 			if (F_ISSET(pip, VRFY_OVFL_LEAFSEEN)) {
 				EPRINT((env, DB_STR_A("0680",
 		"Page %lu: overflow page linked twice from leaf or data page",
@@ -229,7 +229,7 @@ __db_vrfy_ovfl_structure(dbp, vdp, pgno,
 			tlen -= pip->olen;
 
 			/* Send the application feedback about our progress. */
-			if (!LF_ISSET(DB_SALVAGE))
+			if (!((flags) & (DB_SALVAGE)))
 				__db_vrfy_struct_feedback(dbp, vdp);
 		} else
 			goto done;
@@ -358,7 +358,7 @@ __db_safe_goff(dbp, vdp, pgno, dbt, buf,
 		 * Make sure it's really an overflow page, unless we're
 		 * being aggressive, in which case we pretend it is.
 		 */
-		if (!LF_ISSET(DB_AGGRESSIVE) && TYPE(h) != P_OVERFLOW) {
+		if (!((flags) & (DB_AGGRESSIVE)) && TYPE(h) != P_OVERFLOW) {
 			ret = DB_VERIFY_BAD;
 			break;
 		}
@@ -396,7 +396,7 @@ __db_safe_goff(dbp, vdp, pgno, dbt, buf,
 	 * If we're being aggressive, salvage a partial datum if there
 	 * was an error somewhere along the way.
 	 */
-	if (ret == 0 || LF_ISSET(DB_AGGRESSIVE)) {
+	if (ret == 0 || ((flags) & (DB_AGGRESSIVE))) {
 		dbt->size = bytesgot;
 		dbt->data = *(void **)buf;
 	}
diff -u -p a/db-5.2.28.NC/src/lock/lock.c b/db-5.2.28.NC/src/lock/lock.c
--- a/db-5.2.28.NC/src/lock/lock.c
+++ b/db-5.2.28.NC/src/lock/lock.c
@@ -130,7 +130,7 @@ __lock_vec(env, sh_locker, flags, list,
 	for (i = 0, ret = 0; i < nlist && ret == 0; i++)
 		switch (list[i].op) {
 		case DB_LOCK_GET_TIMEOUT:
-			LF_SET(DB_LOCK_SET_TIMEOUT);
+			((flags) |= (DB_LOCK_SET_TIMEOUT));
 			/* FALLTHROUGH */
 		case DB_LOCK_GET:
 			if (IS_RECOVERING(env)) {
@@ -540,7 +540,7 @@ __lock_get_internal(lt, sh_locker, flags
 		return (EINVAL);
 	}
 
-	DB_ASSERT(env, lock_mode == DB_LOCK_WAIT || !LF_ISSET(DB_LOCK_SWITCH));
+	DB_ASSERT(env, lock_mode == DB_LOCK_WAIT || !((flags) & (DB_LOCK_SWITCH)));
 
 	no_dd = ret = 0;
 	newl = NULL;
@@ -566,14 +566,14 @@ again:	if (obj == NULL) {
 		OBJECT_LOCK(lt, region, obj, lock->ndx);
 		ndx = lock->ndx;
 		if ((ret = __lock_getobj(lt,
-		    obj, lock->ndx, !LF_ISSET(DB_LOCK_CHECK), &sh_obj)) != 0)
+		    obj, lock->ndx, !((flags) & (DB_LOCK_CHECK)), &sh_obj)) != 0)
 			goto err;
 #ifdef DIAGNOSTIC
 		if (sh_obj == NULL) {
 			ret = ENOENT;
 			goto err;
 		}
-		if (LF_ISSET(DB_LOCK_UPGRADE)) {
+		if (((flags) & (DB_LOCK_UPGRADE))) {
 			DB_ASSERT(env, LOCK_ISSET(*lock));
 			lp = R_ADDR(&lt->reginfo, lock->off);
 			DB_ASSERT(env, lock->gen == lp->gen);
@@ -584,11 +584,11 @@ again:	if (obj == NULL) {
 	}
 
 #ifdef HAVE_STATISTICS
-	if (LF_ISSET(DB_LOCK_UPGRADE))
+	if (((flags) & (DB_LOCK_UPGRADE)))
 		STAT_INC_VERB(env, lock, upgrade,
 		    lt->obj_stat[ndx].st_nupgrade,
 		    (DBT *) obj, sh_locker->id);
-	else if (!LF_ISSET(DB_LOCK_SWITCH | DB_LOCK_CHECK))
+	else if (!((flags) & (DB_LOCK_SWITCH | DB_LOCK_CHECK)))
 		STAT_INC_VERB(env, lock, request,
 		    lt->obj_stat[ndx].st_nrequests,
 		    (DBT *) obj, sh_locker->id);
@@ -641,11 +641,11 @@ again:	if (obj == NULL) {
 		if (sh_off == lp->holder) {
 			if (lp->mode == lock_mode &&
 			    lp->status == DB_LSTAT_HELD) {
-				if (LF_ISSET(DB_LOCK_UPGRADE))
+				if (((flags) & (DB_LOCK_UPGRADE)))
 					goto upgrade;
 
 #ifdef DIAGNOSTIC
-				if (LF_ISSET(DB_LOCK_CHECK))
+				if (((flags) & (DB_LOCK_CHECK)))
 					goto done;
 #endif
 
@@ -677,7 +677,7 @@ again:	if (obj == NULL) {
 	}
 
 #ifdef DIAGNOSTIC
-	if (LF_ISSET(DB_LOCK_CHECK)) {
+	if (((flags) & (DB_LOCK_CHECK))) {
 		ret = ENOENT;
 		goto err;
 	}
@@ -690,13 +690,13 @@ again:	if (obj == NULL) {
 	 * else to the back.
 	 */
 	if (lp != NULL) {
-		if (ihold || LF_ISSET(DB_LOCK_UPGRADE) ||
+		if (ihold || ((flags) & (DB_LOCK_UPGRADE)) ||
 		    lock_mode == DB_LOCK_READ_UNCOMMITTED)
 			action = HEAD;
 		else
 			action = TAIL;
 	} else {
-		if (LF_ISSET(DB_LOCK_UPGRADE))
+		if (((flags) & (DB_LOCK_UPGRADE)))
 			action = UPGRADE;
 		else if (lock_mode == DB_LOCK_WAIT)
 			action = TAIL;
@@ -766,7 +766,7 @@ again:	if (obj == NULL) {
 	case HEAD:
 	case TAIL:
 	case SECOND:
-		if (LF_ISSET(DB_LOCK_NOWAIT) && lock_mode != DB_LOCK_WAIT) {
+		if (((flags) & (DB_LOCK_NOWAIT)) && lock_mode != DB_LOCK_WAIT) {
 			ret = DB_LOCK_NOTGRANTED;
 			STAT_INC_VERB(env, lock, nowait_notgranted,
 			    region->stat.st_lock_nowait,
@@ -911,7 +911,7 @@ upgrade:	lp = R_ADDR(&lt->reginfo, lock-
 		 * for this transaction then use that, otherwise use
 		 * the global timeout value.
 		 */
-		if (!LF_ISSET(DB_LOCK_SET_TIMEOUT)) {
+		if (!((flags) & (DB_LOCK_SET_TIMEOUT))) {
 			if (F_ISSET(sh_locker, DB_LOCKER_TIMEOUT))
 				timeout = sh_locker->lk_timeout;
 			else
@@ -923,7 +923,7 @@ upgrade:	lp = R_ADDR(&lt->reginfo, lock-
 		 * That way we can unpin the metadata page first and then
 		 * block.
 		 */
-		if (lock_mode == DB_LOCK_WAIT && LF_ISSET(DB_LOCK_NOWAIT)) {
+		if (lock_mode == DB_LOCK_WAIT && ((flags) & (DB_LOCK_NOWAIT))) {
 			newl->mtx_lock = sh_locker->mtx_locker;
 			newl->status = DB_LSTAT_WAITING;
 			goto out;
@@ -954,7 +954,7 @@ in_abort:	newl->status = DB_LSTAT_WAITIN
 		OBJECT_UNLOCK(lt, region, sh_obj->indx);
 
 		/* If we are switching drop the lock we had. */
-		if (LF_ISSET(DB_LOCK_SWITCH) &&
+		if (((flags) & (DB_LOCK_SWITCH)) &&
 		    (ret = __lock_put_nolock(env, lock, &ihold, 0)) != 0) {
 			OBJECT_LOCK_NDX(lt, region, sh_obj->indx);
 			(void)__lock_remove_waiter(
@@ -1024,7 +1024,7 @@ expired:		ret = __lock_put_internal(lt,
 			timespecclear(&sh_locker->lk_expire);
 			goto err;
 		case DB_LSTAT_PENDING:
-			if (LF_ISSET(DB_LOCK_UPGRADE)) {
+			if (((flags) & (DB_LOCK_UPGRADE))) {
 				/*
 				 * The lock just granted got put on the holders
 				 * list.  Since we're upgrading some other lock,
@@ -1069,7 +1069,7 @@ out:	lock->off = R_OFFSET(&lt->reginfo,
 	OBJECT_UNLOCK(lt, region, ndx);
 	return (0);
 
-err:	if (!LF_ISSET(DB_LOCK_UPGRADE | DB_LOCK_SWITCH))
+err:	if (!((flags) & (DB_LOCK_UPGRADE | DB_LOCK_SWITCH)))
 		LOCK_INIT(*lock);
 
 done:	if (newl != NULL &&
@@ -1280,13 +1280,13 @@ __lock_put_internal(lt, lockp, obj_ndx,
 	}
 
 #ifdef HAVE_STATISTICS
-	if (LF_ISSET(DB_LOCK_DOALL))
+	if (((flags) & (DB_LOCK_DOALL)))
 		lt->obj_stat[obj_ndx].st_nreleases += lockp->refcount;
 	else
 		lt->obj_stat[obj_ndx].st_nreleases++;
 #endif
 
-	if (!LF_ISSET(DB_LOCK_DOALL) && lockp->refcount > 1) {
+	if (!((flags) & (DB_LOCK_DOALL)) && lockp->refcount > 1) {
 		lockp->refcount--;
 		PERFMON2(env, lock, put_reduce_count,
 		    &(SH_OFF_TO_PTR(lockp, lockp->obj, DB_LOCKOBJ))->lockobj,
@@ -1321,7 +1321,7 @@ __lock_put_internal(lt, lockp, obj_ndx,
 		lockp->links.stqe_prev = -1;
 	}
 
-	if (LF_ISSET(DB_LOCK_NOPROMOTE))
+	if (((flags) & (DB_LOCK_NOPROMOTE)))
 		state_changed = 0;
 	else if ((ret = __lock_promote(lt,
 		    sh_obj, &state_changed, flags)) != 0)
@@ -1350,7 +1350,7 @@ __lock_put_internal(lt, lockp, obj_ndx,
 	}
 
 	/* Free lock. */
-	if (LF_ISSET(DB_LOCK_UNLINK | DB_LOCK_FREE))
+	if (((flags) & (DB_LOCK_UNLINK | DB_LOCK_FREE)))
 		ret = __lock_freelock(lt, lockp,
 		     R_ADDR(&lt->reginfo, lockp->holder), flags);
 
@@ -1385,7 +1385,7 @@ __lock_freelock(lt, lockp, sh_locker, fl
 	env = lt->env;
 	region = lt->reginfo.primary;
 
-	if (LF_ISSET(DB_LOCK_UNLINK)) {
+	if (((flags) & (DB_LOCK_UNLINK))) {
 		SH_LIST_REMOVE(lockp, locker_links, __db_lock);
 		if (lockp->status == DB_LSTAT_HELD) {
 			sh_locker->nlocks--;
@@ -1394,7 +1394,7 @@ __lock_freelock(lt, lockp, sh_locker, fl
 		}
 	}
 
-	if (LF_ISSET(DB_LOCK_FREE)) {
+	if (((flags) & (DB_LOCK_FREE))) {
 		/*
 		 * If the lock is not held we cannot be sure of its mutex
 		 * state so we refresh it.
@@ -1824,7 +1824,7 @@ __lock_promote(lt, obj, state_changedp,
 		/* Wake up waiter. */
 		MUTEX_UNLOCK(lt->env, lp_w->mtx_lock);
 		state_changed = 1;
-		if (LF_ISSET(DB_LOCK_ONEWAITER))
+		if (((flags) & (DB_LOCK_ONEWAITER)))
 			break;
 	}
 
diff -u -p a/db-5.2.28.NC/src/lock/lock_stat.c b/db-5.2.28.NC/src/lock/lock_stat.c
--- a/db-5.2.28.NC/src/lock/lock_stat.c
+++ b/db-5.2.28.NC/src/lock/lock_stat.c
@@ -106,7 +106,7 @@ __lock_stat(env, statp, flags)
 			stats->st_maxhobjects = lt->obj_stat[i].st_maxnobjects;
 		if (stats->st_hash_len < lt->obj_stat[i].st_hash_len)
 			stats->st_hash_len = lt->obj_stat[i].st_hash_len;
-		if (LF_ISSET(DB_STAT_CLEAR)) {
+		if (((flags) & (DB_STAT_CLEAR))) {
 			htmp = lt->obj_stat[i];
 			memset(&lt->obj_stat[i], 0, sizeof(lt->obj_stat[i]));
 			lt->obj_stat[i].st_nlocks = htmp.st_nlocks;
@@ -145,7 +145,7 @@ __lock_stat(env, statp, flags)
 			stats->st_part_max_wait = tmp_wait;
 		}
 
-		if (LF_ISSET(DB_STAT_CLEAR)) {
+		if (((flags) & (DB_STAT_CLEAR))) {
 			ptmp = lt->part_array[i].part_stat;
 			memset(&lt->part_array[i].part_stat,
 			    0, sizeof(lt->part_array[i].part_stat));
@@ -167,10 +167,10 @@ __lock_stat(env, statp, flags)
 	__mutex_set_wait_info(env, region->mtx_lockers,
 	    &stats->st_lockers_wait, &stats->st_lockers_nowait);
 	stats->st_regsize = lt->reginfo.rp->size;
-	if (LF_ISSET(DB_STAT_CLEAR)) {
+	if (((flags) & (DB_STAT_CLEAR))) {
 		tmp = region->stat;
 		memset(&region->stat, 0, sizeof(region->stat));
-		if (!LF_ISSET(DB_STAT_SUBSYSTEM)) {
+		if (!((flags) & (DB_STAT_SUBSYSTEM))) {
 			__mutex_clear(env, region->mtx_region);
 			__mutex_clear(env, region->mtx_dd);
 			__mutex_clear(env, region->mtx_lockers);
@@ -244,15 +244,14 @@ __lock_stat_print(env, flags)
 	int ret;
 
 	orig_flags = flags;
-	LF_CLR(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM);
-	if (flags == 0 || LF_ISSET(DB_STAT_ALL)) {
+	((flags) &= ~(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM));
+	if (flags == 0 || ((flags) & (DB_STAT_ALL))) {
 		ret = __lock_print_stats(env, orig_flags);
 		if (flags == 0 || ret != 0)
 			return (ret);
 	}
 
-	if (LF_ISSET(DB_STAT_ALL | DB_STAT_LOCK_CONF | DB_STAT_LOCK_LOCKERS |
-	    DB_STAT_LOCK_OBJECTS | DB_STAT_LOCK_PARAMS) &&
+	if (((flags) & (DB_STAT_ALL | DB_STAT_LOCK_CONF | DB_STAT_LOCK_LOCKERS | DB_STAT_LOCK_OBJECTS | DB_STAT_LOCK_PARAMS)) &&
 	    (ret = __lock_print_all(env, orig_flags)) != 0)
 		return (ret);
 
@@ -322,7 +321,7 @@ __lock_print_stats(env, flags)
 	if ((ret = __lock_stat(env, &sp, flags)) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL))
+	if (((flags) & (DB_STAT_ALL)))
 		__db_msg(env, "Default locking region information:");
 	__db_dl(env, "Last allocated locker ID", (u_long)sp->st_id);
 	__db_msg(env, "%#lx\tCurrent maximum unused locker ID",
diff -u -p a/db-5.2.28.NC/src/common/db_err.c b/db-5.2.28.NC/src/common/db_err.c
--- a/db-5.2.28.NC/src/common/db_err.c
+++ b/db-5.2.28.NC/src/common/db_err.c
@@ -30,7 +30,7 @@ __db_fchk(env, name, flags, ok_flags)
 	const char *name;
 	u_int32_t flags, ok_flags;
 {
-	return (LF_ISSET(~ok_flags) ? __db_ferr(env, name, 0) : 0);
+	return (((flags) & (~ok_flags)) ? __db_ferr(env, name, 0) : 0);
 }
 
 /*
@@ -46,8 +46,8 @@ __db_fcchk(env, name, flags, flag1, flag
 	const char *name;
 	u_int32_t flags, flag1, flag2;
 {
-	return (LF_ISSET(flag1) &&
-	    LF_ISSET(flag2) ? __db_ferr(env, name, 1) : 0);
+	return (((flags) & (flag1)) &&
+	    ((flags) & (flag2)) ? __db_ferr(env, name, 1) : 0);
 }
 
 /*
diff -u -p a/db-5.2.28.NC/src/os_windows/os_open.c b/db-5.2.28.NC/src/os_windows/os_open.c
--- a/db-5.2.28.NC/src/os_windows/os_open.c
+++ b/db-5.2.28.NC/src/os_windows/os_open.c
@@ -89,7 +89,7 @@ __os_open(env, name, page_size, flags, m
 	 * only has a "readable" and "writable" flag, applying to all users.
 	 */
 	access = GENERIC_READ;
-	if (!LF_ISSET(DB_OSO_RDONLY))
+	if (!((flags) & (DB_OSO_RDONLY)))
 		access |= GENERIC_WRITE;
 
 #ifdef DB_WINCE
@@ -98,7 +98,7 @@ __os_open(env, name, page_size, flags, m
 	 * CreateFileForMapping.
 	 * Also WinCE does not support the FILE_SHARE_DELETE flag.
 	 */
-	if (LF_ISSET(DB_OSO_REGION))
+	if (((flags) & (DB_OSO_REGION)))
 		share = GENERIC_READ | GENERIC_WRITE;
 	else
 		share = FILE_SHARE_READ | FILE_SHARE_WRITE;
@@ -113,30 +113,30 @@ __os_open(env, name, page_size, flags, m
 	 * Reproduce POSIX 1003.1 semantics: if O_CREATE and O_EXCL are both
 	 * specified, fail, returning EEXIST, unless we create the file.
 	 */
-	if (LF_ISSET(DB_OSO_CREATE) && LF_ISSET(DB_OSO_EXCL))
+	if (((flags) & (DB_OSO_CREATE)) && ((flags) & (DB_OSO_EXCL)))
 		createflag = CREATE_NEW;	/* create only if !exist*/
-	else if (!LF_ISSET(DB_OSO_CREATE) && LF_ISSET(DB_OSO_TRUNC))
+	else if (!((flags) & (DB_OSO_CREATE)) && ((flags) & (DB_OSO_TRUNC)))
 		createflag = TRUNCATE_EXISTING; /* truncate, fail if !exist */
-	else if (LF_ISSET(DB_OSO_TRUNC))
+	else if (((flags) & (DB_OSO_TRUNC)))
 		createflag = CREATE_ALWAYS;	/* create and truncate */
-	else if (LF_ISSET(DB_OSO_CREATE))
+	else if (((flags) & (DB_OSO_CREATE)))
 		createflag = OPEN_ALWAYS;	/* open or create */
 	else
 		createflag = OPEN_EXISTING;	/* open only if existing */
 
-	if (LF_ISSET(DB_OSO_DSYNC)) {
+	if (((flags) & (DB_OSO_DSYNC))) {
 		F_SET(fhp, DB_FH_NOSYNC);
 		attr |= FILE_FLAG_WRITE_THROUGH;
 	}
 
 #ifndef DB_WINCE
-	if (LF_ISSET(DB_OSO_SEQ))
+	if (((flags) & (DB_OSO_SEQ)))
 		attr |= FILE_FLAG_SEQUENTIAL_SCAN;
 	else
 		attr |= FILE_FLAG_RANDOM_ACCESS;
 #endif
 
-	if (LF_ISSET(DB_OSO_TEMP))
+	if (((flags) & (DB_OSO_TEMP)))
 		attr |= FILE_FLAG_DELETE_ON_CLOSE;
 
 	/*
@@ -149,7 +149,7 @@ __os_open(env, name, page_size, flags, m
 	 * return the sector size.
 	 */
 #ifndef DB_WINCE
-	if (LF_ISSET(DB_OSO_DIRECT) && page_size != 0 && name[0] != '\0') {
+	if (((flags) & (DB_OSO_DIRECT)) && page_size != 0 && name[0] != '\0') {
 		if (name[1] == ':') {
 			drive = dbuf;
 			_sntprintf(dbuf, sizeof(dbuf), _T("%c:\\"), tname[0]);
@@ -171,7 +171,7 @@ __os_open(env, name, page_size, flags, m
 	for (nrepeat = 1;; ++nrepeat) {
 		if (fhp->handle == INVALID_HANDLE_VALUE) {
 #ifdef DB_WINCE
-			if (LF_ISSET(DB_OSO_REGION))
+			if (((flags) & (DB_OSO_REGION)))
 				fhp->handle = CreateFileForMapping(tname,
 				    access, share, NULL, createflag, attr, 0);
 			else
@@ -203,11 +203,11 @@ __os_open(env, name, page_size, flags, m
 		 * used just for truncating.
 		 */
 		if (fhp->handle != INVALID_HANDLE_VALUE &&
-		    !LF_ISSET(DB_OSO_RDONLY | DB_OSO_TEMP) &&
+		    !((flags) & (DB_OSO_RDONLY | DB_OSO_TEMP)) &&
 		    fhp->trunc_handle == INVALID_HANDLE_VALUE
 #ifdef DB_WINCE
 		    /* Do not open trunc handle for region files. */
-		    && (!LF_ISSET(DB_OSO_REGION))
+		    && (!((flags) & (DB_OSO_REGION)))
 #endif
 		    )
 			fhp->trunc_handle = CreateFile(
@@ -245,7 +245,7 @@ __os_open(env, name, page_size, flags, m
 
 	FREE_STRING(env, tname);
 
-	if (LF_ISSET(DB_OSO_REGION))
+	if (((flags) & (DB_OSO_REGION)))
 		F_SET(fhp, DB_FH_REGION);
 	F_SET(fhp, DB_FH_OPENED);
 	*fhpp = fhp;
diff -u -p a/db-5.2.28.NC/src/log/log_stat.c b/db-5.2.28.NC/src/log/log_stat.c
--- a/db-5.2.28.NC/src/log/log_stat.c
+++ b/db-5.2.28.NC/src/log/log_stat.c
@@ -74,7 +74,7 @@ __log_stat(env, statp, flags)
 	/* Copy out the global statistics. */
 	LOG_SYSTEM_LOCK(env);
 	*stats = lp->stat;
-	if (LF_ISSET(DB_STAT_CLEAR))
+	if (((flags) & (DB_STAT_CLEAR)))
 		memset(&lp->stat, 0, sizeof(lp->stat));
 
 	stats->st_magic = lp->persist.magic;
@@ -85,7 +85,7 @@ __log_stat(env, statp, flags)
 
 	__mutex_set_wait_info(env, lp->mtx_region,
 	    &stats->st_region_wait, &stats->st_region_nowait);
-	if (LF_ISSET(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM) == DB_STAT_CLEAR)
+	if (((flags) & (DB_STAT_CLEAR | DB_STAT_SUBSYSTEM)) == DB_STAT_CLEAR)
 		__mutex_clear(env, lp->mtx_region);
 	stats->st_regsize = dblp->reginfo.rp->size;
 
@@ -145,14 +145,14 @@ __log_stat_print(env, flags)
 	int ret;
 
 	orig_flags = flags;
-	LF_CLR(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM);
-	if (flags == 0 || LF_ISSET(DB_STAT_ALL)) {
+	((flags) &= ~(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM));
+	if (flags == 0 || ((flags) & (DB_STAT_ALL))) {
 		ret = __log_print_stats(env, orig_flags);
 		if (flags == 0 || ret != 0)
 			return (ret);
 	}
 
-	if (LF_ISSET(DB_STAT_ALL) &&
+	if (((flags) & (DB_STAT_ALL)) &&
 	    (ret = __log_print_all(env, orig_flags)) != 0)
 		return (ret);
 
@@ -174,7 +174,7 @@ __log_print_stats(env, flags)
 	if ((ret = __log_stat(env, &sp, flags)) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL))
+	if (((flags) & (DB_STAT_ALL)))
 		__db_msg(env, "Default logging region information:");
 	STAT_HEX("Log magic number", sp->st_magic);
 	STAT_ULONG("Log version number", sp->st_version);
diff -u -p a/db-5.2.28.NC/src/log/log_put.c b/db-5.2.28.NC/src/log/log_put.c
--- a/db-5.2.28.NC/src/log/log_put.c
+++ b/db-5.2.28.NC/src/log/log_put.c
@@ -58,7 +58,7 @@ __log_put_pp(dbenv, lsnp, udbt, flags)
 		return (ret);
 
 	/* DB_LOG_WRNOSYNC and DB_FLUSH are mutually exclusive. */
-	if (LF_ISSET(DB_LOG_WRNOSYNC) && LF_ISSET(DB_FLUSH))
+	if (((flags) & (DB_LOG_WRNOSYNC)) && ((flags) & (DB_FLUSH)))
 		return (__db_ferr(env, "DB_ENV->log_put", 1));
 
 	/* Replication clients should never write log records. */
@@ -148,7 +148,7 @@ __log_put(env, lsnp, udbt, flags)
 	 * so that we retain an unencrypted copy of the log record to send
 	 * to clients.
 	 */
-	if (!LF_ISSET(DB_LOG_NOCOPY) || IS_REP_MASTER(env)) {
+	if (!((flags) & (DB_LOG_NOCOPY)) || IS_REP_MASTER(env)) {
 		if (CRYPTO_ON(env))
 			t.size += db_cipher->adj_size(udbt->size);
 		if ((ret = __os_calloc(env, 1, t.size, &t.data)) != 0)
@@ -195,11 +195,11 @@ __log_put(env, lsnp, udbt, flags)
 		 * Replication masters need to drop the lock to send messages,
 		 * but want to drop and reacquire it a minimal number of times.
 		 */
-		ctlflags = LF_ISSET(DB_LOG_COMMIT | DB_LOG_CHKPNT) ?
+		ctlflags = ((flags) & (DB_LOG_COMMIT | DB_LOG_CHKPNT)) ?
 		    REPCTL_PERM : 0;
 		LOG_SYSTEM_UNLOCK(env);
 		lock_held = 0;
-		if (LF_ISSET(DB_FLUSH))
+		if (((flags) & (DB_FLUSH)))
 			ctlflags |= REPCTL_FLUSH;
 
 		/*
@@ -284,7 +284,7 @@ __log_put(env, lsnp, udbt, flags)
 		 * form somewhere.
 		 */
 		if (ret != 0 && FLD_ISSET(ctlflags, REPCTL_PERM))
-			LF_SET(DB_FLUSH);
+			((flags) |= (DB_FLUSH));
 		/*
 		 * We ignore send failures so reset 'ret' to 0 here.
 		 * We needed to check special return values from
@@ -304,7 +304,7 @@ __log_put(env, lsnp, udbt, flags)
 	 * If a flush is not needed, see if WRITE_NOSYNC was set and we
 	 * need to write out the log buffer.
 	 */
-	if (LF_ISSET(DB_FLUSH | DB_LOG_WRNOSYNC)) {
+	if (((flags) & (DB_FLUSH | DB_LOG_WRNOSYNC))) {
 		if (!lock_held) {
 			LOG_SYSTEM_LOCK(env);
 			lock_held = 1;
@@ -317,7 +317,7 @@ __log_put(env, lsnp, udbt, flags)
 	 * If flushed a checkpoint record, reset the "bytes since the last
 	 * checkpoint" counters.
 	 */
-	if (LF_ISSET(DB_LOG_CHKPNT))
+	if (((flags) & (DB_LOG_CHKPNT)))
 		lp->stat.st_wc_bytes = lp->stat.st_wc_mbytes = 0;
 
 	/* Increment count of records added to the log. */
@@ -534,7 +534,7 @@ __log_flush_commit(env, lsnp, flags)
 	 * DB_LOG_WRNOSYNC:
 	 *	If there's anything in the current log buffer, write it out.
 	 */
-	if (LF_ISSET(DB_FLUSH))
+	if (((flags) & (DB_FLUSH)))
 		ret = __log_flush_int(dblp, &flush_lsn, 1);
 	else if (!lp->db_log_inmemory && lp->b_off != 0)
 		if ((ret = __log_write(dblp,
@@ -547,10 +547,10 @@ __log_flush_commit(env, lsnp, flags)
 	 * if the commit we care about made it to disk successfully, we just
 	 * ignore the failure, because there's no way to undo the commit.)
 	 */
-	if (ret == 0 || !LF_ISSET(DB_LOG_COMMIT))
+	if (ret == 0 || !((flags) & (DB_LOG_COMMIT)))
 		return (ret);
 
-	if (LF_ISSET(DB_FLUSH) ?
+	if (((flags) & (DB_FLUSH)) ?
 	    flush_lsn.file != lp->s_lsn.file ||
 	    flush_lsn.offset < lp->s_lsn.offset :
 	    flush_lsn.file != lp->lsn.file || flush_lsn.offset < lp->w_off)
@@ -1623,7 +1623,7 @@ err:
 	 */
 	lp->ready_lsn = lp->lsn;
 
-	if (LF_ISSET(DB_LOG_CHKPNT))
+	if (((flags) & (DB_LOG_CHKPNT)))
 		lp->stat.st_wc_bytes = lp->stat.st_wc_mbytes = 0;
 
 	/* Increment count of records added to the log. */
@@ -1703,7 +1703,7 @@ __log_put_record_pp(dbenv, dbp, txnp, re
 		return (ret);
 
 	/* DB_LOG_WRNOSYNC and DB_FLUSH are mutually exclusive. */
-	if (LF_ISSET(DB_LOG_WRNOSYNC) && LF_ISSET(DB_FLUSH))
+	if (((flags) & (DB_LOG_WRNOSYNC)) && ((flags) & (DB_FLUSH)))
 		return (__db_ferr(env, "DB_ENV->log_put_record", 1));
 
 	/* Replication clients should never write log records. */
@@ -1806,7 +1806,7 @@ __log_put_record_int(env, dbp, txnp, ret
 	 * may be the lsn of a page and we do not want to set it if
 	 * the log_put fails after writing the record (due to an I/O error).
 	 */
-	if (LF_ISSET(DB_LOG_COMMIT))
+	if (((flags) & (DB_LOG_COMMIT)))
 		rlsnp = ret_lsnp;
 	else
 		rlsnp = &lsn;
@@ -1814,7 +1814,7 @@ __log_put_record_int(env, dbp, txnp, ret
 	ret = 0;
 	data = NULL;
 
-	if (LF_ISSET(DB_LOG_NOT_DURABLE) ||
+	if (((flags) & (DB_LOG_NOT_DURABLE)) ||
 	    (dbp != NULL && F_ISSET(dbp, DB_AM_NOT_DURABLE))) {
 		if (txnp == NULL)
 			return (0);
diff -u -p a/db-5.2.28.NC/src/log/log_archive.c b/db-5.2.28.NC/src/log/log_archive.c
--- a/db-5.2.28.NC/src/log/log_archive.c
+++ b/db-5.2.28.NC/src/log/log_archive.c
@@ -97,7 +97,7 @@ __log_archive(env, listp, flags)
 
 	/* There are no log files if logs are in memory. */
 	if (lp->db_log_inmemory) {
-		LF_CLR(~DB_ARCH_DATA);
+		((flags) &= ~(~DB_ARCH_DATA));
 		if (flags == 0)
 			return (0);
 	}
@@ -107,8 +107,8 @@ __log_archive(env, listp, flags)
 	 * at a bad time in replication initialization.
 	 */
 	handle_check = 0;
-	if (!LF_ISSET(DB_ARCH_DATA) &&
-	    !LF_ISSET(DB_ARCH_LOG)) {
+	if (!((flags) & (DB_ARCH_DATA)) &&
+	    !((flags) & (DB_ARCH_LOG))) {
 		/*
 		 * If we're locked out, just return success.  No files
 		 * can be archived right now.  Any other error pass back
@@ -127,7 +127,7 @@ __log_archive(env, listp, flags)
 	 * absolute path to the database environment directory.
 	 */
 #ifdef HAVE_GETCWD
-	if (LF_ISSET(DB_ARCH_ABS)) {
+	if (((flags) & (DB_ARCH_ABS))) {
 		/*
 		 * XXX
 		 * Can't trust getcwd(3) to set a valid errno, so don't display
@@ -148,7 +148,7 @@ __log_archive(env, listp, flags)
 #endif
 		pref = NULL;
 
-	LF_CLR(DB_ARCH_ABS);
+	((flags) &= ~(DB_ARCH_ABS));
 	switch (flags) {
 	case DB_ARCH_DATA:
 		ret = __build_data(env, pref, listp);
@@ -208,7 +208,7 @@ __log_archive(env, listp, flags)
 		if (__os_exists(env, name, NULL) != 0) {
 			__os_free(env, name);
 			name = NULL;
-			if (LF_ISSET(DB_ARCH_LOG) && fnum == stable_lsn.file)
+			if (((flags) & (DB_ARCH_LOG)) && fnum == stable_lsn.file)
 				continue;
 			break;
 		}
diff -u -p a/db-5.2.28.NC/src/log/log_method.c b/db-5.2.28.NC/src/log/log_method.c
--- a/db-5.2.28.NC/src/log/log_method.c
+++ b/db-5.2.28.NC/src/log/log_method.c
@@ -335,13 +335,13 @@ __log_get_flags(dbenv, flagsp)
 
 	flags = *flagsp;
 	if (lp->db_log_autoremove)
-		LF_SET(DB_LOG_AUTO_REMOVE);
+		((flags) |= (DB_LOG_AUTO_REMOVE));
 	else
-		LF_CLR(DB_LOG_AUTO_REMOVE);
+		((flags) &= ~(DB_LOG_AUTO_REMOVE));
 	if (lp->db_log_inmemory)
-		LF_SET(DB_LOG_IN_MEMORY);
+		((flags) |= (DB_LOG_IN_MEMORY));
 	else
-		LF_CLR(DB_LOG_IN_MEMORY);
+		((flags) &= ~(DB_LOG_IN_MEMORY));
 	*flagsp = flags;
 }
 
@@ -365,9 +365,9 @@ __log_set_flags(env, flags, on)
 
 	lp = dblp->reginfo.primary;
 
-	if (LF_ISSET(DB_LOG_AUTO_REMOVE))
+	if (((flags) & (DB_LOG_AUTO_REMOVE)))
 		lp->db_log_autoremove = on ? 1 : 0;
-	if (LF_ISSET(DB_LOG_IN_MEMORY))
+	if (((flags) & (DB_LOG_IN_MEMORY)))
 		lp->db_log_inmemory = on ? 1 : 0;
 }
 
@@ -410,7 +410,7 @@ __log_get_config(dbenv, which, onp)
 
 	__env_fetch_flags(LogMap, sizeof(LogMap), &dblp->flags, &flags);
 	__log_get_flags(dbenv, &flags);
-	if (LF_ISSET(which))
+	if (((flags) & (which)))
 		*onp = 1;
 	else
 		*onp = 0;
@@ -454,14 +454,14 @@ __log_set_config_int(dbenv, flags, on, i
 	if (FLD_ISSET(flags, ~OK_FLAGS))
 		return (__db_ferr(env, "DB_ENV->log_set_config", 0));
 	ENV_NOT_CONFIGURED(env, dblp, "DB_ENV->log_set_config", DB_INIT_LOG);
-	if (LF_ISSET(DB_LOG_DIRECT) && __os_support_direct_io() == 0) {
+	if (((flags) & (DB_LOG_DIRECT)) && __os_support_direct_io() == 0) {
 		__db_errx(env,
 "DB_ENV->log_set_config: direct I/O either not configured or not supported");
 		return (EINVAL);
 	}
 
 	if (LOGGING_ON(env)) {
-		if (!in_open && LF_ISSET(DB_LOG_IN_MEMORY) &&
+		if (!in_open && ((flags) & (DB_LOG_IN_MEMORY)) &&
 		    ((LOG *)dblp->reginfo.primary)->db_log_inmemory == 0)
 			ENV_ILLEGAL_AFTER_OPEN(env,
 			     "DB_ENV->log_set_config: DB_LOG_IN_MEMORY");
@@ -478,7 +478,7 @@ __log_set_config_int(dbenv, flags, on, i
 		 * are mutually incompatible.  If we're setting one of them,
 		 * clear all current settings.
 		 */
-		if (on && LF_ISSET(DB_LOG_IN_MEMORY))
+		if (on && ((flags) & (DB_LOG_IN_MEMORY)))
 			F_CLR(dbenv,
 			     DB_ENV_TXN_NOSYNC | DB_ENV_TXN_WRITE_NOSYNC);
 
diff -u -p a/db-5.2.28.NC/src/dbinc/db_am.h b/db-5.2.28.NC/src/dbinc/db_am.h
--- a/db-5.2.28.NC/src/dbinc/db_am.h
+++ b/db-5.2.28.NC/src/dbinc/db_am.h
@@ -42,10 +42,10 @@ struct __db_foreign_info {
  *	Auto-commit test for enviroment operations: DbEnv::{open,remove,rename}
  */
 #define	IS_ENV_AUTO_COMMIT(env, txn, flags)				\
-	(LF_ISSET(DB_AUTO_COMMIT) ||					\
+	(((flags) & (DB_AUTO_COMMIT)) ||					\
 	    (((txn) == NULL || F_ISSET((txn), TXN_FAMILY)) &&		\
 	    F_ISSET((env)->dbenv, DB_ENV_AUTO_COMMIT) &&		\
-	    !LF_ISSET(DB_NO_AUTO_COMMIT)))
+	    !((flags) & (DB_NO_AUTO_COMMIT))))
 
 /*
  * IS_DB_AUTO_COMMIT --
diff -u -p a/db-5.2.28.NC/src/mutex/mut_stat.c b/db-5.2.28.NC/src/mutex/mut_stat.c
--- a/db-5.2.28.NC/src/mutex/mut_stat.c
+++ b/db-5.2.28.NC/src/mutex/mut_stat.c
@@ -83,7 +83,7 @@ __mutex_stat(env, statp, flags)
 	stats->st_regmax = mtxmgr->reginfo.rp->max;
 	__mutex_set_wait_info(env, mtxregion->mtx_region,
 	    &stats->st_region_wait, &stats->st_region_nowait);
-	if (LF_ISSET(DB_STAT_CLEAR))
+	if (((flags) & (DB_STAT_CLEAR)))
 		__mutex_clear(env, mtxregion->mtx_region);
 
 	MUTEX_SYSTEM_UNLOCK(env);
@@ -137,15 +137,15 @@ __mutex_stat_print(env, flags)
 	int ret;
 
 	orig_flags = flags;
-	LF_CLR(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM);
-	if (flags == 0 || LF_ISSET(DB_STAT_ALL)) {
+	((flags) &= ~(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM));
+	if (flags == 0 || ((flags) & (DB_STAT_ALL))) {
 		ret = __mutex_print_stats(env, orig_flags);
 		__mutex_print_summary(env);
 		if (flags == 0 || ret != 0)
 			return (ret);
 	}
 
-	if (LF_ISSET(DB_STAT_ALL))
+	if (((flags) & (DB_STAT_ALL)))
 		ret = __mutex_print_all(env, orig_flags);
 
 	return (0);
@@ -216,10 +216,10 @@ __mutex_print_stats(env, flags)
 	DB_MUTEX_STAT *sp;
 	int ret;
 
-	if ((ret = __mutex_stat(env, &sp, LF_ISSET(DB_STAT_CLEAR))) != 0)
+	if ((ret = __mutex_stat(env, &sp, ((flags) & (DB_STAT_CLEAR)))) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL))
+	if (((flags) & (DB_STAT_ALL)))
 		__db_msg(env, "Default mutex region information:");
 
 	__db_dlbytes(env, "Mutex region size",
@@ -352,8 +352,8 @@ __mutex_print_debug_single(env, tag, mut
 	DB_MSGBUF_INIT(&mb);
 	mbp = &mb;
 
-	if (LF_ISSET(DB_STAT_SUBSYSTEM))
-		LF_CLR(DB_STAT_CLEAR);
+	if (((flags) & (DB_STAT_SUBSYSTEM)))
+		((flags) &= ~(DB_STAT_CLEAR));
 	__db_msgadd(env, mbp, "%lu\t%s ", (u_long)mutex, tag);
 	__mutex_print_debug_stats(env, mbp, mutex, flags);
 	DB_MSGBUF_FLUSH(env, mbp);
@@ -450,7 +450,7 @@ __mutex_print_debug_stats(env, mbp, mute
 		    mutexp->hybrid_wait, mutexp->hybrid_wakeup);
 #endif
 
-	if (LF_ISSET(DB_STAT_CLEAR))
+	if (((flags) & (DB_STAT_CLEAR)))
 		__mutex_clear(env, mutex);
 }
 
diff -u -p a/db-5.2.28.NC/src/mutex/mut_alloc.c b/db-5.2.28.NC/src/mutex/mut_alloc.c
--- a/db-5.2.28.NC/src/mutex/mut_alloc.c
+++ b/db-5.2.28.NC/src/mutex/mut_alloc.c
@@ -35,13 +35,13 @@ __mutex_alloc(env, alloc_id, flags, indx
 	if (alloc_id != MTX_APPLICATION && alloc_id != MTX_MUTEX_TEST &&
 	    (F_ISSET(env->dbenv, DB_ENV_NOLOCKING) ||
 	    (!F_ISSET(env, ENV_THREAD) &&
-	    (LF_ISSET(DB_MUTEX_PROCESS_ONLY) ||
+	    (((flags) & (DB_MUTEX_PROCESS_ONLY)) ||
 	    F_ISSET(env, ENV_PRIVATE)))))
 		return (0);
 
 	/* Private environments never share mutexes. */
 	if (F_ISSET(env, ENV_PRIVATE))
-		LF_SET(DB_MUTEX_PROCESS_ONLY);
+		((flags) |= (DB_MUTEX_PROCESS_ONLY));
 
 	/*
 	 * If we have a region in which to allocate the mutexes, lock it and
@@ -164,15 +164,14 @@ nomem:			__db_errx(env, DB_STR("2034",
 	/* Initialize the mutex. */
 	memset(mutexp, 0, sizeof(*mutexp));
 	F_SET(mutexp, DB_MUTEX_ALLOCATED |
-	    LF_ISSET(DB_MUTEX_LOGICAL_LOCK |
-		DB_MUTEX_PROCESS_ONLY | DB_MUTEX_SHARED));
+	    ((flags) & (DB_MUTEX_LOGICAL_LOCK | DB_MUTEX_PROCESS_ONLY | DB_MUTEX_SHARED)));
 
 	/*
 	 * If the mutex is associated with a single process, set the process
 	 * ID.  If the application ever calls DbEnv::failchk, we'll need the
 	 * process ID to know if the mutex is still in use.
 	 */
-	if (LF_ISSET(DB_MUTEX_PROCESS_ONLY))
+	if (((flags) & (DB_MUTEX_PROCESS_ONLY)))
 		dbenv->thread_id(dbenv, &mutexp->pid, NULL);
 
 #ifdef HAVE_STATISTICS
@@ -282,9 +281,8 @@ __mutex_refresh(env, mutex)
 	if ((ret = __mutex_destroy(env, mutex)) == 0) {
 		memset(mutexp, 0, sizeof(*mutexp));
 		F_SET(mutexp, DB_MUTEX_ALLOCATED |
-		    LF_ISSET(DB_MUTEX_LOGICAL_LOCK |
-			DB_MUTEX_PROCESS_ONLY | DB_MUTEX_SHARED));
-		LF_CLR(DB_MUTEX_LOCKED);
+		    ((flags) & (DB_MUTEX_LOGICAL_LOCK | DB_MUTEX_PROCESS_ONLY | DB_MUTEX_SHARED)));
+		((flags) &= ~(DB_MUTEX_LOCKED));
 		ret = __mutex_init(env, mutex, flags);
 	}
 	return (ret);
diff -u -p a/db-5.2.28.NC/src/mutex/test_mutex.c b/db-5.2.28.NC/src/mutex/test_mutex.c
--- a/db-5.2.28.NC/src/mutex/test_mutex.c
+++ b/db-5.2.28.NC/src/mutex/test_mutex.c
@@ -52,7 +52,7 @@ typedef pid_t os_pid_t;
 typedef pthread_t os_thread_t;
 
 #define	os_thread_create(thrp, attr, func, arg)				\
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define	os_thread_join(thr, statusp) pthread_join((thr), (statusp))
 #define	os_thread_self() pthread_self()
 #endif /* HAVE_PTHREAD_YIELD */
diff -u -p a/db-5.2.28.NC/src/mutex/mut_pthread.c b/db-5.2.28.NC/src/mutex/mut_pthread.c
--- a/db-5.2.28.NC/src/mutex/mut_pthread.c
+++ b/db-5.2.28.NC/src/mutex/mut_pthread.c
@@ -85,8 +85,8 @@ __db_pthread_mutex_init(env, mutex, flag
 
 #ifndef HAVE_MUTEX_HYBRID
 	/* Can't have self-blocking shared latches.  */
-	DB_ASSERT(env, !LF_ISSET(DB_MUTEX_SELF_BLOCK) ||
-	    !LF_ISSET(DB_MUTEX_SHARED));
+	DB_ASSERT(env, !((flags) & (DB_MUTEX_SELF_BLOCK)) ||
+	    !((flags) & (DB_MUTEX_SHARED)));
 #endif
 
 #ifdef HAVE_MUTEX_PTHREADS
@@ -99,11 +99,11 @@ __db_pthread_mutex_init(env, mutex, flag
 	pthread_mutexattr_t *mutexattrp = NULL;
 
 #ifndef HAVE_MUTEX_HYBRID
-	if (LF_ISSET(DB_MUTEX_SHARED)) {
+	if (((flags) & (DB_MUTEX_SHARED))) {
 #if defined(HAVE_SHARED_LATCHES)
 		pthread_rwlockattr_t rwlockattr, *rwlockattrp = NULL;
 #ifndef HAVE_MUTEX_THREAD_ONLY
-		if (!LF_ISSET(DB_MUTEX_PROCESS_ONLY)) {
+		if (!((flags) & (DB_MUTEX_PROCESS_ONLY))) {
 			RET_SET((pthread_rwlockattr_init(&rwlockattr)), ret);
 			if (ret != 0)
 				goto err;
@@ -126,7 +126,7 @@ __db_pthread_mutex_init(env, mutex, flag
 	}
 #endif
 #ifndef HAVE_MUTEX_THREAD_ONLY
-	if (!LF_ISSET(DB_MUTEX_PROCESS_ONLY)) {
+	if (!((flags) & (DB_MUTEX_PROCESS_ONLY))) {
 		RET_SET((pthread_mutexattr_init(&mutexattr)), ret);
 		if (ret != 0)
 			goto err;
@@ -144,9 +144,9 @@ __db_pthread_mutex_init(env, mutex, flag
 		(void)pthread_mutexattr_destroy(mutexattrp);
 	if (ret != 0)
 		goto err;
-	if (LF_ISSET(DB_MUTEX_SELF_BLOCK)) {
+	if (((flags) & (DB_MUTEX_SELF_BLOCK))) {
 #ifndef HAVE_MUTEX_THREAD_ONLY
-		if (!LF_ISSET(DB_MUTEX_PROCESS_ONLY)) {
+		if (!((flags) & (DB_MUTEX_PROCESS_ONLY))) {
 			RET_SET((pthread_condattr_init(&condattr)), ret);
 			if (ret != 0)
 				goto err;
@@ -177,7 +177,7 @@ __db_pthread_mutex_init(env, mutex, flag
 	 * initialization values doesn't have surrounding braces.  There's not
 	 * much we can do.
 	 */
-	if (LF_ISSET(DB_MUTEX_PROCESS_ONLY)) {
+	if (((flags) & (DB_MUTEX_PROCESS_ONLY))) {
 		static lwp_mutex_t mi = DEFAULTMUTEX;
 
 		mutexp->mutex = mi;
@@ -186,8 +186,8 @@ __db_pthread_mutex_init(env, mutex, flag
 
 		mutexp->mutex = mi;
 	}
-	if (LF_ISSET(DB_MUTEX_SELF_BLOCK)) {
-		if (LF_ISSET(DB_MUTEX_PROCESS_ONLY)) {
+	if (((flags) & (DB_MUTEX_SELF_BLOCK))) {
+		if (((flags) & (DB_MUTEX_PROCESS_ONLY))) {
 			static lwp_cond_t ci = DEFAULTCV;
 
 			mutexp->cond = ci;
@@ -203,10 +203,10 @@ __db_pthread_mutex_init(env, mutex, flag
 	{
 	int type;
 
-	type = LF_ISSET(DB_MUTEX_PROCESS_ONLY) ? USYNC_THREAD : USYNC_PROCESS;
+	type = ((flags) & (DB_MUTEX_PROCESS_ONLY)) ? USYNC_THREAD : USYNC_PROCESS;
 
 	ret = mutex_init(&mutexp->mutex, type, NULL);
-	if (ret == 0 && LF_ISSET(DB_MUTEX_SELF_BLOCK)) {
+	if (ret == 0 && ((flags) & (DB_MUTEX_SELF_BLOCK))) {
 		ret = cond_init(&mutexp->cond, type, NULL);
 
 		F_SET(mutexp, DB_MUTEX_SELF_BLOCK);
diff -u -p a/db-5.2.28.NC/src/sequence/sequence.c b/db-5.2.28.NC/src/sequence/sequence.c
--- a/db-5.2.28.NC/src/sequence/sequence.c
+++ b/db-5.2.28.NC/src/sequence/sequence.c
@@ -199,7 +199,7 @@ __seq_open_pp(seq, txn, keyp, flags)
 		goto err;
 	}
 
-	if (LF_ISSET(DB_THREAD)) {
+	if (((flags) & (DB_THREAD))) {
 		if ((ret = __mutex_alloc(env,
 		    MTX_SEQUENCE, DB_MUTEX_PROCESS_ONLY, &seq->mtx_seq)) != 0)
 			goto err;
@@ -238,7 +238,7 @@ retry:	if ((ret = __db_get(dbp, ip,
 			goto retry;
 		}
 		if ((ret != DB_NOTFOUND && ret != DB_KEYEMPTY) ||
-		    !LF_ISSET(DB_CREATE))
+		    !((flags) & (DB_CREATE)))
 			goto err;
 		if (IS_REP_CLIENT(env) &&
 		    !F_ISSET(dbp, DB_AM_NOT_DURABLE)) {
@@ -281,7 +281,7 @@ retry:	if ((ret = __db_get(dbp, ip,
 				goto err;
 			}
 		}
-	} else if (LF_ISSET(DB_CREATE) && LF_ISSET(DB_EXCL)) {
+	} else if (((flags) & (DB_CREATE)) && ((flags) & (DB_EXCL))) {
 		ret = EEXIST;
 		goto err;
 	} else if (seq->seq_data.size < sizeof(seq->seq_record)) {
@@ -469,7 +469,7 @@ __seq_set_flags(seq, flags)
 	     "DB_SEQUENCE->set_flags", flags, DB_SEQ_DEC, DB_SEQ_INC)) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_SEQ_DEC | DB_SEQ_INC))
+	if (((flags) & (DB_SEQ_DEC | DB_SEQ_INC)))
 		F_CLR(rp, DB_SEQ_DEC | DB_SEQ_INC);
 	F_SET(rp, flags);
 
@@ -718,7 +718,7 @@ err:	if (need_mutex) {
 		MUTEX_LOCK(env, seq->mtx_seq);
 	}
 	return (txn_local ? __db_txn_auto_resolve(
-	    env, txn, LF_ISSET(DB_TXN_NOSYNC), ret) : ret);
+	    env, txn, ((flags) & (DB_TXN_NOSYNC)), ret) : ret);
 }
 
 static int
@@ -743,7 +743,7 @@ __seq_get(seq, txn, delta, retp, flags)
 	STRIP_AUTO_COMMIT(flags);
 	SEQ_ILLEGAL_BEFORE_OPEN(seq, "DB_SEQUENCE->get");
 
-	if (delta < 0 || (delta == 0 && !LF_ISSET(DB_CURRENT))) {
+	if (delta < 0 || (delta == 0 && !((flags) & (DB_CURRENT)))) {
 		__db_errx(env, "Sequence delta must be greater than 0");
 		return (EINVAL);
 	}
@@ -776,7 +776,7 @@ __seq_get(seq, txn, delta, retp, flags)
 		goto err;
 	}
 
-	if (LF_ISSET(DB_CURRENT)) {
+	if (((flags) & (DB_CURRENT))) {
 		*retp = seq->seq_prev_value;
 	} else if (F_ISSET(rp, DB_SEQ_INC)) {
 		if (seq->seq_last_value + 1 - rp->seq_value < delta &&
diff -u -p a/db-5.2.28.NC/src/sequence/seq_stat.c b/db-5.2.28.NC/src/sequence/seq_stat.c
--- a/db-5.2.28.NC/src/sequence/seq_stat.c
+++ b/db-5.2.28.NC/src/sequence/seq_stat.c
@@ -70,7 +70,7 @@ __seq_stat(seq, spp, flags)
 		__mutex_set_wait_info(
 		    env, seq->mtx_seq, &sp->st_wait, &sp->st_nowait);
 
-		if (LF_ISSET(DB_STAT_CLEAR))
+		if (((flags) & (DB_STAT_CLEAR)))
 			__mutex_clear(env, seq->mtx_seq);
 	}
 	memset(&data, 0, sizeof(data));
@@ -143,7 +143,7 @@ __seq_stat_print(seq, flags)
 	if ((ret = __seq_print_stats(seq, flags)) != 0)
 		goto err;
 
-	if (LF_ISSET(DB_STAT_ALL) &&
+	if (((flags) & (DB_STAT_ALL)) &&
 	    (ret = __seq_print_all(seq, flags)) != 0)
 		goto err;
 
diff -u -p a/db-5.2.28.NC/src/btree/bt_recno.c b/db-5.2.28.NC/src/btree/bt_recno.c
--- a/db-5.2.28.NC/src/btree/bt_recno.c
+++ b/db-5.2.28.NC/src/btree/bt_recno.c
@@ -372,7 +372,7 @@ __ramc_get(dbc, key, data, flags, pgnop)
 	dbp = dbc->dbp;
 	cp = (BTREE_CURSOR *)dbc->internal;
 
-	LF_CLR(DB_MULTIPLE|DB_MULTIPLE_KEY);
+	((flags) &= ~(DB_MULTIPLE | DB_MULTIPLE_KEY));
 retry:	switch (flags) {
 	case DB_CURRENT:
 		/*
diff -u -p a/db-5.2.28.NC/src/btree/bt_upgrade.c b/db-5.2.28.NC/src/btree/bt_upgrade.c
--- a/db-5.2.28.NC/src/btree/bt_upgrade.c
+++ b/db-5.2.28.NC/src/btree/bt_upgrade.c
@@ -106,7 +106,7 @@ __bam_31_btreemeta(dbp, real_name, flags
 	newmeta->dbmeta.version = 8;
 
 	/* Upgrade the flags. */
-	if (LF_ISSET(DB_DUPSORT))
+	if (((flags) & (DB_DUPSORT)))
 		F_SET(&newmeta->dbmeta, BTM_DUPSORT);
 
 	*dirtyp = 1;
@@ -140,7 +140,7 @@ __bam_31_lbtree(dbp, real_name, flags, f
 		if (B_TYPE(bk->type) == B_DUPLICATE) {
 			pgno = GET_BOVERFLOW(dbp, h, indx)->pgno;
 			if ((ret = __db_31_offdup(dbp, real_name, fhp,
-			    LF_ISSET(DB_DUPSORT) ? 1 : 0, &pgno)) != 0)
+			    ((flags) & (DB_DUPSORT)) ? 1 : 0, &pgno)) != 0)
 				break;
 			if (pgno != GET_BOVERFLOW(dbp, h, indx)->pgno) {
 				*dirtyp = 1;
diff -u -p a/db-5.2.28.NC/src/btree/bt_verify.c b/db-5.2.28.NC/src/btree/bt_verify.c
--- a/db-5.2.28.NC/src/btree/bt_verify.c
+++ b/db-5.2.28.NC/src/btree/bt_verify.c
@@ -213,7 +213,7 @@ __bam_vrfy_meta(dbp, vdp, meta, pgno, fl
 
 err:	if ((t_ret = __db_vrfy_putpageinfo(env, vdp, pip)) != 0 && ret == 0)
 		ret = t_ret;
-	if (LF_ISSET(DB_SALVAGE) &&
+	if (((flags) & (DB_SALVAGE)) &&
 	   (t_ret = __db_salvage_markdone(vdp, pgno)) != 0 && ret == 0)
 		ret = t_ret;
 	return ((ret == 0 && isbad == 1) ? DB_VERIFY_BAD : ret);
@@ -397,7 +397,7 @@ __bam_vrfy(dbp, vdp, h, pgno, flags)
 		EPRINT((env, DB_STR_A("1045",
 		    "Page %lu: item order check unsafe: skipping",
 		    "%lu"), (u_long)pgno));
-	} else if (!LF_ISSET(DB_NOORDERCHK) && (ret =
+	} else if (!((flags) & (DB_NOORDERCHK)) && (ret =
 	    __bam_vrfy_itemorder(dbp,
 	    vdp, vdp->thread_info, h, pgno, 0, 0, 0, flags)) != 0) {
 		/*
@@ -584,7 +584,7 @@ __bam_vrfy_inp(dbp, vdp, h, pgno, nentri
 		 * we merely suspect is a btree page.  Otherwise, it
 		 * shouldn't get called--if it is, that's a verifier bug.
 		 */
-		if (LF_ISSET(DB_SALVAGE))
+		if (((flags) & (DB_SALVAGE)))
 			break;
 		ret = __db_unknown_path(env, "__bam_vrfy_inp");
 		goto err;
@@ -948,7 +948,7 @@ __bam_vrfy_itemorder(dbp, vdp, ip, h, pg
 
 	buf1 = buf2 = NULL;
 
-	DB_ASSERT(env, !LF_ISSET(DB_NOORDERCHK));
+	DB_ASSERT(env, !((flags) & (DB_NOORDERCHK)));
 
 	dupfunc = (dbp->dup_compare == NULL) ? __bam_defcmp : dbp->dup_compare;
 	if (TYPE(h) == P_LDUP)
@@ -1394,7 +1394,7 @@ __bam_vrfy_subtree(dbp, vdp, pgno, l, r,
 	isbad = ret = 0;
 
 	/* Provide feedback on our progress to the application. */
-	if (!LF_ISSET(DB_SALVAGE))
+	if (!((flags) & (DB_SALVAGE)))
 		__db_vrfy_struct_feedback(dbp, vdp);
 
 	if ((ret = __db_vrfy_getpageinfo(vdp, pgno, &pip)) != 0)
@@ -1403,8 +1403,8 @@ __bam_vrfy_subtree(dbp, vdp, pgno, l, r,
 	cc = NULL;
 	level = pip->bt_level;
 
-	toplevel = LF_ISSET(DB_ST_TOPLEVEL) ? 1 : 0;
-	LF_CLR(DB_ST_TOPLEVEL);
+	toplevel = ((flags) & (DB_ST_TOPLEVEL)) ? 1 : 0;
+	((flags) &= ~(DB_ST_TOPLEVEL));
 
 	/*
 	 * If this is the root, initialize the vdp's prev- and next-pgno
@@ -1540,9 +1540,9 @@ bad_prev:				isbad = 1;
 
 		/* Case 1 */
 		if (pip->type == P_LRECNO) {
-			if (!LF_ISSET(DB_ST_IS_RECNO) &&
-			    !(LF_ISSET(DB_ST_DUPOK) &&
-			    !LF_ISSET(DB_ST_DUPSORT))) {
+			if (!((flags) & (DB_ST_IS_RECNO)) &&
+			    !(((flags) & (DB_ST_DUPOK)) &&
+			    !((flags) & (DB_ST_DUPSORT)))) {
 				isbad = 1;
 				EPRINT((env, DB_STR_A("1077",
 				    "Page %lu: recno leaf page non-recno tree",
@@ -1550,7 +1550,7 @@ bad_prev:				isbad = 1;
 				goto done;
 			}
 			goto leaf;
-		} else if (LF_ISSET(DB_ST_IS_RECNO)) {
+		} else if (((flags) & (DB_ST_IS_RECNO))) {
 			/*
 			 * It's a non-recno leaf.  Had better not be a recno
 			 * subtree.
@@ -1571,7 +1571,7 @@ bad_prev:				isbad = 1;
 		/* Check if we have any dups. */
 		if (F_ISSET(pip, VRFY_HAS_DUPS)) {
 			/* If dups aren't allowed in this btree, trouble. */
-			if (!LF_ISSET(DB_ST_DUPOK)) {
+			if (!((flags) & (DB_ST_DUPOK))) {
 				isbad = 1;
 				EPRINT((env, DB_STR_A("1079",
 				    "Page %lu: duplicates in non-dup btree",
@@ -1621,7 +1621,7 @@ bad_prev:				isbad = 1;
 				 * DB_ST_DUPSORT had better not be.
 				 */
 				if (F_ISSET(pip, VRFY_DUPS_UNSORTED) &&
-				    LF_ISSET(DB_ST_DUPSORT)) {
+				    ((flags) & (DB_ST_DUPSORT))) {
 					isbad = 1;
 					EPRINT((env, DB_STR_A("1080",
 		    "Page %lu: unsorted duplicate set in sorted-dup database",
@@ -1691,7 +1691,7 @@ bad_prev:				isbad = 1;
 					goto done;
 			}
 
-			if (LF_ISSET(DB_ST_RELEN)) {
+			if (((flags) & (DB_ST_RELEN))) {
 				if (relen == 0)
 					relen = child_relen;
 				/*
@@ -1709,7 +1709,7 @@ bad_prev:				isbad = 1;
 				if (relenp)
 					*relenp = relen;
 			}
-			if (LF_ISSET(DB_ST_RECNUM)) {
+			if (((flags) & (DB_ST_RECNUM))) {
 				if (child->nrecs != child_nrecs) {
 					isbad = 1;
 					EPRINT((env, DB_STR_A("1083",
@@ -1812,7 +1812,7 @@ bad_prev:				isbad = 1;
 				goto done;
 		}
 
-		if (LF_ISSET(DB_ST_RECNUM)) {
+		if (((flags) & (DB_ST_RECNUM))) {
 			/*
 			 * Keep a running tally on the actual record count so
 			 * we can return it to our parent (if we have one) or
@@ -1845,7 +1845,7 @@ bad_prev:				isbad = 1;
 
 	if (0) {
 leaf:		level = LEAFLEVEL;
-		if (LF_ISSET(DB_ST_RECNUM))
+		if (((flags) & (DB_ST_RECNUM)))
 			nrecs = pip->rec_cnt;
 
 		/* XXX
@@ -1856,7 +1856,7 @@ leaf:		level = LEAFLEVEL;
 		 * soon, so for now we don't bother.
 		 */
 
-		if (LF_ISSET(DB_ST_RELEN) && relenp)
+		if (((flags) & (DB_ST_RELEN)) && relenp)
 			*relenp = pip->re_len;
 	}
 done:	if (F_ISSET(pip, VRFY_INCOMPLETE) && isbad == 0 && ret == 0) {
@@ -1904,7 +1904,7 @@ done:	if (F_ISSET(pip, VRFY_INCOMPLETE)
 	 * so that we can verify our place with respect to them.  If it's
 	 * appropriate--we have a default sort function--verify this.
 	 */
-	if (isbad == 0 && ret == 0 && !LF_ISSET(DB_NOORDERCHK) &&
+	if (isbad == 0 && ret == 0 && !((flags) & (DB_NOORDERCHK)) &&
 	    pip->type != P_IRECNO && pip->type != P_LRECNO) {
 		if (h == NULL && (ret = __memp_fget(mpf, &pgno,
 		    vdp->thread_info, NULL, 0, &h)) != 0)
@@ -1916,7 +1916,7 @@ done:	if (F_ISSET(pip, VRFY_INCOMPLETE)
 		 * and we use the duplicate comparison function;  otherwise,
 		 * use the btree one.  If unset, use the default, of course.
 		 */
-		func = LF_ISSET(DB_ST_DUPSET) ? dbp->dup_compare :
+		func = ((flags) & (DB_ST_DUPSET)) ? dbp->dup_compare :
 		    ((BTREE *)dbp->bt_internal)->bt_compare;
 		if (func == NULL)
 			func = __bam_defcmp;
@@ -1936,7 +1936,7 @@ done:	if (F_ISSET(pip, VRFY_INCOMPLETE)
 	 * Internal pages below the top level do not store their own
 	 * record numbers, so we skip them.
 	 */
-	if (LF_ISSET(DB_ST_RECNUM) && nrecs != pip->rec_cnt && toplevel) {
+	if (((flags) & (DB_ST_RECNUM)) && nrecs != pip->rec_cnt && toplevel) {
 		isbad = 1;
 		EPRINT((env, DB_STR_A("1089",
 		    "Page %lu: bad record count: has %lu records, claims %lu",
@@ -2176,10 +2176,10 @@ __bam_salvage(dbp, vdp, pgno, pgtype, h,
 
 #ifdef HAVE_COMPRESSION
 	memset(&kcpy, 0, sizeof(DBT));
-	unknown_dup_key = LF_ISSET(DB_SA_UNKNOWNKEY);
+	unknown_dup_key = ((flags) & (DB_SA_UNKNOWNKEY));
 	last_key = unknown_dup_key ? NULL : key;
 #endif
-	LF_CLR(DB_SA_UNKNOWNKEY);
+	((flags) &= ~(DB_SA_UNKNOWNKEY));
 
 	DB_INIT_DBT(unknown_key, "UNKNOWN_KEY", sizeof("UNKNOWN_KEY") - 1);
 	DB_INIT_DBT(unknown_data, "UNKNOWN_DATA", sizeof("UNKNOWN_DATA") - 1);
@@ -2192,7 +2192,7 @@ __bam_salvage(dbp, vdp, pgno, pgtype, h,
 		goto err;
 	ovfl_bufsz = dbp->pgsize;
 
-	if (LF_ISSET(DB_AGGRESSIVE) && (ret =
+	if (((flags) & (DB_AGGRESSIVE)) && (ret =
 	    __os_calloc(env, dbp->pgsize, sizeof(pgmap[0]), &pgmap)) != 0)
 		goto err;
 
@@ -2209,7 +2209,7 @@ __bam_salvage(dbp, vdp, pgno, pgtype, h,
 		 * If we're not aggressive, or if we're on an internal page,
 		 * break when we hit NUM_ENT(h).
 		 */
-		if ((!LF_ISSET(DB_AGGRESSIVE) ||
+		if ((!((flags) & (DB_AGGRESSIVE)) ||
 		    pgtype == P_IBTREE) && i >= NUM_ENT(h))
 			break;
 
@@ -2253,7 +2253,7 @@ __bam_salvage(dbp, vdp, pgno, pgtype, h,
 		 * We only print deleted items if DB_AGGRESSIVE is set.
 		 */
 		bk = GET_BKEYDATA(dbp, h, i);
-		if (!LF_ISSET(DB_AGGRESSIVE) && B_DISSET(bk->type))
+		if (!((flags) & (DB_AGGRESSIVE)) && B_DISSET(bk->type))
 			continue;
 
 		/*
@@ -2280,7 +2280,7 @@ __bam_salvage(dbp, vdp, pgno, pgtype, h,
 		 * first, unless DB_SA_SKIPFIRSTKEY is set and we're on the
 		 * first entry.
 		 */
-		if (key != NULL && (i != 0 || !LF_ISSET(DB_SA_SKIPFIRSTKEY))) {
+		if (key != NULL && (i != 0 || !((flags) & (DB_SA_SKIPFIRSTKEY)))) {
 #ifdef HAVE_COMPRESSION
 			last_key = unknown_dup_key ? NULL : key;
 #endif
@@ -2364,7 +2364,7 @@ __bam_salvage(dbp, vdp, pgno, pgtype, h,
 					if (t_ret == DB_VERIFY_FATAL) {
 						if (ret == 0)
 							ret = DB_VERIFY_BAD;
-						if (!LF_ISSET(DB_AGGRESSIVE))
+						if (!((flags) & (DB_AGGRESSIVE)))
 							goto err;
 					} else if (ret == 0) {
 						ret = t_ret;
@@ -2479,7 +2479,7 @@ __bam_salvage(dbp, vdp, pgno, pgtype, h,
 					if (t_ret == DB_VERIFY_FATAL) {
 						if (ret == 0)
 							ret = DB_VERIFY_BAD;
-						if (!LF_ISSET(DB_AGGRESSIVE))
+						if (!((flags) & (DB_AGGRESSIVE)))
 							goto err;
 					} else if (ret == 0) {
 						ret = t_ret;
@@ -2527,7 +2527,7 @@ __bam_salvage(dbp, vdp, pgno, pgtype, h,
 		 * the gaps in case we had any bogus inp elements and thereby
 		 * missed stuff.
 		 */
-		if (LF_ISSET(DB_AGGRESSIVE) && pgtype != P_IBTREE) {
+		if (((flags) & (DB_AGGRESSIVE)) && pgtype != P_IBTREE) {
 			pgmap[beg] = VRFY_ITEM_BEGIN;
 			pgmap[end] = VRFY_ITEM_END;
 		}
@@ -2597,7 +2597,7 @@ __bam_salvage_walkdupint(dbp, vdp, h, ke
 			    env, "__bam_salvage_walkdupint"));
 		}
 		/* Pass DB_SA_SKIPFIRSTKEY, if set, on to the 0th child only. */
-		flags &= ~LF_ISSET(DB_SA_SKIPFIRSTKEY);
+		flags &= ~((flags) & (DB_SA_SKIPFIRSTKEY));
 	}
 
 	return (ret);
diff -u -p a/db-5.2.28.NC/src/btree/bt_stat.c b/db-5.2.28.NC/src/btree/bt_stat.c
--- a/db-5.2.28.NC/src/btree/bt_stat.c
+++ b/db-5.2.28.NC/src/btree/bt_stat.c
@@ -233,10 +233,10 @@ __bam_stat_print(dbc, flags)
 			return (ret);
 	} else
 #endif
-	if ((ret = __bam_stat(dbc, &sp, LF_ISSET(DB_FAST_STAT))) != 0)
+	if ((ret = __bam_stat(dbc, &sp, ((flags) & (DB_FAST_STAT)))) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL)) {
+	if (((flags) & (DB_STAT_ALL))) {
 		__db_msg(env, "%s", DB_GLOBAL(db_line));
 		__db_msg(env, "Default Btree/Recno database information:");
 	}
diff -u -p a/db-5.2.28.NC/src/btree/bt_split.c b/db-5.2.28.NC/src/btree/bt_split.c
--- a/db-5.2.28.NC/src/btree/bt_split.c
+++ b/db-5.2.28.NC/src/btree/bt_split.c
@@ -810,7 +810,7 @@ __bam_pinsert(dbc, parent, split, lchild
 
 	/* If handling record numbers, count records split to the right page. */
 	nrecs = F_ISSET(cp, C_RECNUM) &&
-	    !LF_ISSET(BPI_SPACEONLY) ? __bam_total(dbp, rchild) : 0;
+	    !((flags) & (BPI_SPACEONLY)) ? __bam_total(dbp, rchild) : 0;
 
 	/*
 	 * Now we insert the new page's first key into the parent page, which
@@ -826,7 +826,7 @@ __bam_pinsert(dbc, parent, split, lchild
 	 * key is unavailable.
 	 */
 	off = parent->indx + O_INDX;
-	if (LF_ISSET(BPI_REPLACE))
+	if (((flags) & (BPI_REPLACE)))
 		oldsize = TYPE(ppage) == P_IRECNO ? RINTERNAL_PSIZE :
 		    BINTERNAL_PSIZE(GET_BINTERNAL(dbp, ppage, off)->len);
 	else
@@ -851,7 +851,7 @@ __bam_pinsert(dbc, parent, split, lchild
 
 		if (P_FREESPACE(dbp, ppage) + oldsize < nbytes)
 			return (DB_NEEDSPLIT);
-		if (LF_ISSET(BPI_SPACEONLY))
+		if (((flags) & (BPI_SPACEONLY)))
 			return (0);
 
 		switch (B_TYPE(child_bi->type)) {
@@ -939,7 +939,7 @@ __bam_pinsert(dbc, parent, split, lchild
 
 noprefix:		if (P_FREESPACE(dbp, ppage) + oldsize < nbytes)
 				return (DB_NEEDSPLIT);
-			if (LF_ISSET(BPI_SPACEONLY))
+			if (((flags) & (BPI_SPACEONLY)))
 				return (0);
 
 			memset(&bi, 0, sizeof(bi));
@@ -956,7 +956,7 @@ noprefix:		if (P_FREESPACE(dbp, ppage) +
 
 			if (P_FREESPACE(dbp, ppage) + oldsize < nbytes)
 				return (DB_NEEDSPLIT);
-			if (LF_ISSET(BPI_SPACEONLY))
+			if (((flags) & (BPI_SPACEONLY)))
 				return (0);
 
 			/* Copy the overflow key. */
@@ -995,7 +995,7 @@ noprefix:		if (P_FREESPACE(dbp, ppage) +
 
 		if (P_FREESPACE(dbp, ppage) + oldsize < nbytes)
 			return (DB_NEEDSPLIT);
-		if (LF_ISSET(BPI_SPACEONLY))
+		if (((flags) & (BPI_SPACEONLY)))
 			return (0);
 
 		/* Add a new record for the right page. */
@@ -1008,22 +1008,22 @@ noprefix:		if (P_FREESPACE(dbp, ppage) +
 		 * For now, we are locking internal recno nodes so
 		 * use two steps.
 		 */
-		if (LF_ISSET(BPI_REPLACE)) {
+		if (((flags) & (BPI_REPLACE))) {
 			if ((ret = __bam_ditem(dbc, ppage, off)) != 0)
 				return (ret);
-			LF_CLR(BPI_REPLACE);
+			((flags) &= ~(BPI_REPLACE));
 		}
 		break;
 	default:
 pgfmt:		return (__db_pgfmt(dbp->env, PGNO(child->page)));
 	}
 
-	if (LF_ISSET(BPI_REPLACE)) {
-		DB_ASSERT(dbp->env, !LF_ISSET(BPI_NOLOGGING));
+	if (((flags) & (BPI_REPLACE))) {
+		DB_ASSERT(dbp->env, !((flags) & (BPI_NOLOGGING)));
 		if ((ret = __bam_irep(dbc, ppage, off, &hdr, &data)) != 0)
 			return (ret);
 	} else {
-		if (LF_ISSET(BPI_NOLOGGING))
+		if (((flags) & (BPI_NOLOGGING)))
 			pitem = __db_pitem_nolog;
 		else
 			pitem = __db_pitem;
@@ -1037,7 +1037,7 @@ pgfmt:		return (__db_pgfmt(dbp->env, PGN
 	 * If a Recno or Btree with record numbers AM page, or an off-page
 	 * duplicates tree, adjust the parent page's left page record count.
 	 */
-	if (F_ISSET(cp, C_RECNUM) && !LF_ISSET(BPI_NORECNUM)) {
+	if (F_ISSET(cp, C_RECNUM) && !((flags) & (BPI_NORECNUM))) {
 		/* Log the change. */
 		if (DBC_LOGGING(dbc)) {
 			if ((ret = __bam_cadjust_log(dbp, dbc->txn,
diff -u -p a/db-5.2.28.NC/src/btree/bt_rsearch.c b/db-5.2.28.NC/src/btree/bt_rsearch.c
--- a/db-5.2.28.NC/src/btree/bt_rsearch.c
+++ b/db-5.2.28.NC/src/btree/bt_rsearch.c
@@ -123,7 +123,7 @@ __bam_rsearch(dbc, recnop, flags, stop,
 	 * a fast check now.
 	 */
 	total = RE_NREC(h);
-	if (LF_ISSET(SR_APPEND)) {
+	if (((flags) & (SR_APPEND))) {
 		*exactp = 0;
 		*recnop = recno = total + 1;
 	} else {
@@ -132,7 +132,7 @@ __bam_rsearch(dbc, recnop, flags, stop,
 			*exactp = 1;
 		else {
 			*exactp = 0;
-			if (!LF_ISSET(SR_PAST_EOF) || recno > total + 1) {
+			if (!((flags) & (SR_PAST_EOF)) || recno > total + 1) {
 				/*
 				 * Keep the page locked for serializability.
 				 *
@@ -162,13 +162,13 @@ __bam_rsearch(dbc, recnop, flags, stop,
 	for (total = 0;;) {
 		switch (TYPE(h)) {
 		case P_LBTREE:
-			if (LF_ISSET(SR_MAX)) {
+			if (((flags) & (SR_MAX))) {
 				indx = NUM_ENT(h) - 2;
 				goto enter;
 			}
 			/* FALLTHROUGH */
 		case P_LDUP:
-			if (LF_ISSET(SR_MAX)) {
+			if (((flags) & (SR_MAX))) {
 				indx = NUM_ENT(h) - 1;
 				goto enter;
 			}
@@ -187,7 +187,7 @@ __bam_rsearch(dbc, recnop, flags, stop,
 			for (t_recno = 0, indx = 0;; indx += adjust) {
 				if (indx >= NUM_ENT(h)) {
 					*exactp = 0;
-					if (!LF_ISSET(SR_PAST_EOF) ||
+					if (!((flags) & (SR_PAST_EOF)) ||
 					    recno > t_recno + 1) {
 						ret = __memp_fput(mpf,
 						    dbc->thread_info,
@@ -210,11 +210,11 @@ __bam_rsearch(dbc, recnop, flags, stop,
 			BT_STK_ENTER(env, cp, h, indx, lock, lock_mode, ret);
 			if (ret != 0)
 				goto err;
-			if (LF_ISSET(SR_BOTH))
+			if (((flags) & (SR_BOTH)))
 				goto get_prev;
 			goto done;
 		case P_IBTREE:
-			if (LF_ISSET(SR_MAX)) {
+			if (((flags) & (SR_MAX))) {
 				indx = NUM_ENT(h);
 				bi = GET_BINTERNAL(dbp, h, indx - 1);
 			} else for (indx = 0, top = NUM_ENT(h);;) {
@@ -226,7 +226,7 @@ __bam_rsearch(dbc, recnop, flags, stop,
 			pg = bi->pgno;
 			break;
 		case P_LRECNO:
-			if (LF_ISSET(SR_MAX))
+			if (((flags) & (SR_MAX)))
 				recno = NUM_ENT(h);
 			else
 				recno -= total;
@@ -236,8 +236,8 @@ __bam_rsearch(dbc, recnop, flags, stop,
 enter:			BT_STK_ENTER(env, cp, h, recno, lock, lock_mode, ret);
 			if (ret != 0)
 				goto err;
-			if (LF_ISSET(SR_BOTH)) {
-get_prev:			DB_ASSERT(env, LF_ISSET(SR_NEXT));
+			if (((flags) & (SR_BOTH))) {
+get_prev:			DB_ASSERT(env, ((flags) & (SR_NEXT)));
 				/*
 				 * We have a NEXT tree, now add the sub tree
 				 * that points gets to the previous page.
@@ -253,15 +253,15 @@ get_prev:			DB_ASSERT(env, LF_ISSET(SR_N
 					bi = GET_BINTERNAL(dbp, h, indx);
 					pg = bi->pgno;
 				}
-				LF_CLR(SR_NEXT | SR_BOTH);
-				LF_SET(SR_MAX);
+				((flags) &= ~(SR_NEXT | SR_BOTH));
+				((flags) |= (SR_MAX));
 				stack = 1;
 				h = NULL;
 				goto lock_next;
 			}
 			goto done;
 		case P_IRECNO:
-			if (LF_ISSET(SR_MAX)) {
+			if (((flags) & (SR_MAX))) {
 				indx = NUM_ENT(h);
 				ri = GET_RINTERNAL(dbp, h, indx - 1);
 			} else for (indx = 0, top = NUM_ENT(h);;) {
@@ -296,7 +296,7 @@ get_prev:			DB_ASSERT(env, LF_ISSET(SR_N
 			if ((ret =
 			    __db_lget(dbc, 0, pg, lock_mode, 0, &lock)) != 0)
 				goto err;
-		} else if (LF_ISSET(SR_NEXT)) {
+		} else if (((flags) & (SR_NEXT))) {
 			/*
 			 * For RECNO if we are doing a NEXT search the
 			 * search recno is the one we are looking for
@@ -325,7 +325,7 @@ lock_next:		if ((ret =
 			 * page in the stack.  If we do, write lock it and
 			 * never unlock it.
 			 */
-			if ((LF_ISSET(SR_PARENT) &&
+			if ((((flags) & (SR_PARENT)) &&
 			    (u_int8_t)(stop + 1) >= (u_int8_t)(LEVEL(h) - 1)) ||
 			    (LEVEL(h) - 1) == LEAFLEVEL)
 				stack = 1;
@@ -336,7 +336,7 @@ lock_next:		if ((ret =
 			h = NULL;
 
 			lock_mode = stack &&
-			    LF_ISSET(SR_WRITE) ? DB_LOCK_WRITE : DB_LOCK_READ;
+			    ((flags) & (SR_WRITE)) ? DB_LOCK_WRITE : DB_LOCK_READ;
 			if (lock_mode == DB_LOCK_WRITE)
 				get_mode = DB_MPOOL_DIRTY;
 			if ((ret = __db_lget(dbc,
diff -u -p a/db-5.2.28.NC/src/btree/bt_put.c b/db-5.2.28.NC/src/btree/bt_put.c
--- a/db-5.2.28.NC/src/btree/bt_put.c
+++ b/db-5.2.28.NC/src/btree/bt_put.c
@@ -120,7 +120,7 @@ __bam_iitem(dbc, key, data, op, flags)
 			return (__db_rec_toobig(env, data_size, t->re_len));
 
 		/* Records that are deleted anyway needn't be padded out. */
-		if (!LF_ISSET(BI_DELETED) && data_size < t->re_len) {
+		if (!((flags) & (BI_DELETED)) && data_size < t->re_len) {
 			padrec = 1;
 			data_size = t->re_len;
 		}
@@ -437,11 +437,11 @@ __bam_iitem(dbc, key, data, op, flags)
 		 * We do not have to handle deleted (BI_DELETED) records
 		 * in this case; the actual records should never be created.
 		 */
-		DB_ASSERT(env, !LF_ISSET(BI_DELETED));
+		DB_ASSERT(env, !((flags) & (BI_DELETED)));
 		ret = __bam_ovput(dbc,
 		    B_OVERFLOW, PGNO_INVALID, h, indx, data);
 	} else {
-		if (LF_ISSET(BI_DELETED)) {
+		if (((flags) & (BI_DELETED))) {
 			B_TSET_DELETED(bk_tmp.type, B_KEYDATA);
 			bk_tmp.len = data->size;
 			bk_hdr.data = &bk_tmp;
diff -u -p a/db-5.2.28.NC/src/btree/bt_delete.c b/db-5.2.28.NC/src/btree/bt_delete.c
--- a/db-5.2.28.NC/src/btree/bt_delete.c
+++ b/db-5.2.28.NC/src/btree/bt_delete.c
@@ -261,7 +261,7 @@ __bam_dpages(dbc, use_top, flags)
 	 * It will deadlock here.  Before we unlink the subtree, we relink the
 	 * leaf page chain.
 	 */
-	if (LF_ISSET(BTD_RELINK) && LEVEL(cp->csp->page) == 1 &&
+	if (((flags) & (BTD_RELINK)) && LEVEL(cp->csp->page) == 1 &&
 	    (ret = __db_relink(dbc, cp->csp->page, NULL, PGNO_INVALID)) != 0)
 		goto discard;
 
@@ -281,7 +281,7 @@ __bam_dpages(dbc, use_top, flags)
 	if ((ret = __bam_ca_di(dbc, PGNO(epg->page), epg->indx, -1)) != 0)
 		goto discard;
 
-	if (LF_ISSET(BTD_UPDATE) && epg->indx == 0) {
+	if (((flags) & (BTD_UPDATE)) && epg->indx == 0) {
 		save_sp = cp->csp;
 		cp->csp = epg;
 		ret = __bam_pupdate(dbc, epg->page);
diff -u -p a/db-5.2.28.NC/src/btree/bt_cursor.c b/db-5.2.28.NC/src/btree/bt_cursor.c
--- a/db-5.2.28.NC/src/btree/bt_cursor.c
+++ b/db-5.2.28.NC/src/btree/bt_cursor.c
@@ -1217,17 +1217,17 @@ __bam_bulk(dbc, data, flags)
 	 * next_key is set if we are going after the next key rather than dup.
 	 */
 	if (dbc->dbtype == DB_BTREE) {
-		is_key = LF_ISSET(DB_MULTIPLE_KEY) ? 1: 0;
+		is_key = ((flags) & (DB_MULTIPLE_KEY)) ? 1: 0;
 		rec_key = 0;
-		next_key = is_key && LF_ISSET(DB_OPFLAGS_MASK) != DB_NEXT_DUP;
+		next_key = is_key && ((flags) & (DB_OPFLAGS_MASK)) != DB_NEXT_DUP;
 		adj = 2;
 	} else {
 		is_key = 0;
-		rec_key = LF_ISSET(DB_MULTIPLE_KEY) ? 1 : 0;
-		next_key = LF_ISSET(DB_OPFLAGS_MASK) != DB_NEXT_DUP;
+		rec_key = ((flags) & (DB_MULTIPLE_KEY)) ? 1 : 0;
+		next_key = ((flags) & (DB_OPFLAGS_MASK)) != DB_NEXT_DUP;
 		adj = 1;
 	}
-	no_dup = LF_ISSET(DB_OPFLAGS_MASK) == DB_NEXT_NODUP;
+	no_dup = ((flags) & (DB_OPFLAGS_MASK)) == DB_NEXT_NODUP;
 
 next_pg:
 	indx = cp->indx;
diff -u -p a/db-5.2.28.NC/src/btree/bt_search.c b/db-5.2.28.NC/src/btree/bt_search.c
--- a/db-5.2.28.NC/src/btree/bt_search.c
+++ b/db-5.2.28.NC/src/btree/bt_search.c
@@ -88,11 +88,11 @@ __bam_get_root(dbc, root_pgno, slevel, f
 	 * Retrieve the root page.
 	 */
 try_again:
-	*stack = LF_ISSET(SR_STACK) &&
+	*stack = ((flags) & (SR_STACK)) &&
 	      (dbc->dbtype == DB_RECNO || F_ISSET(cp, C_RECNUM));
 	lock_mode = DB_LOCK_READ;
 	if (*stack ||
-	    LF_ISSET(SR_DEL) || (LF_ISSET(SR_NEXT) && LF_ISSET(SR_WRITE)))
+	    ((flags) & (SR_DEL)) || (((flags) & (SR_NEXT)) && ((flags) & (SR_WRITE))))
 		lock_mode = DB_LOCK_WRITE;
 
 	/*
@@ -133,9 +133,9 @@ retry:	if (lock_mode == DB_LOCK_WRITE)
 	 * We must not hold the latch while we get the lock.
 	 */
 	if (!*stack &&
-	    ((LF_ISSET(SR_PARENT) && (u_int8_t)(slevel + 1) >= LEVEL(h)) ||
+	    ((((flags) & (SR_PARENT)) && (u_int8_t)(slevel + 1) >= LEVEL(h)) ||
 	    LEVEL(h) == LEAFLEVEL ||
-	    (LF_ISSET(SR_START) && slevel == LEVEL(h)))) {
+	    (((flags) & (SR_START)) && slevel == LEVEL(h)))) {
 		*stack = 1;
 		/* If we already have the write lock, we are done. */
 		if (dbc->dbtype == DB_RECNO || F_ISSET(cp, C_RECNUM)) {
@@ -150,7 +150,7 @@ retry:	if (lock_mode == DB_LOCK_WRITE)
 		 * write lock?  If not or we got the lock before latching
 		 * we are done.
 		 */
-		if (LEVEL(h) != LEAFLEVEL || LF_ISSET(SR_WRITE)) {
+		if (LEVEL(h) != LEAFLEVEL || ((flags) & (SR_WRITE))) {
 			lock_mode = DB_LOCK_WRITE;
 			/* Drop the read lock if we got it above. */
 			if ((ret = __LPUT(dbc, lock)) != 0)
@@ -216,10 +216,10 @@ retry:	if (lock_mode == DB_LOCK_WRITE)
 		 * While getting dirty or locked we need to drop the mutex
 		 * so someone else could get in and split the root.
 		 */
-		if (!((LF_ISSET(SR_PARENT) &&
+		if (!((((flags) & (SR_PARENT)) &&
 		    (u_int8_t)(slevel + 1) >= LEVEL(h)) ||
 		    LEVEL(h) == LEAFLEVEL ||
-		    (LF_ISSET(SR_START) && slevel == LEVEL(h)))) {
+		    (((flags) & (SR_START)) && slevel == LEVEL(h)))) {
 			/* Someone else split the root, start over. */
 			ret = __memp_fput(mpf,
 			    dbc->thread_info, h, dbc->priority);
@@ -292,7 +292,7 @@ __bam_search(dbc, root_pgno, key, flags,
 	BT_STK_CLR(cp);
 	LOCK_INIT(saved_lock);
 	LOCK_INIT(lock);
-	was_next = LF_ISSET(SR_NEXT);
+	was_next = ((flags) & (SR_NEXT));
 	wait = DB_LOCK_NOWAIT;
 
 	/*
@@ -327,14 +327,14 @@ retry:	if ((ret = __bam_get_root(dbc, st
 	} else
 		getlock = F_ISSET(cp, C_RECNUM) ||
 		   (lock_mode == DB_LOCK_WRITE &&
-		   (stack || LF_ISSET(SR_NEXT | SR_DEL)));
+		   (stack || ((flags) & (SR_NEXT | SR_DEL))));
 
 	/*
 	 * If we are asked a level that is above the root,
 	 * just return the root.  This can happen if the tree
 	 * collapses while we are trying to lock the root.
 	 */
-	if (!LF_ISSET(SR_START) && LEVEL(h) < slevel)
+	if (!((flags) & (SR_START)) && LEVEL(h) < slevel)
 		goto done;
 
 	BT_STK_CLR(cp);
@@ -365,8 +365,8 @@ retry:	if ((ret = __bam_get_root(dbc, st
 			adjust = O_INDX;
 		}
 		inp = P_INP(dbp, h);
-		if (LF_ISSET(SR_MIN | SR_MAX)) {
-			if (LF_ISSET(SR_MIN) || NUM_ENT(h) == 0)
+		if (((flags) & (SR_MIN | SR_MAX))) {
+			if (((flags) & (SR_MIN)) || NUM_ENT(h) == 0)
 				indx = 0;
 			else if (TYPE(h) == P_LBTREE)
 				indx = NUM_ENT(h) - 2;
@@ -374,8 +374,8 @@ retry:	if ((ret = __bam_get_root(dbc, st
 				indx = NUM_ENT(h) - 1;
 
 			if (LEVEL(h) == LEAFLEVEL ||
-			     (!LF_ISSET(SR_START) && LEVEL(h) == slevel)) {
-				if (LF_ISSET(SR_NEXT))
+			     (!((flags) & (SR_START)) && LEVEL(h) == slevel)) {
+				if (((flags) & (SR_NEXT)))
 					goto get_next;
 				goto found;
 			}
@@ -395,9 +395,9 @@ retry:	if ((ret = __bam_get_root(dbc, st
 				goto err;
 			if (cmp == 0) {
 				if (LEVEL(h) == LEAFLEVEL ||
-				    (!LF_ISSET(SR_START) &&
+				    (!((flags) & (SR_START)) &&
 				    LEVEL(h) == slevel)) {
-					if (LF_ISSET(SR_NEXT))
+					if (((flags) & (SR_NEXT)))
 						goto get_next;
 					goto found;
 				}
@@ -417,15 +417,15 @@ retry:	if ((ret = __bam_get_root(dbc, st
 		 * Delete only deletes exact matches.
 		 */
 		if (LEVEL(h) == LEAFLEVEL ||
-		    (!LF_ISSET(SR_START) && LEVEL(h) == slevel)) {
+		    (!((flags) & (SR_START)) && LEVEL(h) == slevel)) {
 			*exactp = 0;
 
-			if (LF_ISSET(SR_EXACT)) {
+			if (((flags) & (SR_EXACT))) {
 				ret = DB_NOTFOUND;
 				goto err;
 			}
 
-			if (LF_ISSET(SR_STK_ONLY)) {
+			if (((flags) & (SR_STK_ONLY))) {
 				BT_STK_NUM(env, cp, h, base, ret);
 				if ((t_ret =
 				    __LPUT(dbc, lock)) != 0 && ret == 0)
@@ -438,7 +438,7 @@ retry:	if ((ret = __bam_get_root(dbc, st
 					goto err;
 				goto done;
 			}
-			if (LF_ISSET(SR_NEXT)) {
+			if (((flags) & (SR_NEXT))) {
 get_next:			/*
 				 * The caller could have asked for a NEXT
 				 * at the root if the tree recently collapsed.
@@ -462,10 +462,10 @@ get_next:			/*
 				 * Search down again starting at the
 				 * next child of the root of this subtree.
 				 */
-				LF_SET(SR_MIN);
-				LF_CLR(SR_NEXT);
+				((flags) |= (SR_MIN));
+				((flags) &= ~(SR_NEXT));
 				set_stack = stack = 1;
-				if (LF_ISSET(SR_BOTH)) {
+				if (((flags) & (SR_BOTH))) {
 					cp->csp++;
 					BT_STK_PUSH(env,
 					    cp, h, indx, lock, lock_mode, ret);
@@ -503,7 +503,7 @@ get_next:			/*
 			 * to find an undeleted record.  This is handled by the
 			 * calling routine.
 			 */
-			if (LF_ISSET(SR_DEL) && cp->csp == cp->sp)
+			if (((flags) & (SR_DEL)) && cp->csp == cp->sp)
 				cp->csp++;
 			BT_STK_ENTER(env, cp, h, base, lock, lock_mode, ret);
 			if (ret != 0)
@@ -531,10 +531,10 @@ next:		if (recnop != NULL)
 		level = LEVEL(h);
 
 		/* See if we are at the level to start stacking. */
-		if (LF_ISSET(SR_START) && slevel == level)
+		if (((flags) & (SR_START)) && slevel == level)
 			set_stack = stack = 1;
 
-		if (LF_ISSET(SR_STK_ONLY)) {
+		if (((flags) & (SR_STK_ONLY))) {
 			if (slevel == LEVEL(h)) {
 				BT_STK_NUM(env, cp, h, indx, ret);
 				if ((t_ret = __memp_fput(mpf, dbc->thread_info,
@@ -551,14 +551,14 @@ next:		if (recnop != NULL)
 			h = NULL;
 		} else if (stack) {
 			/* Return if this is the lowest page wanted. */
-			if (LF_ISSET(SR_PARENT) && slevel == level) {
+			if (((flags) & (SR_PARENT)) && slevel == level) {
 				BT_STK_ENTER(env,
 				    cp, h, indx, lock, lock_mode, ret);
 				if (ret != 0)
 					goto err;
 				goto done;
 			}
-			if (LF_ISSET(SR_DEL) && NUM_ENT(h) > 1) {
+			if (((flags) & (SR_DEL)) && NUM_ENT(h) > 1) {
 				/*
 				 * There was a page with a singleton pointer
 				 * to a non-empty subtree.
@@ -588,7 +588,7 @@ next:		if (recnop != NULL)
 			 * set until we leave this clause. If we are locking
 			 * then we must lock this level before getting the page.
 			 */
-			if ((LF_ISSET(SR_PARENT) &&
+			if ((((flags) & (SR_PARENT)) &&
 			    (u_int8_t)(slevel + 1) >= (level - 1)) ||
 			    (level - 1) == LEAFLEVEL)
 				set_stack = 1;
@@ -597,7 +597,7 @@ next:		if (recnop != NULL)
 			 * Check for a normal search.  If so, we need to
 			 * latch couple the parent/chid buffers.
 			 */
-			if (!LF_ISSET(SR_DEL | SR_NEXT)) {
+			if (!((flags) & (SR_DEL | SR_NEXT))) {
 				parent_h = h;
 				goto lock_next;
 			}
@@ -615,14 +615,14 @@ next:		if (recnop != NULL)
 			 * edge, then drop the subtree.
 			 */
 
-			if ((LF_ISSET(SR_DEL) && NUM_ENT(h) == 1)) {
+			if ((((flags) & (SR_DEL)) && NUM_ENT(h) == 1)) {
 				/*
 				 * We are pushing the things on the stack,
 				 * set the stack variable now to indicate this
 				 * has happened.
 				 */
 				stack = set_stack = 1;
-				LF_SET(SR_WRITE);
+				((flags) |= (SR_WRITE));
 				/* Push the parent. */
 				cp->csp++;
 				/* Push this node. */
@@ -642,7 +642,7 @@ next:		if (recnop != NULL)
 			 * we find a singleton.
 			 */
 do_del:				if (cp->csp->page != NULL) {
-					if (LF_ISSET(SR_NEXT) &&
+					if (((flags) & (SR_NEXT)) &&
 					     indx == NUM_ENT(h) - 1)
 						cp->csp++;
 					else if ((ret =
@@ -659,7 +659,7 @@ do_del:				if (cp->csp->page != NULL) {
 
 lock_next:		h = NULL;
 
-			if (set_stack && LF_ISSET(SR_WRITE)) {
+			if (set_stack && ((flags) & (SR_WRITE))) {
 				lock_mode = DB_LOCK_WRITE;
 				get_mode = DB_MPOOL_DIRTY;
 				getlock = 1;
@@ -687,7 +687,7 @@ lock_next:		h = NULL;
 				 * have an extra level saved in the stack,
 				 * push it so it will get freed.
 				 */
-				if (LF_ISSET(SR_DEL | SR_NEXT) && !stack)
+				if (((flags) & (SR_DEL | SR_NEXT)) && !stack)
 					cp->csp++;
 				PERFMON6(env, race, bam_search, dbp->fname,
 				    dbp->dname, ret, h, parent_h, flags);
@@ -786,8 +786,8 @@ drop_lock:				ret = __LPUT(dbc, saved_lo
 				h = NULL;
 
 				if (was_next) {
-					LF_CLR(SR_MIN);
-					LF_SET(SR_NEXT);
+					((flags) &= ~(SR_MIN));
+					((flags) |= (SR_NEXT));
 				}
 				/*
 				 * We have the lock but we dropped the
@@ -827,11 +827,11 @@ found:	*exactp = 1;
 	 * single leaf page.
 	 */
 	if (TYPE(h) == P_LBTREE && NUM_ENT(h) > P_INDX) {
-		if (LF_ISSET(SR_DUPLAST))
+		if (((flags) & (SR_DUPLAST)))
 			while (indx < (db_indx_t)(NUM_ENT(h) - P_INDX) &&
 			    inp[indx] == inp[indx + P_INDX])
 				indx += P_INDX;
-		else if (LF_ISSET(SR_DUPFIRST))
+		else if (((flags) & (SR_DUPFIRST)))
 			while (indx > 0 &&
 			    inp[indx] == inp[indx - P_INDX])
 				indx -= P_INDX;
@@ -843,10 +843,10 @@ found:	*exactp = 1;
 	 * not move from the original found key on the basis of the SR_DELNO
 	 * flag.)
 	 */
-	DB_ASSERT(env, recnop == NULL || LF_ISSET(SR_DELNO));
-	if (LF_ISSET(SR_DELNO)) {
+	DB_ASSERT(env, recnop == NULL || ((flags) & (SR_DELNO)));
+	if (((flags) & (SR_DELNO))) {
 		deloffset = TYPE(h) == P_LBTREE ? O_INDX : 0;
-		if (LF_ISSET(SR_DUPLAST))
+		if (((flags) & (SR_DUPLAST)))
 			while (B_DISSET(GET_BKEYDATA(dbp,
 			    h, indx + deloffset)->type) && indx > 0 &&
 			    inp[indx] == inp[indx - adjust])
@@ -886,14 +886,14 @@ found:	*exactp = 1;
 		}
 	}
 
-	if (LF_ISSET(SR_STK_ONLY)) {
+	if (((flags) & (SR_STK_ONLY))) {
 		BT_STK_NUM(env, cp, h, indx, ret);
 		if ((t_ret = __memp_fput(mpf,
 		     dbc->thread_info, h, dbc->priority)) != 0 && ret == 0)
 			ret = t_ret;
 		h = NULL;
 	} else {
-		if (LF_ISSET(SR_DEL) && cp->csp == cp->sp)
+		if (((flags) & (SR_DEL)) && cp->csp == cp->sp)
 			cp->csp++;
 		BT_STK_ENTER(env, cp, h, indx, lock, lock_mode, ret);
 	}
@@ -966,7 +966,7 @@ __bam_stkrel(dbc, flags)
 	 */
 	for (ret = 0, epg = cp->sp; epg <= cp->csp; ++epg) {
 		if (epg->page != NULL) {
-			if (LF_ISSET(STK_CLRDBC) && cp->page == epg->page) {
+			if (((flags) & (STK_CLRDBC)) && cp->page == epg->page) {
 				cp->page = NULL;
 				LOCK_INIT(cp->lock);
 			}
@@ -980,9 +980,9 @@ __bam_stkrel(dbc, flags)
 		 * but are not logically ready to have the pages
 		 * visible.
 		 */
-		if (LF_ISSET(STK_PGONLY))
+		if (((flags) & (STK_PGONLY)))
 			continue;
-		if (LF_ISSET(STK_NOLOCK) &&
+		if (((flags) & (STK_NOLOCK)) &&
 		    (epg->lock.mode == DB_LOCK_READ ||
 		    atomic_read(&mpf->mfp->multiversion) == 0)) {
 			if ((t_ret = __LPUT(dbc, epg->lock)) != 0 && ret == 0)
@@ -993,7 +993,7 @@ __bam_stkrel(dbc, flags)
 	}
 
 	/* Clear the stack, all pages have been released. */
-	if (!LF_ISSET(STK_PGONLY))
+	if (!((flags) & (STK_PGONLY)))
 		BT_STK_CLR(cp);
 
 	return (ret);
diff -u -p a/db-5.2.28.NC/src/btree/bt_compress.c b/db-5.2.28.NC/src/btree/bt_compress.c
--- a/db-5.2.28.NC/src/btree/bt_compress.c
+++ b/db-5.2.28.NC/src/btree/bt_compress.c
@@ -2268,8 +2268,8 @@ __bamc_compress_iput(dbc, key, data, fla
 	memset(&pdata, 0, sizeof(DBT));
 	memset(&empty, 0, sizeof(DBT));
 
-	multi = LF_ISSET(DB_MULTIPLE|DB_MULTIPLE_KEY);
-	LF_CLR(DB_MULTIPLE|DB_MULTIPLE_KEY);
+	multi = ((flags) & (DB_MULTIPLE | DB_MULTIPLE_KEY));
+	((flags) &= ~(DB_MULTIPLE | DB_MULTIPLE_KEY));
 
 	switch (flags) {
 	case DB_CURRENT:
diff -u -p a/db-5.2.28.NC/src/btree/bt_method.c b/db-5.2.28.NC/src/btree/bt_method.c
--- a/db-5.2.28.NC/src/btree/bt_method.c
+++ b/db-5.2.28.NC/src/btree/bt_method.c
@@ -167,41 +167,41 @@ __bam_set_flags(dbp, flagsp)
 	t = dbp->bt_internal;
 
 	flags = *flagsp;
-	if (LF_ISSET(DB_DUP | DB_DUPSORT | DB_RECNUM | DB_REVSPLITOFF))
+	if (((flags) & (DB_DUP | DB_DUPSORT | DB_RECNUM | DB_REVSPLITOFF)))
 		DB_ILLEGAL_AFTER_OPEN(dbp, "DB->set_flags");
 
 	/*
 	 * The DB_DUP and DB_DUPSORT flags are shared by the Hash
 	 * and Btree access methods.
 	 */
-	if (LF_ISSET(DB_DUP | DB_DUPSORT))
+	if (((flags) & (DB_DUP | DB_DUPSORT)))
 		DB_ILLEGAL_METHOD(dbp, DB_OK_BTREE | DB_OK_HASH);
 
-	if (LF_ISSET(DB_RECNUM | DB_REVSPLITOFF))
+	if (((flags) & (DB_RECNUM | DB_REVSPLITOFF)))
 		DB_ILLEGAL_METHOD(dbp, DB_OK_BTREE | DB_OK_HASH);
 
 	/* DB_DUP/DB_DUPSORT is incompatible with DB_RECNUM. */
-	if (LF_ISSET(DB_DUP | DB_DUPSORT) && F_ISSET(dbp, DB_AM_RECNUM))
+	if (((flags) & (DB_DUP | DB_DUPSORT)) && F_ISSET(dbp, DB_AM_RECNUM))
 		goto incompat;
 
 	/* DB_RECNUM is incompatible with DB_DUP/DB_DUPSORT. */
-	if (LF_ISSET(DB_RECNUM) && F_ISSET(dbp, DB_AM_DUP))
+	if (((flags) & (DB_RECNUM)) && F_ISSET(dbp, DB_AM_DUP))
 		goto incompat;
 
 	/* DB_RECNUM is incompatible with DB_DUP/DB_DUPSORT. */
-	if (LF_ISSET(DB_RECNUM) && LF_ISSET(DB_DUP | DB_DUPSORT))
+	if (((flags) & (DB_RECNUM)) && ((flags) & (DB_DUP | DB_DUPSORT)))
 		goto incompat;
 
 #ifdef HAVE_COMPRESSION
 	/* DB_RECNUM is incompatible with compression */
-	if (LF_ISSET(DB_RECNUM) && DB_IS_COMPRESSED(dbp)) {
+	if (((flags) & (DB_RECNUM)) && DB_IS_COMPRESSED(dbp)) {
 		__db_errx(dbp->env, DB_STR("1024",
 		    "DB_RECNUM cannot be used with compression"));
 		return (EINVAL);
 	}
 
 	/* DB_DUP without DB_DUPSORT is incompatible with compression */
-	if (LF_ISSET(DB_DUP) && !LF_ISSET(DB_DUPSORT) &&
+	if (((flags) & (DB_DUP)) && !((flags) & (DB_DUPSORT)) &&
 		!F_ISSET(dbp, DB_AM_DUPSORT) && DB_IS_COMPRESSED(dbp)) {
 		__db_errx(dbp->env, DB_STR("1025",
 	    "DB_DUP cannot be used with compression without DB_DUPSORT"));
@@ -209,7 +209,7 @@ __bam_set_flags(dbp, flagsp)
 	}
 #endif
 
-	if (LF_ISSET(DB_DUPSORT) && dbp->dup_compare == NULL) {
+	if (((flags) & (DB_DUPSORT)) && dbp->dup_compare == NULL) {
 #ifdef HAVE_COMPRESSION
 		if (DB_IS_COMPRESSED(dbp)) {
 			dbp->dup_compare = __bam_compress_dupcmp;
@@ -531,7 +531,7 @@ __ram_set_flags(dbp, flagsp)
 	u_int32_t flags;
 
 	flags = *flagsp;
-	if (LF_ISSET(DB_RENUMBER | DB_SNAPSHOT)) {
+	if (((flags) & (DB_RENUMBER | DB_SNAPSHOT))) {
 		DB_ILLEGAL_AFTER_OPEN(dbp, "DB->set_flags");
 		DB_ILLEGAL_METHOD(dbp, DB_OK_RECNO);
 	}
lock on line 40 in file ../bd-orig/db-5.2.28.NC/src/btree/bt_curadj.c has no unlock
MLOCK ( dbp -> env , dbp -> mutex )
lock on line 43 in file ../bd-orig/db-5.2.28.NC/src/btree/bt_curadj.c has no unlock
MLOCK ( dbp -> env , dbp -> mutex )
unlock on line 38 in file ../bd-orig/db-5.2.28.NC/src/btree/bt_curadj.c has no lock
unlock on line 39 in file ../bd-orig/db-5.2.28.NC/src/btree/bt_curadj.c has no lock
diff -u -p a/db-5.2.28.NC/src/btree/bt_curadj.c b/db-5.2.28.NC/src/btree/bt_curadj.c
--- a/db-5.2.28.NC/src/btree/bt_curadj.c
+++ b/db-5.2.28.NC/src/btree/bt_curadj.c
@@ -138,8 +138,10 @@ __bam_ca_delete(dbp, pgno, indx, del, co
 	 * list of DBs and then the list of cursors in each DB.
 	 */
 	if ((ret = __db_walk_cursors(dbp, NULL,
-	    __bam_ca_delete_func, &count, pgno, indx, &del)) != 0)
-		return (ret);
+	    __bam_ca_delete_func, &count, pgno, indx, &del)) != 0) {
+		
+			return (ret);
+		}
 
 	if (countp != NULL)
 		*countp = count;
@@ -181,8 +183,10 @@ __ram_ca_delete(dbp, root_pgno, foundp)
 	int ret;
 
 	if ((ret = __db_walk_cursors(dbp, NULL, __ram_ca_delete_func,
-	    foundp, root_pgno, 0, NULL)) != 0 && ret != EEXIST)
-		return (ret);
+	    foundp, root_pgno, 0, NULL)) != 0 && ret != EEXIST) {
+		
+			return (ret);
+		}
 
 	return (0);
 }
@@ -203,8 +207,10 @@ __bam_ca_di_func(dbc, my_dbc, foundp, pg
 	DBC_INTERNAL *cp;
 	struct __bam_ca_di_args *args;
 
-	if (dbc->dbtype == DB_RECNO)
-		return (0);
+	if (dbc->dbtype == DB_RECNO) {
+		
+			return (0);
+		}
 
 	cp = dbc->internal;
 	args = vargs;
@@ -249,13 +255,17 @@ __bam_ca_di(my_dbc, pgno, indx, adjust)
 	 * Adjust the cursors.  See the comment in __bam_ca_delete().
 	 */
 	if ((ret = __db_walk_cursors(dbp, my_dbc, __bam_ca_di_func,
-	    &found, pgno, indx, &args)) != 0)
-		return (ret);
+	    &found, pgno, indx, &args)) != 0) {
+		
+			return (ret);
+		}
 
 	if (found != 0 && DBC_LOGGING(my_dbc)) {
 		if ((ret = __bam_curadj_log(dbp, my_dbc->txn, &lsn, 0,
-		    DB_CA_DI, pgno, 0, 0, (u_int32_t)adjust, indx, 0)) != 0)
-			return (ret);
+		    DB_CA_DI, pgno, 0, 0, (u_int32_t)adjust, indx, 0)) != 0) {
+			
+				return (ret);
+			}
 	}
 
 	return (0);
@@ -288,8 +298,10 @@ __bam_opd_cursor(dbp, dbc, first, tpgno,
 	 * will do, assert this.
 	 */
 	DB_ASSERT(dbp->env, orig_cp->opd == NULL);
-	if ((ret = __dbc_newopd(dbc, tpgno, orig_cp->opd, &dbc_nopd)) != 0)
-		return (ret);
+	if ((ret = __dbc_newopd(dbc, tpgno, orig_cp->opd, &dbc_nopd)) != 0) {
+		
+			return (ret);
+		}
 
 	cp = (BTREE_CURSOR *)dbc_nopd->internal;
 	cp->pgno = tpgno;
@@ -346,22 +358,26 @@ __bam_ca_dup_func(dbc, my_dbc, foundp, f
 	 * converted.
 	 */
 	orig_cp = (BTREE_CURSOR *)dbc->internal;
-	if (orig_cp->opd != NULL)
-		return (0);
+	if (orig_cp->opd != NULL) {
+		
+			return (0);
+		}
 
 	/* Find cursors pointing to this record. */
 	if (orig_cp->pgno != fpgno || orig_cp->indx != fi ||
-	    MVCC_SKIP_CURADJ(dbc, fpgno))
-		return (0);
+	    MVCC_SKIP_CURADJ(dbc, fpgno)) {
+		
+			return (0);
+		}
 
 	dbp = dbc->dbp;
 	args = vargs;
 
-	MUTEX_UNLOCK(dbp->env, dbp->mutex);
+	liblock_unlock_in_cs(MLOCK(dbp->env, dbp->mutex));
 
 	if ((ret = __bam_opd_cursor(dbp,
 	    dbc, args->first, args->tpgno, args->ti)) != 0) {
-		MUTEX_LOCK(dbp->env, dbp->mutex);
+		liblock_relock_in_cs(MLOCK(dbp->env, dbp->mutex));
 		return (ret);
 	}
 	if (args->my_txn != NULL && args->my_txn != dbc->txn)
@@ -398,8 +414,10 @@ __bam_ca_dup(my_dbc, first, fpgno, fi, t
 	args.my_txn = IS_SUBTRANSACTION(my_dbc->txn) ? my_dbc->txn : NULL;
 
 	if ((ret = __db_walk_cursors(dbp,
-	    my_dbc, __bam_ca_dup_func, &found, fpgno, fi, &args)) != 0)
-		return (ret);
+	    my_dbc, __bam_ca_dup_func, &found, fpgno, fi, &args)) != 0) {
+		
+			return (ret);
+		}
 
 	if (found != 0 && DBC_LOGGING(my_dbc)) {
 		if ((t_ret = __bam_curadj_log(dbp, my_dbc->txn,
@@ -442,11 +460,13 @@ __bam_ca_undodup_func(dbc, my_dbc, count
 	    orig_cp->indx != args->first ||
 	    orig_cp->opd == NULL || ((BTREE_CURSOR *)
 	    orig_cp->opd->internal)->indx != args->ti ||
-	    MVCC_SKIP_CURADJ(dbc, fpgno))
-		return (0);
-	MUTEX_UNLOCK(dbp->env, dbp->mutex);
+	    MVCC_SKIP_CURADJ(dbc, fpgno)) {
+		
+			return (0);
+		}
+	liblock_unlock_in_cs(MLOCK(dbp->env, dbp->mutex));
 	if ((ret = __dbc_close(orig_cp->opd)) != 0) {
-		MUTEX_LOCK(dbp->env, dbp->mutex);
+		liblock_relock_in_cs(MLOCK(dbp->env, dbp->mutex));
 		return (ret);
 	}
 	orig_cp->opd = NULL;
@@ -496,8 +516,10 @@ __bam_ca_rsplit_func(dbc, my_dbc, foundp
 
 	COMPQUIET(indx, 0);
 
-	if (dbc->dbtype == DB_RECNO)
-		return (0);
+	if (dbc->dbtype == DB_RECNO) {
+		
+			return (0);
+		}
 
 	tpgno = *(db_pgno_t *)args;
 	if (dbc->internal->pgno == fpgno &&
@@ -532,13 +554,17 @@ __bam_ca_rsplit(my_dbc, fpgno, tpgno)
 	dbp = my_dbc->dbp;
 
 	if ((ret = __db_walk_cursors(dbp, my_dbc,
-	    __bam_ca_rsplit_func, &found, fpgno, 0, &tpgno)) != 0)
-		return (ret);
+	    __bam_ca_rsplit_func, &found, fpgno, 0, &tpgno)) != 0) {
+		
+			return (ret);
+		}
 
 	if (found != 0 && DBC_LOGGING(my_dbc)) {
 		if ((ret = __bam_curadj_log(dbp, my_dbc->txn,
-		    &lsn, 0, DB_CA_RSPLIT, fpgno, tpgno, 0, 0, 0, 0)) != 0)
-			return (ret);
+		    &lsn, 0, DB_CA_RSPLIT, fpgno, tpgno, 0, 0, 0, 0)) != 0) {
+			
+				return (ret);
+			}
 	}
 	return (0);
 }
@@ -563,8 +589,10 @@ __bam_ca_split_func(dbc, my_dbc, foundp,
 
 	COMPQUIET(my_dbc, NULL);
 
-	if (dbc->dbtype == DB_RECNO)
-		return (0);
+	if (dbc->dbtype == DB_RECNO) {
+		
+			return (0);
+		}
 	cp = dbc->internal;
 	args = vargs;
 	if (cp->pgno == ppgno &&
@@ -621,14 +649,18 @@ __bam_ca_split(my_dbc, ppgno, lpgno, rpg
 	args.cleft = cleft;
 	args.my_txn = IS_SUBTRANSACTION(my_dbc->txn) ? my_dbc->txn : NULL;
 	if ((ret = __db_walk_cursors(dbp, my_dbc,
-	    __bam_ca_split_func, &found, ppgno, split_indx, &args)) != 0)
-		return (ret);
+	    __bam_ca_split_func, &found, ppgno, split_indx, &args)) != 0) {
+		
+			return (ret);
+		}
 
 	if (found != 0 && DBC_LOGGING(my_dbc)) {
 		if ((ret = __bam_curadj_log(dbp,
 		    my_dbc->txn, &lsn, 0, DB_CA_SPLIT, ppgno, rpgno,
-		    cleft ? lpgno : PGNO_INVALID, 0, split_indx, 0)) != 0)
-			return (ret);
+		    cleft ? lpgno : PGNO_INVALID, 0, split_indx, 0)) != 0) {
+			
+				return (ret);
+			}
 	}
 
 	return (0);
@@ -649,8 +681,10 @@ __bam_ca_undosplit_func(dbc, my_dbc, fou
 	COMPQUIET(my_dbc, NULL);
 	COMPQUIET(foundp, NULL);
 
-	if (dbc->dbtype == DB_RECNO)
-		return (0);
+	if (dbc->dbtype == DB_RECNO) {
+		
+			return (0);
+		}
 	cp = dbc->internal;
 	args = vargs;
 	if (cp->pgno == args->rpgno &&
diff -u -p a/db-5.2.28.NC/src/os/os_handle.c b/db-5.2.28.NC/src/os/os_handle.c
--- a/db-5.2.28.NC/src/os/os_handle.c
+++ b/db-5.2.28.NC/src/os/os_handle.c
@@ -72,7 +72,7 @@ __os_openhandle(env, name, flags, mode,
 		 * file.  If successful, and O_EXCL return EEXIST.  If
 		 * unsuccessful call creat and then end single threading.
 		 */
-		if (LF_ISSET(O_CREAT)) {
+		if (((flags) & (O_CREAT))) {
 			DB_BEGIN_SINGLE_THREAD;
 			newflags = flags & ~(O_CREAT | O_EXCL);
 			if ((fhp->fd = open(name, newflags, mode)) != -1) {
@@ -83,7 +83,7 @@ __os_openhandle(env, name, flags, mode,
 				 * opened on the error path.
 				 */
 				F_SET(fhp, DB_FH_OPENED);
-				if (LF_ISSET(O_EXCL)) {
+				if (((flags) & (O_EXCL))) {
 					/*
 					 * If we get here, want O_EXCL create,
 					 * and the file exists.  Close and
diff -u -p a/db-5.2.28.NC/src/os/os_tmpdir.c b/db-5.2.28.NC/src/os/os_tmpdir.c
--- a/db-5.2.28.NC/src/os/os_tmpdir.c
+++ b/db-5.2.28.NC/src/os/os_tmpdir.c
@@ -37,8 +37,8 @@ __os_tmpdir(env, flags)
 	dbenv = env->dbenv;
 
 	/* Use the environment if it's permitted and initialized. */
-	if (LF_ISSET(DB_USE_ENVIRON) ||
-	    (LF_ISSET(DB_USE_ENVIRON_ROOT) && __os_isroot())) {
+	if (((flags) & (DB_USE_ENVIRON)) ||
+	    (((flags) & (DB_USE_ENVIRON_ROOT)) && __os_isroot())) {
 		/* POSIX: TMPDIR */
 		tdir = tdir_buf;
 		if ((ret = __os_getenv(
diff -u -p a/db-5.2.28.NC/src/os/os_open.c b/db-5.2.28.NC/src/os/os_open.c
--- a/db-5.2.28.NC/src/os/os_open.c
+++ b/db-5.2.28.NC/src/os/os_open.c
@@ -63,27 +63,27 @@ __os_open(env, name, page_size, flags, m
 	 * same time with DB_OSO_CREATE/O_CREAT and DB_OSO_EXCL/O_EXCL flags
 	 * set return an EEXIST failure in at least one.
 	 */
-	if (LF_ISSET(DB_OSO_CREATE))
+	if (((flags) & (DB_OSO_CREATE)))
 		oflags |= O_CREAT;
 
-	if (LF_ISSET(DB_OSO_EXCL))
+	if (((flags) & (DB_OSO_EXCL)))
 		oflags |= O_EXCL;
 
 #ifdef HAVE_O_DIRECT
-	if (LF_ISSET(DB_OSO_DIRECT))
+	if (((flags) & (DB_OSO_DIRECT)))
 		oflags |= O_DIRECT;
 #endif
 #ifdef O_DSYNC
-	if (LF_ISSET(DB_OSO_DSYNC))
+	if (((flags) & (DB_OSO_DSYNC)))
 		oflags |= O_DSYNC;
 #endif
 
-	if (LF_ISSET(DB_OSO_RDONLY))
+	if (((flags) & (DB_OSO_RDONLY)))
 		oflags |= O_RDONLY;
 	else
 		oflags |= O_RDWR;
 
-	if (LF_ISSET(DB_OSO_TRUNC))
+	if (((flags) & (DB_OSO_TRUNC)))
 		oflags |= O_TRUNC;
 
 	/*
@@ -91,13 +91,13 @@ __os_open(env, name, page_size, flags, m
 	 * directories whenever a file is opened.
 	 */
 	if (dbenv != NULL &&
-	    env->dir_mode != 0 && LF_ISSET(DB_OSO_CREATE) &&
+	    env->dir_mode != 0 && ((flags) & (DB_OSO_CREATE)) &&
 	    (ret = __db_mkpath(env, name)) != 0)
 		return (ret);
 
 	/* Open the file. */
 #ifdef HAVE_QNX
-	if (LF_ISSET(DB_OSO_REGION))
+	if (((flags) & (DB_OSO_REGION)))
 		ret = __os_qnx_region_open(env, name, oflags, mode, &fhp);
 	else
 #endif
@@ -105,7 +105,7 @@ __os_open(env, name, page_size, flags, m
 	if (ret != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_OSO_REGION))
+	if (((flags) & (DB_OSO_REGION)))
 		F_SET(fhp, DB_FH_REGION);
 #ifdef HAVE_FCHMOD
 	/*
@@ -116,7 +116,7 @@ __os_open(env, name, page_size, flags, m
 	 * process may be multi-threaded and the umask value is per-process, not
 	 * per-thread.
 	 */
-	if (LF_ISSET(DB_OSO_CREATE) && LF_ISSET(DB_OSO_ABSMODE))
+	if (((flags) & (DB_OSO_CREATE)) && ((flags) & (DB_OSO_ABSMODE)))
 		(void)fchmod(fhp->fd, mode);
 #endif
 
@@ -125,7 +125,7 @@ __os_open(env, name, page_size, flags, m
 	 * If we can configure the file descriptor to flush on write, the
 	 * file descriptor does not need to be explicitly sync'd.
 	 */
-	if (LF_ISSET(DB_OSO_DSYNC))
+	if (((flags) & (DB_OSO_DSYNC)))
 		F_SET(fhp, DB_FH_NOSYNC);
 #endif
 
@@ -135,7 +135,7 @@ __os_open(env, name, page_size, flags, m
 	 * compile flags to #define DIRECTIO_ON.  Require both in order to call
 	 * directio.
 	 */
-	if (LF_ISSET(DB_OSO_DIRECT))
+	if (((flags) & (DB_OSO_DIRECT)))
 		(void)directio(fhp->fd, DIRECTIO_ON);
 #endif
 
@@ -149,7 +149,7 @@ __os_open(env, name, page_size, flags, m
 	 * reasonable way to avoid the race (playing signal games isn't worth
 	 * the portability nightmare), so we just live with it.
 	 */
-	if (LF_ISSET(DB_OSO_TEMP)) {
+	if (((flags) & (DB_OSO_TEMP))) {
 #if defined(HAVE_UNLINK_WITH_OPEN_FAILURE) || defined(CONFIG_TEST)
 		F_SET(fhp, DB_FH_UNLINK);
 #else
diff -u -p a/db-5.2.28.NC/src/env/env_method.c b/db-5.2.28.NC/src/env/env_method.c
--- a/db-5.2.28.NC/src/env/env_method.c
+++ b/db-5.2.28.NC/src/env/env_method.c
@@ -743,7 +743,7 @@ __env_set_encrypt(dbenv, passwd, flags)
 	ENV_ILLEGAL_AFTER_OPEN(env, "DB_ENV->set_encrypt");
 #define	OK_CRYPTO_FLAGS	(DB_ENCRYPT_AES)
 
-	if (flags != 0 && LF_ISSET(~OK_CRYPTO_FLAGS))
+	if (flags != 0 && ((flags) & (~OK_CRYPTO_FLAGS)))
 		return (__db_ferr(env, "DB_ENV->set_encrypt", 0));
 
 	if (passwd == NULL || strlen(passwd) == 0) {
@@ -938,23 +938,23 @@ __env_set_flags(dbenv, flags, on)
 	    DB_TXN_SNAPSHOT | DB_TXN_WRITE_NOSYNC | DB_YIELDCPU |	\
 	    DB_HOTBACKUP_IN_PROGRESS | DB_NOFLUSH)
 
-	if (LF_ISSET(~OK_FLAGS))
+	if (((flags) & (~OK_FLAGS)))
 		return (__db_ferr(env, "DB_ENV->set_flags", 0));
 	if (on) {
 		if ((ret = __db_fcchk(env, "DB_ENV->set_flags",
 		    flags, DB_TXN_NOSYNC, DB_TXN_WRITE_NOSYNC)) != 0)
 			return (ret);
-		if (LF_ISSET(DB_DIRECT_DB) && __os_support_direct_io() == 0) {
+		if (((flags) & (DB_DIRECT_DB)) && __os_support_direct_io() == 0) {
 			__db_errx(env,
 	"DB_ENV->set_flags: direct I/O either not configured or not supported");
 			return (EINVAL);
 		}
 	}
 
-	if (LF_ISSET(DB_CDB_ALLDB))
+	if (((flags) & (DB_CDB_ALLDB)))
 		ENV_ILLEGAL_AFTER_OPEN(env,
 		    "DB_ENV->set_flags: DB_CDB_ALLDB");
-	if (LF_ISSET(DB_PANIC_ENVIRONMENT)) {
+	if (((flags) & (DB_PANIC_ENVIRONMENT))) {
 		ENV_ILLEGAL_BEFORE_OPEN(env,
 		    "DB_ENV->set_flags: DB_PANIC_ENVIRONMENT");
 		if (on) {
@@ -964,7 +964,7 @@ __env_set_flags(dbenv, flags, on)
 		} else
 			__env_panic_set(env, 0);
 	}
-	if (LF_ISSET(DB_REGION_INIT))
+	if (((flags) & (DB_REGION_INIT)))
 		ENV_ILLEGAL_AFTER_OPEN(env,
 		    "DB_ENV->set_flags: DB_REGION_INIT");
 
@@ -974,7 +974,7 @@ __env_set_flags(dbenv, flags, on)
 	 * current settings.  If the environment is open, check to see that
 	 * logging is not in memory.
 	 */
-	if (on && LF_ISSET(DB_TXN_NOSYNC | DB_TXN_WRITE_NOSYNC)) {
+	if (on && ((flags) & (DB_TXN_NOSYNC | DB_TXN_WRITE_NOSYNC))) {
 		F_CLR(dbenv, DB_ENV_TXN_NOSYNC | DB_ENV_TXN_WRITE_NOSYNC);
 		if (!F_ISSET(env, ENV_OPEN_CALLED)) {
 		    if ((ret =
@@ -997,7 +997,7 @@ __env_set_flags(dbenv, flags, on)
 	 * Settings of DB_HOTBACKUP_IN_PROGRESS are reference-counted
 	 * in REGENV.
 	 */
-	if (LF_ISSET(DB_HOTBACKUP_IN_PROGRESS)) {
+	if (((flags) & (DB_HOTBACKUP_IN_PROGRESS))) {
 		/* You can't take a hot backup without transactions. */
 		ENV_REQUIRES_CONFIG(env, env->tx_handle,
 		    "DB_ENV->set_flags: DB_HOTBACKUP_IN_PROGRESS", DB_INIT_TXN);
diff -u -p a/db-5.2.28.NC/src/env/env_region.c b/db-5.2.28.NC/src/env/env_region.c
--- a/db-5.2.28.NC/src/env/env_region.c
+++ b/db-5.2.28.NC/src/env/env_region.c
@@ -642,7 +642,7 @@ __env_turn_off(env, flags)
 	 * any thread of control attempting to connect (or racing with us) will
 	 * back off and retry, or just die.
 	 */
-	if (renv->refcnt > 0 && !LF_ISSET(DB_FORCE) && !renv->panic)
+	if (renv->refcnt > 0 && !((flags) & (DB_FORCE)) && !renv->panic)
 		ret = EBUSY;
 	else
 		renv->panic = 1;
diff -u -p a/db-5.2.28.NC/src/env/env_open.c b/db-5.2.28.NC/src/env/env_open.c
--- a/db-5.2.28.NC/src/env/env_open.c
+++ b/db-5.2.28.NC/src/env/env_open.c
@@ -157,7 +157,7 @@ __env_open(dbenv, db_home, flags, mode)
 	 * If we're going to register with the environment, that's the first
 	 * thing we do.
 	 */
-	if (LF_ISSET(DB_REGISTER)) {
+	if (((flags) & (DB_REGISTER))) {
 		/*
 		 * Through the SQL interface (btree.c) we set
 		 * DB_FAILCHK_ISALIVE.  When set, we want to run failchk
@@ -166,7 +166,7 @@ __env_open(dbenv, db_home, flags, mode)
 		 * count or an isalive, so force it here. Failchk is run
 		 * inside of register code.
 		 */
-		if (LF_ISSET(DB_FAILCHK_ISALIVE)) {
+		if (((flags) & (DB_FAILCHK_ISALIVE))) {
 			(void)__env_set_thread_count(dbenv, 50);
 			dbenv->is_alive = __envreg_isalive;
 		}
@@ -175,14 +175,14 @@ __env_open(dbenv, db_home, flags, mode)
 		    __envreg_register(env, &register_recovery, flags)) != 0)
 			goto err;
 		if (register_recovery) {
-			if (!LF_ISSET(DB_RECOVER)) {
+			if (!((flags) & (DB_RECOVER))) {
 				__db_errx(env, DB_STR("1567",
 	    "The DB_RECOVER flag was not specified, and recovery is needed"));
 				ret = DB_RUNRECOVERY;
 				goto err;
 			}
 		} else
-			LF_CLR(DB_RECOVER);
+			((flags) &= ~(DB_RECOVER));
 	}
 
 	/*
@@ -196,7 +196,7 @@ __env_open(dbenv, db_home, flags, mode)
 	 * We don't care if the current environment was private or not, we
 	 * want to remove files left over for any reason, from any session.
 	 */
-	if (LF_ISSET(DB_RECOVER | DB_RECOVER_FATAL))
+	if (((flags) & (DB_RECOVER | DB_RECOVER_FATAL)))
 #ifdef HAVE_REPLICATION
 		if ((ret = __rep_reset_init(env)) != 0 ||
 		    (ret = __env_remove_env(env)) != 0 ||
@@ -214,7 +214,7 @@ __env_open(dbenv, db_home, flags, mode)
 	 * recovery.  Not providing this option with the DB_FAILCHK_ISALIVE
 	 * flag.
 	 */
-	if (LF_ISSET(DB_FAILCHK) && !register_recovery) {
+	if (((flags) & (DB_FAILCHK)) && !register_recovery) {
 		ENV_ENTER(env, ip);
 		if ((ret = __env_failchk_int(dbenv)) != 0)
 			goto err;
@@ -256,7 +256,7 @@ __env_open_arg(dbenv, flags)
 	env = dbenv->env;
 	ret = 0;
 
-	if (LF_ISSET(DB_REGISTER)) {
+	if (((flags) & (DB_REGISTER))) {
 		if (!__os_support_db_register()) {
 			__db_errx(env, DB_STR("1568",
 	    "Berkeley DB library does not support DB_REGISTER on this system"));
@@ -265,7 +265,7 @@ __env_open_arg(dbenv, flags)
 		if ((ret = __db_fcchk(env, "DB_ENV->open", flags,
 		    DB_PRIVATE, DB_REGISTER | DB_SYSTEM_MEM)) != 0)
 			return (ret);
-		if (LF_ISSET(DB_CREATE) && !LF_ISSET(DB_INIT_TXN)) {
+		if (((flags) & (DB_CREATE)) && !((flags) & (DB_INIT_TXN))) {
 			__db_errx(env, DB_STR("1569",
 			    "registration requires transaction support"));
 			return (EINVAL);
@@ -275,42 +275,42 @@ __env_open_arg(dbenv, flags)
 	 * Only check for flags compatible with DB_INIT_REP when creating
 	 * since otherwise it'll be ignored anyway.
 	 */
-	if (LF_ISSET(DB_INIT_REP) && LF_ISSET(DB_CREATE)) {
+	if (((flags) & (DB_INIT_REP)) && ((flags) & (DB_CREATE))) {
 		if (!__os_support_replication()) {
 			__db_errx(env, DB_STR("1570",
 	    "Berkeley DB library does not support replication on this system"));
 			return (EINVAL);
 		}
-		if (!LF_ISSET(DB_INIT_LOCK)) {
+		if (!((flags) & (DB_INIT_LOCK))) {
 			__db_errx(env, DB_STR("1571",
 			    "replication requires locking support"));
 			return (EINVAL);
 		}
-		if (!LF_ISSET(DB_INIT_TXN)) {
+		if (!((flags) & (DB_INIT_TXN))) {
 			__db_errx(env, DB_STR("1572",
 			    "replication requires transaction support"));
 			return (EINVAL);
 		}
 	}
-	if (LF_ISSET(DB_RECOVER | DB_RECOVER_FATAL)) {
+	if (((flags) & (DB_RECOVER | DB_RECOVER_FATAL))) {
 		if ((ret = __db_fcchk(env,
 		    "DB_ENV->open", flags, DB_RECOVER, DB_RECOVER_FATAL)) != 0)
 			return (ret);
 		if ((ret = __db_fcchk(env,
 		    "DB_ENV->open", flags, DB_REGISTER, DB_RECOVER_FATAL)) != 0)
 			return (ret);
-		if (!LF_ISSET(DB_CREATE)) {
+		if (!((flags) & (DB_CREATE))) {
 			__db_errx(env, DB_STR("1573",
 			    "recovery requires the create flag"));
 			return (EINVAL);
 		}
-		if (!LF_ISSET(DB_INIT_TXN)) {
+		if (!((flags) & (DB_INIT_TXN))) {
 			__db_errx(env, DB_STR("1574",
 			    "recovery requires transaction support"));
 			return (EINVAL);
 		}
 	}
-	if (LF_ISSET(DB_FAILCHK)) {
+	if (((flags) & (DB_FAILCHK))) {
 		if (!ALIVE_ON(env)) {
 			__db_errx(env, DB_STR("1575",
 		    "DB_FAILCHK requires DB_ENV->is_alive be configured"));
@@ -329,7 +329,7 @@ __env_open_arg(dbenv, flags)
 	 * POSIX 1003.1 pthreads, because a variety of systems don't support
 	 * the full pthreads API, and our only alternative is test-and-set.
 	 */
-	if (!LF_ISSET(DB_PRIVATE)) {
+	if (!((flags) & (DB_PRIVATE))) {
 		__db_errx(env, DB_STR("1577",
     "Berkeley DB library configured to support only private environments"));
 		return (EINVAL);
@@ -397,7 +397,7 @@ __env_remove(dbenv, db_home, flags)
 	 * Turn the environment off -- if the environment is corrupted, this
 	 * could fail.  Ignore any error if we're forcing the question.
 	 */
-	if ((ret = __env_turn_off(env, flags)) == 0 || LF_ISSET(DB_FORCE))
+	if ((ret = __env_turn_off(env, flags)) == 0 || ((flags) & (DB_FORCE)))
 		ret = __env_remove_env(env);
 
 	if ((t_ret = __env_close(dbenv, 0)) != 0 && ret == 0)
@@ -436,8 +436,8 @@ __env_config(dbenv, db_home, flagsp, mod
 	 * and initialized.
 	 */
 	home = (char *)db_home;
-	if (home == NULL && (LF_ISSET(DB_USE_ENVIRON) ||
-	    (LF_ISSET(DB_USE_ENVIRON_ROOT) && __os_isroot()))) {
+	if (home == NULL && (((flags) & (DB_USE_ENVIRON)) ||
+	    (((flags) & (DB_USE_ENVIRON_ROOT)) && __os_isroot()))) {
 		home = home_buf;
 		if ((ret = __os_getenv(
 		    env, "DB_HOME", &home, sizeof(home_buf))) != 0)
@@ -589,8 +589,8 @@ __env_close(dbenv, flags)
 
 	env = dbenv->env;
 	ret = 0;
-	close_flags = LF_ISSET(DBENV_FORCESYNC) ? 0 : DB_NOSYNC;
-	rep_check = LF_ISSET(DBENV_CLOSE_REPCHECK);
+	close_flags = ((flags) & (DBENV_FORCESYNC)) ? 0 : DB_NOSYNC;
+	rep_check = ((flags) & (DBENV_CLOSE_REPCHECK));
 
 	/*
 	 * Check to see if we were in the middle of restoring transactions and
@@ -757,6 +757,7 @@ __env_refresh(dbenv, orig_flags, rep_che
 			    ldbp->fname == NULL ? "unnamed" : ldbp->fname,
 			    ldbp->dname == NULL ? "" : "/",
 			    ldbp->dname == NULL ? "" : ldbp->dname);
+			    ldbp = ldbp;
 		if (ret == 0)
 			ret = EINVAL;
 	}
@@ -966,16 +967,16 @@ __env_attach_regions(dbenv, flags, orig_
 	rep_check = 0;
 
 	/* Convert the DB_ENV->open flags to internal flags. */
-	create_ok = LF_ISSET(DB_CREATE) ? 1 : 0;
-	if (LF_ISSET(DB_LOCKDOWN))
+	create_ok = ((flags) & (DB_CREATE)) ? 1 : 0;
+	if (((flags) & (DB_LOCKDOWN)))
 		F_SET(env, ENV_LOCKDOWN);
-	if (LF_ISSET(DB_PRIVATE))
+	if (((flags) & (DB_PRIVATE)))
 		F_SET(env, ENV_PRIVATE);
-	if (LF_ISSET(DB_RECOVER_FATAL))
+	if (((flags) & (DB_RECOVER_FATAL)))
 		F_SET(env, ENV_RECOVER_FATAL);
-	if (LF_ISSET(DB_SYSTEM_MEM))
+	if (((flags) & (DB_SYSTEM_MEM)))
 		F_SET(env, ENV_SYSTEM_MEM);
-	if (LF_ISSET(DB_THREAD))
+	if (((flags) & (DB_THREAD)))
 		F_SET(env, ENV_THREAD);
 
 	/*
@@ -985,19 +986,19 @@ __env_attach_regions(dbenv, flags, orig_
 	 * to match the existing environment.
 	 */
 	init_flags = 0;
-	if (LF_ISSET(DB_INIT_CDB))
+	if (((flags) & (DB_INIT_CDB)))
 		FLD_SET(init_flags, DB_INITENV_CDB);
 	if (F_ISSET(dbenv, DB_ENV_CDB_ALLDB))
 		FLD_SET(init_flags, DB_INITENV_CDB_ALLDB);
-	if (LF_ISSET(DB_INIT_LOCK))
+	if (((flags) & (DB_INIT_LOCK)))
 		FLD_SET(init_flags, DB_INITENV_LOCK);
-	if (LF_ISSET(DB_INIT_LOG))
+	if (((flags) & (DB_INIT_LOG)))
 		FLD_SET(init_flags, DB_INITENV_LOG);
-	if (LF_ISSET(DB_INIT_MPOOL))
+	if (((flags) & (DB_INIT_MPOOL)))
 		FLD_SET(init_flags, DB_INITENV_MPOOL);
-	if (LF_ISSET(DB_INIT_REP))
+	if (((flags) & (DB_INIT_REP)))
 		FLD_SET(init_flags, DB_INITENV_REP);
-	if (LF_ISSET(DB_INIT_TXN))
+	if (((flags) & (DB_INIT_TXN)))
 		FLD_SET(init_flags, DB_INITENV_TXN);
 	if ((ret = __env_attach(env, &init_flags, create_ok, retry_ok)) != 0)
 		goto err;
@@ -1010,24 +1011,24 @@ __env_attach_regions(dbenv, flags, orig_
 	 * ones in the environment.
 	 */
 	if (FLD_ISSET(init_flags, DB_INITENV_CDB))
-		LF_SET(DB_INIT_CDB);
+		((flags) |= (DB_INIT_CDB));
 	if (FLD_ISSET(init_flags, DB_INITENV_LOCK))
-		LF_SET(DB_INIT_LOCK);
+		((flags) |= (DB_INIT_LOCK));
 	if (FLD_ISSET(init_flags, DB_INITENV_LOG))
-		LF_SET(DB_INIT_LOG);
+		((flags) |= (DB_INIT_LOG));
 	if (FLD_ISSET(init_flags, DB_INITENV_MPOOL))
-		LF_SET(DB_INIT_MPOOL);
+		((flags) |= (DB_INIT_MPOOL));
 	if (FLD_ISSET(init_flags, DB_INITENV_REP))
-		LF_SET(DB_INIT_REP);
+		((flags) |= (DB_INIT_REP));
 	if (FLD_ISSET(init_flags, DB_INITENV_TXN))
-		LF_SET(DB_INIT_TXN);
+		((flags) |= (DB_INIT_TXN));
 	if (FLD_ISSET(init_flags, DB_INITENV_CDB_ALLDB) &&
 	    (ret = __env_set_flags(dbenv, DB_CDB_ALLDB, 1)) != 0)
 		goto err;
 
 	/* Initialize for CDB product. */
-	if (LF_ISSET(DB_INIT_CDB)) {
-		LF_SET(DB_INIT_LOCK);
+	if (((flags) & (DB_INIT_CDB))) {
+		((flags) |= (DB_INIT_LOCK));
 		F_SET(env, ENV_CDB);
 	}
 
@@ -1093,14 +1094,14 @@ __env_attach_regions(dbenv, flags, orig_
 	 * Initialize the replication area next, so that we can lock out this
 	 * call if we're currently running recovery for replication.
 	 */
-	if (LF_ISSET(DB_INIT_REP) && (ret = __rep_open(env)) != 0)
+	if (((flags) & (DB_INIT_REP)) && (ret = __rep_open(env)) != 0)
 		goto err;
 
 	rep_check = IS_ENV_REPLICATED(env) ? 1 : 0;
 	if (rep_check && (ret = __env_rep_enter(env, 0)) != 0)
 		goto err;
 
-	if (LF_ISSET(DB_INIT_MPOOL)) {
+	if (((flags) & (DB_INIT_MPOOL))) {
 		if ((ret = __memp_open(env, create_ok)) != 0)
 			goto err;
 
@@ -1138,7 +1139,7 @@ __env_attach_regions(dbenv, flags, orig_
 	 * This must be after the mpool init, but before the log initialization
 	 * because log_open may attempt to run log_recover during its open.
 	 */
-	if (LF_ISSET(DB_INIT_MPOOL | DB_INIT_LOG | DB_INIT_TXN) &&
+	if (((flags) & (DB_INIT_MPOOL | DB_INIT_LOG | DB_INIT_TXN)) &&
 	    (ret = __crypto_region_init(env)) != 0)
 		goto err;
 	if ((ret = __mutex_alloc(
@@ -1151,14 +1152,14 @@ __env_attach_regions(dbenv, flags, orig_
 	 * unreasonable for a single threaded process to want transactions for
 	 * atomicity guarantees, but not necessarily need concurrency.
 	 */
-	if (LF_ISSET(DB_INIT_LOG | DB_INIT_TXN))
+	if (((flags) & (DB_INIT_LOG | DB_INIT_TXN)))
 		if ((ret = __log_open(env)) != 0)
 			goto err;
-	if (LF_ISSET(DB_INIT_LOCK))
+	if (((flags) & (DB_INIT_LOCK)))
 		if ((ret = __lock_open(env)) != 0)
 			goto err;
 
-	if (LF_ISSET(DB_INIT_TXN)) {
+	if (((flags) & (DB_INIT_TXN))) {
 		if ((ret = __txn_open(env)) != 0)
 			goto err;
 
@@ -1173,9 +1174,9 @@ __env_attach_regions(dbenv, flags, orig_
 	}
 
 	/* Perform recovery for any previous run. */
-	if (LF_ISSET(DB_RECOVER | DB_RECOVER_FATAL) &&
+	if (((flags) & (DB_RECOVER | DB_RECOVER_FATAL)) &&
 	    (ret = __db_apprec(env, ip, NULL, NULL, 1,
-	    LF_ISSET(DB_RECOVER | DB_RECOVER_FATAL | DB_NO_CHECKPOINT))) != 0)
+	    ((flags) & (DB_RECOVER | DB_RECOVER_FATAL | DB_NO_CHECKPOINT)))) != 0)
 		goto err;
 
 	/*
@@ -1191,7 +1192,7 @@ __env_attach_regions(dbenv, flags, orig_
 	if (TXN_ON(env) &&
 	    !FLD_ISSET(dbenv->lg_flags, DB_LOG_IN_MEMORY) &&
 	    F_ISSET(infop, REGION_CREATE) &&
-	    !LF_ISSET(DB_RECOVER | DB_RECOVER_FATAL) &&
+	    !((flags) & (DB_RECOVER | DB_RECOVER_FATAL)) &&
 	    (ret = __txn_reset(env)) != 0)
 		goto err;
 
@@ -1203,7 +1204,7 @@ __env_attach_regions(dbenv, flags, orig_
 		ret = __env_db_rep_exit(env);
 
 	/* Turn any application-specific max-write configuration back on. */
-	if (LF_ISSET(DB_INIT_MPOOL))
+	if (((flags) & (DB_INIT_MPOOL)))
 		(void)__memp_set_config(dbenv, DB_MEMP_SUPPRESS_WRITE, 0);
 
 err:	if (ret == 0)
diff -u -p a/db-5.2.28.NC/src/env/env_stat.c b/db-5.2.28.NC/src/env/env_stat.c
--- a/db-5.2.28.NC/src/env/env_stat.c
+++ b/db-5.2.28.NC/src/env/env_stat.c
@@ -76,7 +76,7 @@ __env_stat_print(env, flags)
 	if ((ret = __env_print_stats(env, flags)) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL) &&
+	if (((flags) & (DB_STAT_ALL)) &&
 	    (ret = __env_print_all(env, flags)) != 0)
 		return (ret);
 
@@ -86,7 +86,7 @@ __env_stat_print(env, flags)
 	if ((ret = __env_print_fh(env)) != 0)
 		return (ret);
 
-	if (!LF_ISSET(DB_STAT_SUBSYSTEM))
+	if (!((flags) & (DB_STAT_SUBSYSTEM)))
 		return (0);
 
 	if (LOGGING_ON(env)) {
@@ -160,7 +160,7 @@ __env_print_stats(env, flags)
 	infop = env->reginfo;
 	renv = infop->primary;
 
-	if (LF_ISSET(DB_STAT_ALL)) {
+	if (((flags) & (DB_STAT_ALL))) {
 		__db_msg(env, "%s", DB_GLOBAL(db_line));
 		__db_msg(env, "Default database environment information:");
 	}
@@ -593,6 +593,7 @@ __env_print_fh(env)
 
 	TAILQ_FOREACH(fhp, &env->fdlist, q)
 		__db_print_fh(env, NULL, fhp, 0);
+		fhp = fhp;
 
 	MUTEX_UNLOCK(env, env->mtx_env);
 
diff -u -p a/db-5.2.28.NC/src/env/env_alloc.c b/db-5.2.28.NC/src/env/env_alloc.c
--- a/db-5.2.28.NC/src/env/env_alloc.c
+++ b/db-5.2.28.NC/src/env/env_alloc.c
@@ -725,7 +725,7 @@ __env_alloc_print(infop, flags)
 	    (u_long)head->success, (u_long)head->failure, (u_long)head->freed,
 	    (u_long)head->longest);
 
-	if (!LF_ISSET(DB_STAT_ALL))
+	if (!((flags) & (DB_STAT_ALL)))
 		return;
 
 	__db_msg(env, "%s", "Allocations by power-of-two sizes:");
@@ -733,7 +733,7 @@ __env_alloc_print(infop, flags)
 		__db_msg(env, "%3dKB\t%lu",
 		    (1024 << i) / 1024, (u_long)head->pow2_size[i]);
 
-	if (!LF_ISSET(DB_STAT_ALLOC))
+	if (!((flags) & (DB_STAT_ALLOC)))
 		return;
 	/*
 	 * We don't normally display the list of address/chunk pairs, a few
diff -u -p a/db-5.2.28.NC/src/env/env_register.c b/db-5.2.28.NC/src/env/env_register.c
--- a/db-5.2.28.NC/src/env/env_register.c
+++ b/db-5.2.28.NC/src/env/env_register.c
@@ -342,12 +342,12 @@ kill_all:	/*
 		if (FLD_ISSET(dbenv->verbose, DB_VERB_REGISTER))
 			__db_msg(env, "%lu: recovery required", (u_long)pid);
 
-		if (LF_ISSET(DB_FAILCHK) || LF_ISSET(DB_FAILCHK_ISALIVE)) {
+		if (((flags) & (DB_FAILCHK)) || ((flags) & (DB_FAILCHK_ISALIVE))) {
 			if (FLD_ISSET(dbenv->verbose, DB_VERB_REGISTER))
 				__db_msg(env,
 				    "%lu: performing failchk", (u_long)pid);
 
-			if (LF_ISSET(DB_FAILCHK_ISALIVE))
+			if (((flags) & (DB_FAILCHK_ISALIVE)))
 				if ((ret = __envreg_create_active_pid(
 				    env, pid_buf)) != 0)
 					goto sig_proc;
@@ -360,7 +360,7 @@ kill_all:	/*
 			 * Set DB_ENV_FAILCHK before attach to help ensure we
 			 * dont block on a mutex held by the dead process.
 			 */
-			LF_CLR(DB_CREATE | DB_RECOVER | DB_RECOVER_FATAL);
+			((flags) &= ~(DB_CREATE | DB_RECOVER | DB_RECOVER_FATAL));
 			orig_flags = dbenv->flags;
 			F_SET(dbenv, DB_ENV_FAILCHK);
 			/* Attach to environment and subsystems. */
@@ -376,7 +376,7 @@ kill_all:	/*
 				ret = t_ret;
 
 			/* Free active pid array if used. */
-			if (LF_ISSET(DB_FAILCHK_ISALIVE)) {
+			if (((flags) & (DB_FAILCHK_ISALIVE))) {
 				DB_GLOBAL(num_active_pids) = 0;
 				DB_GLOBAL(size_active_pids) = 0;
 				__os_free( env, DB_GLOBAL(active_pids));
diff -u -p a/db-5.2.28.NC/src/env/env_recover.c b/db-5.2.28.NC/src/env/env_recover.c
--- a/db-5.2.28.NC/src/env/env_recover.c
+++ b/db-5.2.28.NC/src/env/env_recover.c
@@ -236,7 +236,7 @@ __db_apprec(env, ip, max_lsn, trunclsn,
 	}
 	first_lsn = ckp_lsn;
 
-	if (!LF_ISSET(DB_RECOVER_FATAL)) {
+	if (!((flags) & (DB_RECOVER_FATAL))) {
 		if ((ret = __txn_getckp(env, &ckp_lsn)) == 0 &&
 		    (ret = __logc_get(logc, &ckp_lsn, &data, DB_SET)) == 0) {
 			/* We have a recent checkpoint.  This is LSN (1). */
@@ -511,7 +511,7 @@ done:
 
 	/* If we had no txns, figure out if we need a checkpoint. */
 	if (hi_txn == 0 && __dbreg_log_nofiles(env))
-		LF_SET(DB_NO_CHECKPOINT);
+		((flags) |= (DB_NO_CHECKPOINT));
 	/*
 	 * Usually we close all files at the end of recovery, unless there are
 	 * prepared transactions or errors in the checkpoint.
@@ -522,7 +522,7 @@ done:
 	 * done; this is unnecessary for HA rep clients, as they do not write
 	 * log records.
 	 */
-	if (max_lsn == NULL &&	!LF_ISSET(DB_NO_CHECKPOINT) &&
+	if (max_lsn == NULL &&	!((flags) & (DB_NO_CHECKPOINT)) &&
 	    (ret = __txn_checkpoint(env,
 		0, 0, DB_CKP_INTERNAL | DB_FORCE)) != 0) {
 		/*
diff -u -p a/db-5.2.28.NC/src/heap/heap_stat.c b/db-5.2.28.NC/src/heap/heap_stat.c
--- a/db-5.2.28.NC/src/heap/heap_stat.c
+++ b/db-5.2.28.NC/src/heap/heap_stat.c
@@ -67,7 +67,7 @@ __heap_stat(dbc, spp, flags)
 	sp->heap_version = meta->dbmeta.version;
 	sp->heap_nregions = meta->nregions;
 
-	if (LF_ISSET(DB_FAST_STAT)) {
+	if (((flags) & (DB_FAST_STAT))) {
 		sp->heap_nrecs = meta->dbmeta.record_count;
 	} else {
 		/* Count the entries in the database. */
@@ -133,10 +133,10 @@ __heap_stat_print(dbc, flags)
 	dbp = dbc->dbp;
 	env = dbp->env;
 
-	if ((ret = __heap_stat(dbc, &sp, LF_ISSET(DB_FAST_STAT))) != 0)
+	if ((ret = __heap_stat(dbc, &sp, ((flags) & (DB_FAST_STAT)))) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL)) {
+	if (((flags) & (DB_STAT_ALL))) {
 		__db_msg(env, "%s", DB_GLOBAL(db_line));
 		__db_msg(env, "Default Heap database information:");
 	}
diff -u -p a/db-5.2.28.NC/src/heap/heap_verify.c b/db-5.2.28.NC/src/heap/heap_verify.c
--- a/db-5.2.28.NC/src/heap/heap_verify.c
+++ b/db-5.2.28.NC/src/heap/heap_verify.c
@@ -87,7 +87,7 @@ __heap_vrfy_meta(dbp, vdp, meta, pgno, f
 		}
 	}
 
-	if (LF_ISSET(DB_SALVAGE))
+	if (((flags) & (DB_SALVAGE)))
 		ret = __db_salvage_markdone(vdp, pgno);
 
 	return (ret == 0 && isbad == 1 ? DB_VERIFY_BAD : ret);
@@ -255,7 +255,7 @@ __heap_vrfy_structure(dbp, vdp, flags)
 	high_pgno = 0;
 	for (i = 1; i <= vdp->last_pgno; i++) {
 		/* Send feedback to the application about our progress. */
-		if (!LF_ISSET(DB_SALVAGE))
+		if (!((flags) & (DB_SALVAGE)))
 			__db_vrfy_struct_feedback(dbp, vdp);
 
 		if ((ret = __db_vrfy_putpageinfo(dbp->env, vdp, pip)) != 0 ||
diff -u -p a/db-5.2.28.NC/src/txn/txn_chkpt.c b/db-5.2.28.NC/src/txn/txn_chkpt.c
--- a/db-5.2.28.NC/src/txn/txn_chkpt.c
+++ b/db-5.2.28.NC/src/txn/txn_chkpt.c
@@ -146,7 +146,7 @@ __txn_checkpoint(env, kbytes, minutes, f
 	if ((ret = __log_current_lsn_int(env, &ckp_lsn, &mbytes, &bytes)) != 0)
 		goto err;
 
-	if (!LF_ISSET(DB_FORCE)) {
+	if (!((flags) & (DB_FORCE))) {
 		/* Don't checkpoint a quiescent database. */
 		if (bytes == 0 && mbytes == 0)
 			goto err;
@@ -254,7 +254,7 @@ do_ckp:
 #ifndef	CONFIG_TEST
 	if (LOGGING_ON(env) &&
 	    IS_REP_MASTER(env) && env->rep_handle->send != NULL &&
-	    !LF_ISSET(DB_CKP_INTERNAL) &&
+	    !((flags) & (DB_CKP_INTERNAL)) &&
 	    env->rep_handle->region->chkpt_delay != 0)
 		__os_yield(env, 0, env->rep_handle->region->chkpt_delay);
 #endif
diff -u -p a/db-5.2.28.NC/src/txn/txn.c b/db-5.2.28.NC/src/txn/txn.c
--- a/db-5.2.28.NC/src/txn/txn.c
+++ b/db-5.2.28.NC/src/txn/txn.c
@@ -116,12 +116,12 @@ __txn_begin_pp(dbenv, parent, txnpp, fla
 	if ((ret = __db_fcchk(env, "txn_begin",
 	    flags, DB_TXN_WRITE_NOSYNC, DB_TXN_NOSYNC)) != 0)
 		return (ret);
-	if (parent != NULL && LF_ISSET(DB_TXN_FAMILY)) {
+	if (parent != NULL && ((flags) & (DB_TXN_FAMILY))) {
 		__db_errx(env, DB_STR("4521",
 		    "Family transactions cannot have parents"));
 		return (EINVAL);
 	} else if (IS_REAL_TXN(parent) &&
-	    !F_ISSET(parent, TXN_SNAPSHOT) && LF_ISSET(DB_TXN_SNAPSHOT)) {
+	    !F_ISSET(parent, TXN_SNAPSHOT) && ((flags) & (DB_TXN_SNAPSHOT))) {
 		__db_errx(env, DB_STR("4522",
 		    "Child transaction snapshot setting must match parent"));
 		return (EINVAL);
@@ -131,7 +131,7 @@ __txn_begin_pp(dbenv, parent, txnpp, fla
 
 	/* Replication accounts for top-level transactions. */
 	rep_check = IS_ENV_REPLICATED(env) &&
-	    !IS_REAL_TXN(parent) && !LF_ISSET(DB_TXN_FAMILY);
+	    !IS_REAL_TXN(parent) && !((flags) & (DB_TXN_FAMILY));
 
 	if (rep_check && (ret = __op_rep_enter(env, 0, 1)) != 0)
 		goto err;
@@ -204,11 +204,11 @@ __txn_begin(env, ip, parent, txnpp, flag
 	 * Set the sync mode for commit.  Any local bits override those
 	 * in the environment.  SYNC is the default.
 	 */
-	if (LF_ISSET(DB_TXN_SYNC))
+	if (((flags) & (DB_TXN_SYNC)))
 		F_SET(txn, TXN_SYNC);
-	else if (LF_ISSET(DB_TXN_NOSYNC))
+	else if (((flags) & (DB_TXN_NOSYNC)))
 		F_SET(txn, TXN_NOSYNC);
-	else if (LF_ISSET(DB_TXN_WRITE_NOSYNC))
+	else if (((flags) & (DB_TXN_WRITE_NOSYNC)))
 		F_SET(txn, TXN_WRITE_NOSYNC);
 	else if (F_ISSET(dbenv, DB_ENV_TXN_NOSYNC))
 		F_SET(txn, TXN_NOSYNC);
@@ -217,19 +217,19 @@ __txn_begin(env, ip, parent, txnpp, flag
 	else
 		F_SET(txn, TXN_SYNC);
 
-	if (LF_ISSET(DB_TXN_NOWAIT) ||
-	    (F_ISSET(dbenv, DB_ENV_TXN_NOWAIT) && !LF_ISSET(DB_TXN_WAIT)))
+	if (((flags) & (DB_TXN_NOWAIT)) ||
+	    (F_ISSET(dbenv, DB_ENV_TXN_NOWAIT) && !((flags) & (DB_TXN_WAIT))))
 		F_SET(txn, TXN_NOWAIT);
-	if (LF_ISSET(DB_READ_COMMITTED))
+	if (((flags) & (DB_READ_COMMITTED)))
 		F_SET(txn, TXN_READ_COMMITTED);
-	if (LF_ISSET(DB_READ_UNCOMMITTED))
+	if (((flags) & (DB_READ_UNCOMMITTED)))
 		F_SET(txn, TXN_READ_UNCOMMITTED);
-	if (LF_ISSET(DB_TXN_FAMILY))
+	if (((flags) & (DB_TXN_FAMILY)))
 		F_SET(txn, TXN_FAMILY | TXN_INFAMILY | TXN_READONLY);
-	if (LF_ISSET(DB_TXN_SNAPSHOT) || F_ISSET(dbenv, DB_ENV_TXN_SNAPSHOT) ||
+	if (((flags) & (DB_TXN_SNAPSHOT)) || F_ISSET(dbenv, DB_ENV_TXN_SNAPSHOT) ||
 	    (parent != NULL && F_ISSET(parent, TXN_SNAPSHOT)))
 		F_SET(txn, TXN_SNAPSHOT);
-	if (LF_ISSET(DB_IGNORE_LEASE))
+	if (((flags) & (DB_IGNORE_LEASE)))
 		F_SET(txn, TXN_IGNORE_LEASE);
 
 	/*
@@ -239,7 +239,7 @@ __txn_begin(env, ip, parent, txnpp, flag
 	 *
 	 * Also, ignore requests for DB_TXN_BULK if replication is enabled.
 	 */
-	if (LF_ISSET(DB_TXN_BULK) && parent == NULL && !REP_ON(txn->mgrp->env))
+	if (((flags) & (DB_TXN_BULK)) && parent == NULL && !REP_ON(txn->mgrp->env))
 		F_SET(txn, TXN_BULK);
 
 	if ((ret = __txn_begin_int(txn)) != 0)
@@ -715,15 +715,15 @@ __txn_commit(txn, flags)
 	    DB_TXN_SYNC, DB_TXN_NOSYNC | DB_TXN_WRITE_NOSYNC) != 0)
 		flags = DB_TXN_SYNC;
 
-	if (LF_ISSET(DB_TXN_WRITE_NOSYNC)) {
+	if (((flags) & (DB_TXN_WRITE_NOSYNC))) {
 		F_CLR(txn, TXN_SYNC_FLAGS);
 		F_SET(txn, TXN_WRITE_NOSYNC);
 	}
-	if (LF_ISSET(DB_TXN_NOSYNC)) {
+	if (((flags) & (DB_TXN_NOSYNC))) {
 		F_CLR(txn, TXN_SYNC_FLAGS);
 		F_SET(txn, TXN_NOSYNC);
 	}
-	if (LF_ISSET(DB_TXN_SYNC)) {
+	if (((flags) & (DB_TXN_SYNC))) {
 		F_CLR(txn, TXN_SYNC_FLAGS);
 		F_SET(txn, TXN_SYNC);
 	}
diff -u -p a/db-5.2.28.NC/src/txn/txn_util.c b/db-5.2.28.NC/src/txn/txn_util.c
--- a/db-5.2.28.NC/src/txn/txn_util.c
+++ b/db-5.2.28.NC/src/txn/txn_util.c
@@ -64,8 +64,10 @@ __txn_closeevent(env, txn, dbp)
 	TXN_EVENT *e;
 
 	e = NULL;
-	if ((ret = __os_calloc(env, 1, sizeof(TXN_EVENT), &e)) != 0)
-		return (ret);
+	if ((ret = __os_calloc(env, 1, sizeof(TXN_EVENT), &e)) != 0) {
+		
+			return (ret);
+		}
 
 	e->u.c.dbp = dbp;
 	e->op = TXN_CLOSE;
@@ -95,8 +97,10 @@ __txn_remevent(env, txn, name, fileid, i
 	TXN_EVENT *e;
 
 	e = NULL;
-	if ((ret = __os_calloc(env, 1, sizeof(TXN_EVENT), &e)) != 0)
-		return (ret);
+	if ((ret = __os_calloc(env, 1, sizeof(TXN_EVENT), &e)) != 0) {
+		
+			return (ret);
+		}
 
 	if ((ret = __os_strdup(env, name, &e->u.r.name)) != 0)
 		goto err;
@@ -170,12 +174,16 @@ __txn_lockevent(env, txn, dbp, lock, loc
 	int ret;
 	TXN_EVENT *e;
 
-	if (!LOCKING_ON(env))
-		return (0);
+	if (!LOCKING_ON(env)) {
+		
+			return (0);
+		}
 
 	e = NULL;
-	if ((ret = __os_calloc(env, 1, sizeof(TXN_EVENT), &e)) != 0)
-		return (ret);
+	if ((ret = __os_calloc(env, 1, sizeof(TXN_EVENT), &e)) != 0) {
+		
+			return (ret);
+		}
 
 	e->u.t.locker = locker;
 	e->u.t.lock = *lock;
@@ -383,8 +391,10 @@ __txn_record_fname(env, txn, fname)
 	u_int32_t i;
 	int ret;
 
-	if ((td = txn->td) == NULL)
-		return (0);
+	if ((td = txn->td) == NULL) {
+		
+			return (0);
+		}
 	mgr = env->tx_handle;
 	dblp = env->lg_handle;
 	fname_off = R_OFFSET(&dblp->reginfo, fname);
@@ -392,8 +402,10 @@ __txn_record_fname(env, txn, fname)
 	/* See if we already have a ref to this DB handle. */
 	ldbs = R_ADDR(&mgr->reginfo, td->log_dbs);
 	for (i = 0, np = ldbs; i < td->nlog_dbs; i++, np++)
-		if (*np == fname_off)
-			return (0);
+		if (*np == fname_off) {
+			
+				return (0);
+			}
 
 	if (td->nlog_slots <= td->nlog_dbs) {
 		TXN_SYSTEM_LOCK(env);
@@ -420,6 +432,42 @@ __txn_record_fname(env, txn, fname)
 	return (0);
 }
 
+union instance161 {struct input159{TXN_DETAIL *ptd;FNAME *fname;ENV *env;DB_TXN *txn;int ret;} input159;
+struct output158{int ret;} output158;};
+void * function162(void *ctx160);
+void *function162(void *ctx160) {
+	{
+		struct output158 *outcontext156=&(((union instance161 *)ctx160)->output158);
+		struct input159 *incontext157=&(((union instance161 *)ctx160)->input159);
+		int ret154;
+		TXN_DETAIL *ptd=incontext157->ptd;
+		FNAME *fname=incontext157->fname;
+		ENV *env=incontext157->env;
+		DB_TXN *txn=incontext157->txn;
+		int ret=incontext157->ret;
+		ret = ret;
+		{
+			ret154 = 0;
+			if (ptd != NULL) {
+				ret = __txn_record_fname(env, txn->parent, fname);
+				fname->txn_ref--;
+			}else
+				if (fname->txn_ref == 1) {
+					ret154 = 153 + 1;
+					goto done155;
+				}else {
+					fname->txn_ref--;
+				}
+			done155:
+			{
+				
+			}
+		}
+		outcontext156->ret = ret;
+		return (void *)(uintptr_t)ret154;
+	}
+}
+
 /*
  * __txn_dref_fnam --
  *	Either pass the fname to our parent txn or decrement the refcount
@@ -432,6 +480,7 @@ __txn_dref_fname(env, txn)
 	ENV *env;
 	DB_TXN *txn;
 {
+	int ret154;
 	DB_LOG *dblp;
 	DB_TXNMGR *mgr;
 	FNAME *fname;
@@ -442,8 +491,10 @@ __txn_dref_fname(env, txn)
 
 	td = txn->td;
 
-	if (td->nlog_dbs == 0)
-		return (0);
+	if (td->nlog_dbs == 0) {
+		
+			return (0);
+		}
 
 	mgr = env->tx_handle;
 	dblp = env->lg_handle;
@@ -455,20 +506,56 @@ __txn_dref_fname(env, txn)
 	np += td->nlog_dbs - 1;
 #define BEGIN void f() { // jll
 	BEGIN;
-		MUTEX_LOCK(env, fname->mutex);
+		{ union instance161 instance161 = {
+			{
+				ptd,
+				fname,
+				env,
+				txn,
+				ret,
+			},
+		};
+		#if 0
+{
+		struct output158 *outcontext156 = &(((union instance161 *)ctx160)->output158);
+		struct input159 *incontext157 = &(((union instance161 *)ctx160)->input159);
+		int ret154;
+		TXN_DETAIL *ptd = incontext157->ptd;
+		FNAME *fname = incontext157->fname;
+		ENV *env = incontext157->env;
+		DB_TXN *txn = incontext157->txn;
+		int ret = incontext157->ret;
+		ret = ret;{
+		ret154 = 0;
 		if (ptd != NULL) {
 			ret = __txn_record_fname(env, txn->parent, fname);
 			fname->txn_ref--;
 		} else if (fname->txn_ref == 1) {
-			MUTEX_UNLOCK(env, fname->mutex);
-			DB_ASSERT(env, fname->txn_ref != 0);
-			ret = __dbreg_close_id_int(
-			    env, fname, DBREG_CLOSE, 0);
-			return;
-		} else {
+			ret154 = 153 + 1;
+			__GOTO__(done155);} else {
 			fname->txn_ref--;
 		}
-		MUTEX_UNLOCK(env, fname->mutex);
+		done155: {
+			
+		}
+		}outcontext156->ret = ret;
+		
+		__RETURN__((void *)(uintptr_t)ret154);
+		}
+#endif
+		ret154 =(int)(uintptr_t)(liblock_execute_operation(env, fname->mutex,
+					  (void *)(uintptr_t)(&instance161), &function162));
+		ret = instance161.output158.ret;
+		}
+		if (ret154) {
+			if (ret154 == 153 + 1)
+				{
+					DB_ASSERT(env, fname->txn_ref != 0);
+					ret = __dbreg_close_id_int(env, fname, DBREG_CLOSE, 0);
+					return;
+				}
+			
+		}
 #define END }
 	END;
 
@@ -533,8 +620,10 @@ __txn_remove_fe_watermark(txn, db)
 {
 	DB *db_tmp;
 
-	if (txn == NULL || !F_ISSET(txn, TXN_BULK))
-		return;
+	if (txn == NULL || !F_ISSET(txn, TXN_BULK)) {
+		
+			return;
+		}
 
 	TAILQ_FOREACH(db_tmp, &txn->femfs, felink) {
 		if (db_tmp == db) {
@@ -542,6 +631,7 @@ __txn_remove_fe_watermark(txn, db)
 			break;
 		}
 	}
+	db_tmp = db_tmp;
 }
 
 /*
@@ -562,8 +652,10 @@ __txn_add_fe_watermark(txn, db, pgno)
 {
 	MPOOLFILE *mfp;
 
-	if (txn == NULL || !F_ISSET(txn, TXN_BULK))
-		return;
+	if (txn == NULL || !F_ISSET(txn, TXN_BULK)) {
+		
+			return;
+		}
 
 	mfp = db->mpf->mfp;
 	/* If the watermark is already set, there's nothing to do. */
@@ -608,9 +700,12 @@ __txn_flush_fe_files(txn)
 	TAILQ_FOREACH(db, &txn->femfs, felink) {
 		if (db->mpf->mfp->fe_nlws > 0 &&
 		    (ret = __memp_sync_int(env, db->mpf, 0,
-		    DB_SYNC_FILE, NULL, NULL)))
-			return (ret);
+		    DB_SYNC_FILE, NULL, NULL))) {
+			
+				return (ret);
+			}
 	}
+	db = db;
 
 	return (0);
 }
@@ -637,8 +732,10 @@ __txn_pg_above_fe_watermark(txn, mpf, pg
 	int skip;
 
 	if (txn == NULL || (!F_ISSET(txn, TXN_BULK)) ||
-	    mpf->fe_watermark == PGNO_INVALID)
-		return (0);
+	    mpf->fe_watermark == PGNO_INVALID) {
+		
+			return (0);
+		}
 
 	env = txn->mgrp->env;
 
@@ -647,8 +744,10 @@ __txn_pg_above_fe_watermark(txn, mpf, pg
 	if (((DB_TXNREGION *)env->tx_handle->reginfo.primary)->n_hotbackup > 0)
 		skip = 1;
 	TXN_SYSTEM_UNLOCK(env);
-	if (skip)
-		return (0);
+	if (skip) {
+		
+			return (0);
+		}
 
 	/*
 	 * If the watermark is a valid page number, then the extending
diff -u -p a/db-5.2.28.NC/src/txn/txn_stat.c b/db-5.2.28.NC/src/txn/txn_stat.c
--- a/db-5.2.28.NC/src/txn/txn_stat.c
+++ b/db-5.2.28.NC/src/txn/txn_stat.c
@@ -125,8 +125,8 @@ __txn_stat(env, statp, flags)
 	__mutex_set_wait_info(env, region->mtx_region,
 	    &stats->st_region_wait, &stats->st_region_nowait);
 	stats->st_regsize = (roff_t)mgr->reginfo.rp->size;
-	if (LF_ISSET(DB_STAT_CLEAR)) {
-		if (!LF_ISSET(DB_STAT_SUBSYSTEM))
+	if (((flags) & (DB_STAT_CLEAR))) {
+		if (!((flags) & (DB_STAT_SUBSYSTEM)))
 			__mutex_clear(env, region->mtx_region);
 		memset(&region->stat, 0, sizeof(region->stat));
 		region->stat.st_maxtxns = region->maxtxns;
@@ -188,14 +188,14 @@ __txn_stat_print(env, flags)
 	int ret;
 
 	orig_flags = flags;
-	LF_CLR(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM);
-	if (flags == 0 || LF_ISSET(DB_STAT_ALL)) {
+	((flags) &= ~(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM));
+	if (flags == 0 || ((flags) & (DB_STAT_ALL))) {
 		ret = __txn_print_stats(env, orig_flags);
 		if (flags == 0 || ret != 0)
 			return (ret);
 	}
 
-	if (LF_ISSET(DB_STAT_ALL) &&
+	if (((flags) & (DB_STAT_ALL)) &&
 	    (ret = __txn_print_all(env, orig_flags)) != 0)
 		return (ret);
 
@@ -224,7 +224,7 @@ __txn_print_stats(env, flags)
 	if ((ret = __txn_stat(env, &sp, flags)) != 0)
 		return (ret);
 
-	if (LF_ISSET(DB_STAT_ALL))
+	if (((flags) & (DB_STAT_ALL)))
 		__db_msg(env, "Default transaction region information:");
 	__db_msg(env, "%lu/%lu\t%s",
 	    (u_long)sp->st_last_ckp.file, (u_long)sp->st_last_ckp.offset,
diff -u -p a/db-5.2.28.NC/src/xa/xa.c b/db-5.2.28.NC/src/xa/xa.c
--- a/db-5.2.28.NC/src/xa/xa.c
+++ b/db-5.2.28.NC/src/xa/xa.c
@@ -114,7 +114,7 @@ __xa_get_txn(env, xid, td, txnp, flags,
 	 */
 	if (td == NULL) {
 		DB_ASSERT(env, ending == 0);
-		if (LF_ISSET(TMJOIN | TMRESUME))
+		if (((flags) & (TMJOIN | TMRESUME)))
 			ret = XAER_NOTA;
 		else if ((ret = __txn_begin(env,
 		    ip, NULL, txnp, DB_TXN_NOWAIT)) != 0) {
@@ -138,7 +138,7 @@ __xa_get_txn(env, xid, td, txnp, flags,
 		}
 	} else {
 		/* If we get here, the tranaction exists. */
-		if (ending == 0 && !LF_ISSET(TMRESUME) && !LF_ISSET(TMJOIN)) {
+		if (ending == 0 && !((flags) & (TMRESUME)) && !((flags) & (TMJOIN))) {
 			ret = XAER_DUPID;
 			goto out;
 		}
@@ -161,7 +161,7 @@ __xa_get_txn(env, xid, td, txnp, flags,
 				    TXN_XA_THREAD_ASSOCIATED);
 				DB_ASSERT(env, (*txnp) ==
 				    SH_TAILQ_FIRST(&ip->dbth_xatxn, __db_txn));
-			} else if (LF_ISSET(TMRESUME)) {
+			} else if (((flags) & (TMRESUME))) {
 				DB_ASSERT(env, (*txnp)->xa_thr_status ==
 				    TXN_XA_THREAD_SUSPENDED);
 				DB_ASSERT(env, ip->dbth_xa_status ==
@@ -181,7 +181,7 @@ __xa_get_txn(env, xid, td, txnp, flags,
 			} else
 				ret = XAER_PROTO;
 		} else {
-			if (LF_ISSET(TMRESUME)) {
+			if (((flags) & (TMRESUME))) {
 				dbenv->err(dbenv, EINVAL, DB_STR("4542",
 				    "xa_get_txn: transaction does not exist"));
 				ret = XAER_PROTO;
@@ -310,7 +310,7 @@ __db_xa_open(xa_info, rmid, arg_flags)
 	flags = (u_long)arg_flags;	/* Conversion for bit operations. */
 	ret = 0;
 
-	if (LF_ISSET(TMASYNC))
+	if (((flags) & (TMASYNC)))
 		return (XAER_ASYNC);
 	if (flags != TMNOFLAGS)
 		return (XAER_INVAL);
@@ -410,7 +410,7 @@ __db_xa_close(xa_info, rmid, arg_flags)
 
 	flags = (u_long)arg_flags;	/* Conversion for bit operations. */
 
-	if (LF_ISSET(TMASYNC))
+	if (((flags) & (TMASYNC)))
 		return (XAER_ASYNC);
 	if (flags != TMNOFLAGS)
 		return (XAER_INVAL);
@@ -492,13 +492,13 @@ __db_xa_start(xid, rmid, arg_flags)
 	ret = 0;
 
 #define	OK_FLAGS	(TMJOIN | TMRESUME | TMNOWAIT | TMASYNC | TMNOFLAGS)
-	if (LF_ISSET(~OK_FLAGS))
+	if (((flags) & (~OK_FLAGS)))
 		return (XAER_INVAL);
 
-	if (LF_ISSET(TMJOIN) && LF_ISSET(TMRESUME))
+	if (((flags) & (TMJOIN)) && ((flags) & (TMRESUME)))
 		return (XAER_INVAL);
 
-	if (LF_ISSET(TMASYNC))
+	if (((flags) & (TMASYNC)))
 		return (XAER_ASYNC);
 
 	if (__db_rmid_to_env(rmid, &env) != 0)
@@ -555,7 +555,7 @@ __db_xa_end(xid, rmid, arg_flags)
 	u_long flags;
 
 	flags = (u_long)arg_flags;	/* Convert for bit manipulation. */
-	if (flags != TMNOFLAGS && !LF_ISSET(TMSUSPEND | TMSUCCESS | TMFAIL))
+	if (flags != TMNOFLAGS && !((flags) & (TMSUSPEND | TMSUCCESS | TMFAIL)))
 		return (XAER_INVAL);
 
 	if (__db_rmid_to_env(rmid, &env) != 0)
@@ -615,7 +615,7 @@ __db_xa_end(xid, rmid, arg_flags)
 	 */
 	if (td->xa_ref == 1 && td->xa_br_status == TXN_XA_ACTIVE)
 		td->xa_br_status = TXN_XA_IDLE;
-	if (LF_ISSET(TMSUSPEND)) {
+	if (((flags) & (TMSUSPEND))) {
 		txn->thread_info->dbth_xa_status = TXN_XA_THREAD_SUSPENDED;
 		txn->xa_thr_status = TXN_XA_THREAD_SUSPENDED;
 	} else {
@@ -700,7 +700,7 @@ __db_xa_prepare(xid, rmid, arg_flags)
 	flags = (u_long)arg_flags;	/* Conversion for bit operations. */
 	ret = 0;
 
-	if (LF_ISSET(TMASYNC))
+	if (((flags) & (TMASYNC)))
 		return (XAER_ASYNC);
 	if (flags != TMNOFLAGS)
 		return (XAER_INVAL);
@@ -786,11 +786,11 @@ __db_xa_commit(xid, rmid, arg_flags)
 	flags = (u_long)arg_flags;	/* Conversion for bit operations. */
 	ret = 0;
 
-	if (LF_ISSET(TMASYNC))
+	if (((flags) & (TMASYNC)))
 		return (XAER_ASYNC);
 #undef	OK_FLAGS
 #define	OK_FLAGS	(TMNOFLAGS | TMNOWAIT | TMONEPHASE)
-	if (LF_ISSET(~OK_FLAGS))
+	if (((flags) & (~OK_FLAGS)))
 		return (XAER_INVAL);
 
 	/*
@@ -830,13 +830,13 @@ __db_xa_commit(xid, rmid, arg_flags)
 	if (td->xa_br_status == TXN_XA_ROLLEDBACK)
 		return (XA_RBOTHER);
 
-	if (LF_ISSET(TMONEPHASE) && td->xa_br_status != TXN_XA_IDLE) {
+	if (((flags) & (TMONEPHASE)) && td->xa_br_status != TXN_XA_IDLE) {
 		dbenv->err(dbenv, EINVAL, DB_STR("4561",
 		    "xa_commit: commiting transaction active in branch"));
 		return (XAER_PROTO);
 	}
 
-	if (!LF_ISSET(TMONEPHASE) && td->xa_br_status != TXN_XA_PREPARED) {
+	if (!((flags) & (TMONEPHASE)) && td->xa_br_status != TXN_XA_PREPARED) {
 		dbenv->err(dbenv, EINVAL, DB_STR("4562",
 		    "xa_commit: attempting to commit unprepared transaction"));
 		return (XAER_PROTO);
@@ -884,9 +884,9 @@ __db_xa_recover(xids, count, rmid, flags
 	if (__db_rmid_to_env(rmid, &env) != 0)
 		return (XAER_PROTO);
 
-	if (LF_ISSET(TMSTARTRSCAN))
+	if (((flags) & (TMSTARTRSCAN)))
 		newflags = DB_FIRST;
-	else if (LF_ISSET(TMENDRSCAN))
+	else if (((flags) & (TMENDRSCAN)))
 		newflags = DB_LAST;
 	else
 		newflags = DB_NEXT;
@@ -922,7 +922,7 @@ __db_xa_rollback(xid, rmid, arg_flags)
 	flags = (u_long)arg_flags;	/* Conversion for bit operations. */
 	ret = 0;
 
-	if (LF_ISSET(TMASYNC))
+	if (((flags) & (TMASYNC)))
 		return (XAER_ASYNC);
 	if (flags != TMNOFLAGS)
 		return (XAER_INVAL);
@@ -1008,7 +1008,7 @@ __db_xa_forget(xid, rmid, arg_flags)
 
 	flags = (u_long)arg_flags;	/* Conversion for bit operations. */
 
-	if (LF_ISSET(TMASYNC))
+	if (((flags) & (TMASYNC)))
 		return (XAER_ASYNC);
 	if (flags != TMNOFLAGS)
 		return (XAER_INVAL);
diff -u -p a/db-5.2.28.NC/src/repmgr/repmgr_stat.c b/db-5.2.28.NC/src/repmgr/repmgr_stat.c
--- a/db-5.2.28.NC/src/repmgr/repmgr_stat.c
+++ b/db-5.2.28.NC/src/repmgr/repmgr_stat.c
@@ -68,7 +68,7 @@ __repmgr_stat(env, statp, flags)
 		return (ret);
 
 	memcpy(copy, stats, sizeof(*stats));
-	if (LF_ISSET(DB_STAT_CLEAR)) {
+	if (((flags) & (DB_STAT_CLEAR))) {
 		tmp = stats->st_max_elect_threads;
 		memset(stats, 0, sizeof(DB_REPMGR_STAT));
 		stats->st_max_elect_threads = tmp;
@@ -116,15 +116,15 @@ __repmgr_stat_print(env, flags)
 	int ret;
 
 	orig_flags = flags;
-	LF_CLR(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM);
-	if (flags == 0 || LF_ISSET(DB_STAT_ALL)) {
+	((flags) &= ~(DB_STAT_CLEAR | DB_STAT_SUBSYSTEM));
+	if (flags == 0 || ((flags) & (DB_STAT_ALL))) {
 		if ((ret = __repmgr_print_stats(env, orig_flags)) == 0)
 			ret = __repmgr_print_sites(env);
 		if (flags == 0 || ret != 0)
 			return (ret);
 	}
 
-	if (LF_ISSET(DB_STAT_ALL) &&
+	if (((flags) & (DB_STAT_ALL)) &&
 	    (ret = __repmgr_print_all(env, orig_flags)) != 0)
 		return (ret);
 
diff -u -p a/db-5.2.28.NC/src/repmgr/repmgr_sel.c b/db-5.2.28.NC/src/repmgr/repmgr_sel.c
--- a/db-5.2.28.NC/src/repmgr/repmgr_sel.c
+++ b/db-5.2.28.NC/src/repmgr/repmgr_sel.c
@@ -1718,7 +1718,7 @@ process_parameters(env, conn, host, port
 		 * "orphans" list.  But now that we've received the parameters
 		 * we'll be able to figure all that out.
 		 */
-		if (LF_ISSET(APP_CHANNEL_CONNECTION)) {
+		if (((flags) & (APP_CHANNEL_CONNECTION))) {
 			conn->type = APP_CONNECTION;
 			return (0);
 		} else
@@ -1734,7 +1734,7 @@ process_parameters(env, conn, host, port
 			conn->ref_count--;
 
 			eid = EID_FROM_SITE(site);
-			if (LF_ISSET(REPMGR_SUBORDINATE)) {
+			if (((flags) & (REPMGR_SUBORDINATE))) {
 				/*
 				 * Accept it, as a supplementary source of
 				 * input, but nothing else.
@@ -1843,7 +1843,7 @@ process_parameters(env, conn, host, port
 	 */
 	if (!IS_SUBORDINATE(db_rep) && /* us */
 	    !__repmgr_master_is_known(env) &&
-	    !LF_ISSET(REPMGR_SUBORDINATE)) { /* the remote site */
+	    !((flags) & (REPMGR_SUBORDINATE))) { /* the remote site */
 		RPRINT(env, (env, DB_VERB_REPMGR_MISC,
 		    "handshake with no known master to wake election thread"));
 		db_rep->new_connection = TRUE;
diff -u -p a/db-5.2.28.NC/src/repmgr/repmgr_posix.c b/db-5.2.28.NC/src/repmgr/repmgr_posix.c
--- a/db-5.2.28.NC/src/repmgr/repmgr_posix.c
+++ b/db-5.2.28.NC/src/repmgr/repmgr_posix.c
@@ -68,7 +68,7 @@ __repmgr_thread_start(env, runnable)
 	runnable->quit_requested = FALSE;
 	runnable->env = env;
 
-	return (pthread_create(&runnable->thread_id, attrp,
+	return (liblock_thread_create(&runnable->thread_id, attrp,
 		    runnable->run, runnable));
 }
 
diff -u -p a/db-5.2.28.NC/src/repmgr/repmgr_net.c b/db-5.2.28.NC/src/repmgr/repmgr_net.c
--- a/db-5.2.28.NC/src/repmgr/repmgr_net.c
+++ b/db-5.2.28.NC/src/repmgr/repmgr_net.c
@@ -300,7 +300,7 @@ __repmgr_send(dbenv, control, rec, lsnp,
 		 * be trying to establish its first set of lease grants.
 		 */
 		if (IS_USING_LEASES(env) && !rep->stat.st_startup_complete)
-			LF_CLR(DB_REP_ANYWHERE);
+			((flags) &= ~(DB_REP_ANYWHERE));
 		/*
 		 * If this is a request that can be sent anywhere, then see if
 		 * we can send it to our peer (to save load on the master), but
@@ -359,7 +359,7 @@ __repmgr_send(dbenv, control, rec, lsnp,
 	 * policy, there's no point waiting for something that will never
 	 * happen.
 	 */
-	if (LF_ISSET(DB_REP_PERMANENT)) {
+	if (((flags) & (DB_REP_PERMANENT))) {
 		/* Adjust so as not to count the local site. */
 		nclients = db_rep->region->config_nsites -1;
 
@@ -503,7 +503,7 @@ __repmgr_send(dbenv, control, rec, lsnp,
 	}
 
 out:	UNLOCK_MUTEX(db_rep->mutex);
-	if (LF_ISSET(DB_REP_PERMANENT)) {
+	if (((flags) & (DB_REP_PERMANENT))) {
 		if (ret != 0) {
 			switch (db_rep->active_gmdb_update) {
 			case none:
@@ -1124,7 +1124,7 @@ __repmgr_bust_connection(env, conn)
 			 */
 			flags = ELECT_F_EVENT_NOTIFY;
 			if (FLD_ISSET(db_rep->region->config, REP_C_ELECTIONS))
-				LF_SET(ELECT_F_IMMED | ELECT_F_FAST);
+				((flags) |= (ELECT_F_IMMED | ELECT_F_FAST));
 			else
 				RPRINT(env, (env, DB_VERB_REPMGR_MISC,
 				    "Master failure, but no elections"));
diff -u -p a/db-5.2.28.NC/src/repmgr/repmgr_elect.c b/db-5.2.28.NC/src/repmgr/repmgr_elect.c
--- a/db-5.2.28.NC/src/repmgr/repmgr_elect.c
+++ b/db-5.2.28.NC/src/repmgr/repmgr_elect.c
@@ -403,7 +403,7 @@ __repmgr_elect(env, flags, failtimep)
 	else
 		nvotes = ELECTION_MAJORITY(nsites);
 
-	if (LF_ISSET(ELECT_F_INVITEE)) {
+	if (((flags) & (ELECT_F_INVITEE))) {
 		/*
 		 * We're going to the election party because we were invited by
 		 * another site.  Accept the other site's suggested value, if
@@ -418,7 +418,7 @@ __repmgr_elect(env, flags, failtimep)
 			nsites = invitation;
 		}
 	}
-	if (LF_ISSET(ELECT_F_FAST) && nsites > nvotes) {
+	if (((flags) & (ELECT_F_FAST)) && nsites > nvotes) {
 		/*
 		 * If we're doing an election because we noticed that the master
 		 * failed, it's reasonable to expect that the master won't
diff -u -p a/db-5.2.28.NC/src/repmgr/repmgr_msg.c b/db-5.2.28.NC/src/repmgr/repmgr_msg.c
--- a/db-5.2.28.NC/src/repmgr/repmgr_msg.c
+++ b/db-5.2.28.NC/src/repmgr/repmgr_msg.c
@@ -528,6 +528,7 @@ send_permlsn(env, generation, lsn)
 			    conn, generation, lsn)) != 0)
 				goto unlock;
 		}
+		conn = conn;
 	}
 	if (bcast) {
 		/*
diff -u -p a/db-5.2.28.NC/src/repmgr/repmgr_method.c b/db-5.2.28.NC/src/repmgr/repmgr_method.c
--- a/db-5.2.28.NC/src/repmgr/repmgr_method.c
+++ b/db-5.2.28.NC/src/repmgr/repmgr_method.c
@@ -410,7 +410,7 @@ __repmgr_valid_config(env, flags)
 	LOCK_MUTEX(db_rep->mutex);
 
 	/* (Can't check IS_SUBORDINATE if select thread isn't running yet.) */
-	if (LF_ISSET(REP_C_ELECTIONS) &&
+	if (((flags) & (REP_C_ELECTIONS)) &&
 	    db_rep->selector != NULL && IS_SUBORDINATE(db_rep)) {
 		__db_errx(env, DB_STR("3642",
 	    "can't configure repmgr elections from subordinate process"));
@@ -1606,7 +1606,7 @@ __repmgr_send_request(db_channel, reques
 
 	meta.tag = i;
 	meta.flags = REPMGR_REQUEST_MSG_TYPE |
-	    (LF_ISSET(DB_MULTIPLE) ? REPMGR_MULTI_RESP : 0) |
+	    (((flags) & (DB_MULTIPLE)) ? REPMGR_MULTI_RESP : 0) |
 	    (F_ISSET(response, DB_DBT_USERMEM) ? REPMGR_RESPONSE_LIMIT : 0);
 	meta.limit = response->ulen;
 
@@ -1660,7 +1660,7 @@ __repmgr_send_request(db_channel, reques
 	if (ret == 0) {
 		DB_ASSERT(env, F_ISSET(resp, RESP_COMPLETE));
 		*response = resp->dbt;
-		if ((ret = resp->ret) == 0 && LF_ISSET(DB_MULTIPLE))
+		if ((ret = resp->ret) == 0 && ((flags) & (DB_MULTIPLE)))
 			adjust_bulk_response(env, response);
 		F_CLR(resp, RESP_IN_USE | RESP_THREAD_WAITING);
 
@@ -1755,7 +1755,7 @@ request_self(env, request, nrequest, res
 	channel.response.dbt = *response;
 
 	meta.flags = REPMGR_REQUEST_MSG_TYPE |
-	    (LF_ISSET(DB_MULTIPLE) ? REPMGR_MULTI_RESP : 0) |
+	    (((flags) & (DB_MULTIPLE)) ? REPMGR_MULTI_RESP : 0) |
 	    (F_ISSET(response, DB_DBT_USERMEM) ? REPMGR_RESPONSE_LIMIT : 0);
 	meta.limit = response->ulen;
 
@@ -1769,7 +1769,7 @@ request_self(env, request, nrequest, res
 	} else {
 		response->data = channel.response.dbt.data;
 		response->size = channel.response.dbt.size;
-		if (LF_ISSET(DB_MULTIPLE))
+		if (((flags) & (DB_MULTIPLE)))
 			adjust_bulk_response(env, response);
 	}
 	return (0);
diff -u -p a/db-5.2.28.NC/src/repmgr/repmgr_util.c b/db-5.2.28.NC/src/repmgr/repmgr_util.c
--- a/db-5.2.28.NC/src/repmgr/repmgr_util.c
+++ b/db-5.2.28.NC/src/repmgr/repmgr_util.c
@@ -87,6 +87,7 @@ __repmgr_schedule_connection_attempt(env
 			if (timespeccmp(&target->time, &t, >))
 				break;
 		}
+		target = target;
 		if (target == NULL)
 			TAILQ_INSERT_TAIL(&db_rep->retries, retry, entries);
 		else
diff -u -p a/db-5.2.28.NC/util/db_recover.c b/db-5.2.28.NC/util/db_recover.c
--- a/db-5.2.28.NC/util/db_recover.c
+++ b/db-5.2.28.NC/util/db_recover.c
@@ -135,10 +135,9 @@ main(argc, argv)
 	 * certainly use DB_CONFIG files in the directory.
 	 */
 	flags = 0;
-	LF_SET(DB_CREATE | DB_INIT_LOG |
-	    DB_INIT_MPOOL | DB_INIT_TXN | DB_USE_ENVIRON);
-	LF_SET(fatal_recover ? DB_RECOVER_FATAL : DB_RECOVER);
-	LF_SET(retain_env ? DB_INIT_LOCK : DB_PRIVATE);
+	((flags) |= (DB_CREATE | DB_INIT_LOG | DB_INIT_MPOOL | DB_INIT_TXN | DB_USE_ENVIRON));
+	((flags) |= (fatal_recover ? DB_RECOVER_FATAL : DB_RECOVER));
+	((flags) |= (retain_env ? DB_INIT_LOCK : DB_PRIVATE));
 	if ((ret = dbenv->open(dbenv, home, flags, 0)) != 0) {
 		dbenv->err(dbenv, ret, "DB_ENV->open");
 		goto err;
diff -u -p a/db-5.2.28.NC/util/db_stat.c b/db-5.2.28.NC/util/db_stat.c
--- a/db-5.2.28.NC/util/db_stat.c
+++ b/db-5.2.28.NC/util/db_stat.c
@@ -59,7 +59,7 @@ main(argc, argv)
 	    argv, "aC:cd:Eefgh:L:lM:mNP:R:rs:tVxX:Z")) != EOF)
 		switch (ch) {
 		case 'a':
-			LF_SET(DB_STAT_ALLOC);
+			((flags) |= (DB_STAT_ALLOC));
 			break;
 		case 'C': case 'c':
 			if (ttype != T_NOTSET && ttype != T_LOCK)
@@ -69,21 +69,21 @@ main(argc, argv)
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 					case 'A':
-						LF_SET(DB_STAT_ALL);
+						((flags) |= (DB_STAT_ALL));
 						break;
 					case 'c':
-						LF_SET(DB_STAT_LOCK_CONF);
+						((flags) |= (DB_STAT_LOCK_CONF));
 						break;
 					case 'l':
-						LF_SET(DB_STAT_LOCK_LOCKERS);
+						((flags) |= (DB_STAT_LOCK_LOCKERS));
 						break;
 					case 'm': /* Backward compatible. */
 						break;
 					case 'o':
-						LF_SET(DB_STAT_LOCK_OBJECTS);
+						((flags) |= (DB_STAT_LOCK_OBJECTS));
 						break;
 					case 'p':
-						LF_SET(DB_STAT_LOCK_PARAMS);
+						((flags) |= (DB_STAT_LOCK_PARAMS));
 						break;
 					default:
 						return (usage());
@@ -99,15 +99,15 @@ main(argc, argv)
 			if (ttype != T_NOTSET && ttype != T_ENV)
 				goto argcombo;
 			ttype = T_ENV;
-			LF_SET(DB_STAT_SUBSYSTEM);
+			((flags) |= (DB_STAT_SUBSYSTEM));
 			if (ch == 'E')
-				LF_SET(DB_STAT_ALL);
+				((flags) |= (DB_STAT_ALL));
 			break;
 		case 'f':
 			if (ttype != T_NOTSET && ttype != T_DB)
 				goto argcombo;
 			ttype = T_DB;
-			LF_SET(DB_FAST_STAT);
+			((flags) |= (DB_FAST_STAT));
 			break;
 		case 'h':
 			home = optarg;
@@ -120,7 +120,7 @@ main(argc, argv)
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 					case 'A':
-						LF_SET(DB_STAT_ALL);
+						((flags) |= (DB_STAT_ALL));
 						break;
 					default:
 						return (usage());
@@ -134,10 +134,10 @@ main(argc, argv)
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 					case 'A':
-						LF_SET(DB_STAT_ALL);
+						((flags) |= (DB_STAT_ALL));
 						break;
 					case 'h':
-						LF_SET(DB_STAT_MEMP_HASH);
+						((flags) |= (DB_STAT_MEMP_HASH));
 						break;
 					case 'm': /* Backward compatible. */
 						break;
@@ -166,7 +166,7 @@ main(argc, argv)
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 					case 'A':
-						LF_SET(DB_STAT_ALL);
+						((flags) |= (DB_STAT_ALL));
 						break;
 					default:
 						return (usage());
@@ -198,14 +198,14 @@ argcombo:			fprintf(stderr, DB_STR_A("50
 				for (p = optarg; *p; ++p)
 					switch (*p) {
 						case 'A':
-							LF_SET(DB_STAT_ALL);
+							((flags) |= (DB_STAT_ALL));
 							break;
 						default:
 							return (usage());
 					}
 			break;
 		case 'Z':
-			LF_SET(DB_STAT_CLEAR);
+			((flags) |= (DB_STAT_CLEAR));
 			break;
 		case '?':
 		default:
@@ -231,7 +231,7 @@ argcombo:			fprintf(stderr, DB_STR_A("50
 		return (usage());
 	}
 
-	if (LF_ISSET(DB_STAT_ALL | DB_STAT_ALLOC) == DB_STAT_ALLOC)
+	if (((flags) & (DB_STAT_ALL | DB_STAT_ALLOC)) == DB_STAT_ALLOC)
 		return (usage());
 
 	/* Handle possible interruptions. */
diff -u -p a/db-5.2.28.NC/util/db_upgrade.c b/db-5.2.28.NC/util/db_upgrade.c
--- a/db-5.2.28.NC/util/db_upgrade.c
+++ b/db-5.2.28.NC/util/db_upgrade.c
@@ -65,7 +65,7 @@ main(argc, argv)
 			}
 			break;
 		case 's':
-			LF_SET(DB_DUPSORT);
+			((flags) |= (DB_DUPSORT));
 			break;
 		case 'V':
 			printf("%s\n", db_version(NULL, NULL, NULL));
diff -u -p a/db-5.2.28.NC/util/db_load.c b/db-5.2.28.NC/util/db_load.c
--- a/db-5.2.28.NC/util/db_load.c
+++ b/db-5.2.28.NC/util/db_load.c
@@ -302,7 +302,7 @@ load(dbenv, name, argtype, clist, flags,
 	int ascii_recno, checkprint, hexkeys, keyflag, keys, resize, ret, rval;
 	char *subdb;
 
-	put_flags = LF_ISSET(LDF_NOOVERWRITE) ? DB_NOOVERWRITE : 0;
+	put_flags = ((flags) & (LDF_NOOVERWRITE)) ? DB_NOOVERWRITE : 0;
 	G(endodata) = 0;
 
 	dbc = NULL;
@@ -326,7 +326,7 @@ retry_db:
 	}
 
 	/* Read the header -- if there's no header, we expect flat text. */
-	if (LF_ISSET(LDF_NOHEADER)) {
+	if (((flags) & (LDF_NOHEADER))) {
 		checkprint = 1;
 		dbtype = argtype;
 	} else {
@@ -420,7 +420,7 @@ retry_db:
 		ascii_recno = 0;
 
 	/* If configured with a password, encrypt databases we create. */
-	if (LF_ISSET(LDF_PASSWORD) &&
+	if (((flags) & (LDF_PASSWORD)) &&
 	    (ret = dbp->set_flags(dbp, DB_ENCRYPT)) != 0) {
 		dbp->err(dbp, ret, "DB->set_flags: DB_ENCRYPT");
 		goto err;
@@ -692,8 +692,8 @@ db_init(dbenv, home, cache, is_private)
 	 * an mpool region exists).  Create one, but make it private so that
 	 * no files are actually created.
 	 */
-	LF_CLR(DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_TXN);
-	LF_SET(DB_CREATE | DB_PRIVATE);
+	((flags) &= ~(DB_INIT_LOCK | DB_INIT_LOG | DB_INIT_TXN));
+	((flags) |= (DB_CREATE | DB_PRIVATE));
 	*is_private = 1;
 	if ((ret = dbenv->set_cachesize(dbenv, 0, cache, 1)) != 0) {
 		dbenv->err(dbenv, ret, "set_cachesize");
diff -u -p a/db-5.2.28.NC/util/db_archive.c b/db-5.2.28.NC/util/db_archive.c
--- a/db-5.2.28.NC/util/db_archive.c
+++ b/db-5.2.28.NC/util/db_archive.c
@@ -49,16 +49,16 @@ main(argc, argv)
 	while ((ch = getopt(argc, argv, "adh:lP:sVv")) != EOF)
 		switch (ch) {
 		case 'a':
-			LF_SET(DB_ARCH_ABS);
+			((flags) |= (DB_ARCH_ABS));
 			break;
 		case 'd':
-			LF_SET(DB_ARCH_REMOVE);
+			((flags) |= (DB_ARCH_REMOVE));
 			break;
 		case 'h':
 			home = optarg;
 			break;
 		case 'l':
-			LF_SET(DB_ARCH_LOG);
+			((flags) |= (DB_ARCH_LOG));
 			break;
 		case 'P':
 			passwd = strdup(optarg);
@@ -71,7 +71,7 @@ main(argc, argv)
 			}
 			break;
 		case 's':
-			LF_SET(DB_ARCH_DATA);
+			((flags) |= (DB_ARCH_DATA));
 			break;
 		case 'V':
 			printf("%s\n", db_version(NULL, NULL, NULL));
diff -u -p a/db-5.2.28.NC/util/db_verify.c b/db-5.2.28.NC/util/db_verify.c
--- a/db-5.2.28.NC/util/db_verify.c
+++ b/db-5.2.28.NC/util/db_verify.c
@@ -67,13 +67,13 @@ main(argc, argv)
 			}
 			break;
 		case 'o':
-			LF_SET(DB_NOORDERCHK);
+			((flags) |= (DB_NOORDERCHK));
 			break;
 		case 'q':
 			quiet = 1;
 			break;
 		case 'u':			/* Undocumented. */
-			LF_SET(DB_UNREF);
+			((flags) |= (DB_UNREF));
 			break;
 		case 'V':
 			printf("%s\n", db_version(NULL, NULL, NULL));
diff -u -p a/db-5.2.28.NC/test/c/suites/TestKeyExistErrorReturn.c b/db-5.2.28.NC/test/c/suites/TestKeyExistErrorReturn.c
--- a/db-5.2.28.NC/test/c/suites/TestKeyExistErrorReturn.c
+++ b/db-5.2.28.NC/test/c/suites/TestKeyExistErrorReturn.c
@@ -15,6 +15,10 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #include "db.h"
 #include "CuTest.h"
@@ -48,7 +52,7 @@ typedef HANDLE mutex_t;
 
 typedef pthread_t thread_t;
 #define	thread_create(thrp, attr, func, arg)				\
-    pthread_create((thrp), (attr), (func), (arg))
+    liblock_thread_create((thrp), (attr), (func), (arg))
 #define	thread_join(thr, statusp) pthread_join((thr), (statusp))
 
 typedef pthread_mutex_t mutex_t;
diff -u -p a/db-5.2.28.NC/test/c/suites/TestChannel.c b/db-5.2.28.NC/test/c/suites/TestChannel.c
--- a/db-5.2.28.NC/test/c/suites/TestChannel.c
+++ b/db-5.2.28.NC/test/c/suites/TestChannel.c
@@ -12,6 +12,10 @@
 #include <time.h>
 #include <stdlib.h>
 #include <errno.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 #ifndef _WIN32
 #include <pthread.h>
 #include <unistd.h>
diff -u -p a/db-5.2.28.NC/test/micro/source/b_latch.c b/db-5.2.28.NC/test/micro/source/b_latch.c
--- a/db-5.2.28.NC/test/micro/source/b_latch.c
+++ b/db-5.2.28.NC/test/micro/source/b_latch.c
@@ -174,7 +174,7 @@ b_latch(argc, argv)
 #ifdef _POSIX_THREADS
 	if (nthreads > 0) {
 		for (i = 0; i < nthreads; i++)
-			DB_BENCH_ASSERT(pthread_create(&threads[i].id,
+			DB_BENCH_ASSERT(liblock_thread_create(&threads[i].id,
 			    NULL, latch_threadmain, &threads[i]) == 0);
 		for (i = 0; i < nthreads; i++) {
 			ret = pthread_join(threads[i].id, &status);
diff -u -p a/db-5.2.28.NC/test/xa/src3/client.c b/db-5.2.28.NC/test/xa/src3/client.c
--- a/db-5.2.28.NC/test/xa/src3/client.c
+++ b/db-5.2.28.NC/test/xa/src3/client.c
@@ -24,6 +24,10 @@
 #include <fml1632.h>
 
 #include <db.h>
+#include <liblock.h>
+#include <liblock-bd.h>
+//;
+#include <stdint.h>
 
 #define	HOME	"../data"
 #define	TABLE1	"../data/table1.db"
@@ -238,7 +242,7 @@ main(int argc, char* argv[])
 	for (i = 0; i < num_threads; i++) {
 		if (verbose)
 		       printf("calling server thread\n");
-		ret = pthread_create(&threads[i], NULL, 
+		ret = liblock_thread_create(&threads[i], NULL, 
 		    call_server_thread, names[i]);
 		if (ret) {
 		       fprintf(stderr, "%s: failed to create thread %s.\n",
